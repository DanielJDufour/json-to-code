(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.jsonToCode = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
const minQuote = require("min-quote");

const declareVars = ({ vars, comment=false, language="JavaScript", pretty, semi }) => {
  language = language.toUpperCase();
  let lang;
  if (language === "JS" || language === "JAVASCRIPT") lang = "JS";
  else if (language === "PY" || language === "PYTHON") lang = "PY";

  if (semi === undefined) {
    if (lang === "JS") semi = true;
    else if (lang === "PY") semi = false;
  }

  if (pretty === undefined) {
    if (lang === "JS") pretty = false;
    else if (lang === "PY") pretty = true;
  }

  let out = "";
  if (comment) {
    if (lang === "JS") out += "/* " + (typeof comment === "string" ? comment : "declarations") + " */\n";
    if (lang === "PY") out += "# " + (typeof comment === "string" ? comment : "declarations") + "\n";
  }
  if (!pretty && lang === "JS") out += "const ";
  vars.forEach(({ name, value, raw=false }, i) => {
    if (pretty) {
      if (i !== 0) out += "\n";
      out += (lang === "JS" ? "const " : "") + name + "=";
    } else {
      if (i !== 0) {
        if (lang === "JS") out += ",";
        else if (lang === "PY") out += ";";
      }
      out += name + "=";  
    }
    if (typeof value === "number" || raw) {
      out += value;
    } else if (typeof value === "string") {
      out += minQuote(value, { backtick: lang === "JS" });
    }
    if (pretty && semi) out += ";";
  });
  if (semi && !pretty) out += ";"
  return out;
};

module.exports = declareVars;

},{"min-quote":2}],2:[function(require,module,exports){
const minQuote = (str, { debug=false, backtick=true } = { backtick: false, debug: false }) => {
  if (debug) console.log("[min-quote] starting with str:", [str]);
  let quotechars = ["'", '"', "`"];
  let numQuotes = quotechars.length;
  let selection;
  for (let i = 0; i < numQuotes; i++) {
    const char = quotechars[i];
    if (!str.includes(char)) {
      selection = char;
      break;
    }
  }
  let result;
  if (selection) {
    result = selection + str + selection;
  } else {
    // chose the quote that would require the least amount of escaping
    const counts = { "'": 0, '"': 0, "`": 0 };
    for (let i = 0; i < str.length; i++) {
      const char = str[i];
      if (char === "'" || char === '"' || char === "`") {
        counts[char]++;
      }
    }
    if (debug) console.log("[min-quote] counts:", counts);
    const sortedCounts = Object.entries(counts).sort((a, b) => Math.sign(a[1] - b[1]));
    const minCount = sortedCounts[0][1];
    const candidates = sortedCounts.filter(([char, count]) => count === minCount);
    const notBackticks = candidates.filter(([char, count]) => char !== "`");
    if (notBackticks.length >= 1) selection = notBackticks[0][0];
    else selection = candidates[0][0];
    if (debug) console.log("[min-quote] selection:", selection);
    result = selection + str.replace(selection, "\\" + selection) + selection;
  }
  return result;
};

if (typeof module === "object") module.exports = minQuote;
if (typeof window === "object") window.minQuote = minQuote;
if (typeof self === "object") self.minQuote = minQuote;
},{}],3:[function(require,module,exports){
const { forEach } = require("advarr");
const count = require("deep-counter");
const declareVars = require("declare-vars");
const deconcat = require("deconcat");
const walk = require("deepest-walk");
const countNGrams = require("n-gram-counter");
const minQuote = require("min-quote");
const { genVarNames } = require("var-names");
const separo = require("separo");
const striptags = require("striptags");
const textops = require("textops");

const hasStuff = obj => Object.keys(obj).length > 0;

const isFlatArray = it => Array.isArray(it) && it.every(subitem => subitem === null || typeof subitem !== "object");

const isQuoted = str => str.match(/^(['"`]).*\1$/);

// remove wrapping braces
const unbrace = str => str.replace(/^\[/, "").replace(/\]$/);

const forEachFlatArray = (data, cb) => {
  walk({
    data,
    callback: ({ data, mod, type }) => {
      if (isFlatArray(data)) {
        cb({ data, mod, type });
      }
    }
  });
};

const forEachString = (data, cb) => {
  walk({
    data,
    callback: ({ data, mod, type }) => {
      if (typeof data === "string") {
        cb({ str: data, mod, type });
      }
    }
  });
};

// string in code
const toString = it => {
  if (it === null) return "null";
  else if (it === undefined) return "undefined";
  else if (typeof it === "string") return it;
  else if (typeof it === "number") return it.toString();
  else if (Array.isArray(it)) return JSON.stringify(it);
  else throw new Error("to-string failed because unexpected type");
};

const encode = ({ data, debug_level = 0, language = "JavaScript", max_passes = 100, prefix, read_only = true, spacer }) => {
  if (debug_level >= 1) console.log("[encode] starting");
  if (debug_level >= 2) console.log("[encode] data:", JSON.stringify(data).substring(0, 200), "...");

  // normalizing language
  language = language.toUpperCase();
  let lang;
  if (language === "JS" || language === "JAVASCRIPT") lang = "JS";
  else if (language === "PY" || language === "PYTHON") lang = "PY";

  if (prefix == undefined) {
    if (lang === "JS") prefix = "module.exports";
    else if (lang === "PY") prefix = "data";
  }

  const useBacktick = lang === "JS";

  const counts = count({ data, debug_level: debug_level - 1 });
  if (debug_level >= 1) console.log("counts:", counts);

  const stringified = typeof data === "string" ? data : JSON.stringify(data);
  if (debug_level >= 1) console.log("[encode] stringified:", stringified.substring(0, 200), "...");

  /* generate a UID for text operations */
  let uid;
  while (!uid) {
    const num = Math.floor(Math.random() * 1e5).toString();
    if (!stringified.includes(num)) uid = num;
  }
  if (debug_level >= 1) console.log("uid:", uid);

  // a number is always the first and last because there's not such thing as a sub-number (unlike a sub-string)
  const number_counts = Object.values(counts.numbers).map(it => ({
    type: "number",
    value: it.value,
    count: it.count
  }));

  const string_counts = Object.values(counts.strings).map(it => ({
    type: "string",
    value: it.value,
    count: it.count,
    first: it.first,
    last: it.last
  }));

  const all_counts = [...number_counts, ...string_counts];
  if (counts.null) {
    all_counts.push({
      type: "null",
      value: null,
      count: counts.null
    });
  }
  if (counts.undefined) {
    all_counts.push({
      type: "undefined",
      value: undefined,
      count: counts.undefined
    });
  }

  const sorted_counts = all_counts.sort((a, b) => Math.sign(b.count - a.count));
  if (debug_level >= 1) console.log("[encode] sorted counts");
  if (debug_level >= 2) console.log("[encode] sorted_counts:", sorted_counts);

  const tokens = sorted_counts.map(it => {
    try {
      if (debug_level >= 2) console.log("it:", it);

      const { value, count, type } = it;

      const value_string = toString(value);

      if (["null", "number", "undefined"].includes(type)) {
        const value_length = value_string.length;
        const current_cost = count * value_length;
        const savings = {};
        for (let variable_length = 1; variable_length <= 5; variable_length++) {
          // like ,A=123; or ,Ba=null or ,Ab=undefined;
          const declaration_cost = 1 + variable_length + 1 + value_length;
          const replacement_cost = declaration_cost + count * variable_length;
          savings[variable_length] = current_cost - replacement_cost;
        }
        return { value, count, savings };
      } else if (type === "string") {
        const { first, last } = it;
        const percent_start = first / count;
        const percent_end = last / count;
        const not_percent_start = 1 - percent_start;
        const not_percent_end = 1 - percent_end;

        // if it is always preceeded by a space, we will later prepend a " " space
        const pad = first === 0;
        if (debug_level >= 2) console.log("pad:", pad);

        // how many characters the current value takes up
        const value_length = `${pad ? " " : ""}${value_string}`.length;
        if (debug_level >= 2) console.log("value_length:", value_length);

        const current_cost = count * value_length;
        if (debug_level >= 2) console.log("current_cost:", current_cost);

        const savings = {};
        for (let variable_length = 1; variable_length <= 5; variable_length++) {
          // like ,A='+lon_0=105'
          let declaration_length = 1 + variable_length + 1 + 1 + value_length + 1;

          // not factoring in that strings can be keys as well
          // will need to upgrade deep-counter to track additional stats like is the string a complete key, is the string part of a key and position, and is string a substring in a string
          // also need to factor in whether to prepend space or not
          // ?? maybe should factor in assuming strings are replaced before and after with variables ??
          const average_replacement_length = `"+`.length * not_percent_start + variable_length + `"+`.length * not_percent_end;
          // console.log("average_replacement_length:", average_replacement_length);

          const total_replacement_size = declaration_length + average_replacement_length * count;
          if (debug_level >= 3) console.log("total_replacement_size:", total_replacement_size);
          savings[variable_length] = current_cost - total_replacement_size;
        }
        if (debug_level >= 2) console.log("savings:", savings);
        return {
          value: (pad ? " " : "") + it.value,
          count: count,
          first,
          last,
          pad,
          savings
        };
      }
    } catch (error) {
      throw error;
    }
  });
  if (debug_level >= 1) console.log(tokens);

  const skipVarNames = new Set();
  if (lang === "PY") {
    ["and", "as", "is", "or", "null"].forEach(skipword => {
      skipVarNames.add(skipword);
    });
  }

  const varname2token = new Map();
  const token2varname = new Map();

  const gen = genVarNames();
  for (const varname of gen) {
    if (debug_level >= 2) console.log("varname:", varname);
    if (skipVarNames.has(varname)) continue;

    const varlen = varname.length;

    // sort tokens by saving for the given variable's length
    tokens.sort((a, b) => Math.sign(b.savings[varlen] - a.savings[varlen]));

    // pop out the first token
    const token = tokens.shift();

    // if we can save any space with the token with the most potential savings, break
    if (token.savings[varlen] <= 0) break;

    // console.log("token:", token);
    // save the selection

    varname2token.set(varname, { first: token.first, token: token.value });
    token2varname.set(token.value, { varname, first: token.first, value: token.value });
  }
  if (debug_level >= 1) console.log("assigned variable names to tokens");
  if (debug_level >= 2) console.log("token2name:", token2varname);

  // console.log("varname2token['U']:", varname2token['U']);

  // get a clone of the original data
  const result = JSON.parse(stringified);
  if (debug_level >= 1) console.log("cloned original data");
  if (debug_level >= 2) console.log("cloned data:", result);

  const delprevchar = `<delprevchar-${uid}>`;
  const delnextchar = `<delnextchar-${uid}>`;

  // is the string an expression for an object key
  // like [a+b+c] in { [a+b+c]: value }
  const isObjKeyExprFn = ({ str, type }) => {
    return type === "object-key-string" && str.startsWith(delprevchar + "[") && str.endsWith(delnextchar + "]");
  };

  const lookup = x => {
    let varname;
    let varvalue;
    if (token2varname.has(x)) {
      varname = token2varname.get(x).varname;
      varvalue = x;
    } else if (typeof x === "string") {
      if (x.startsWith(" ") && token2varname.has(x.substr(1))) {
        varname = token2varname.get(x.substr(1)).varname;
        varvalue = x.substr(1);
      } else if (!x.startsWith(" ") && token2varname.get(" " + x)) {
        varname = token2varname.get(" " + x).varname;
        varvalue = " " + x;
      }
    }
    return { varname, varvalue };
  };

  const getVarOut = ({ it, varname, varvalue }) => {
    if (typeof it === "string") {
      if (it.startsWith(" ")) {
        if (varvalue.startsWith(" ")) {
          return varname;
        } else {
          return `" "+${varname}`;
        }
      } else if (varvalue.startsWith(" ")) {
        if (lang === "JS") {
          return `${varname}.trim()`;
        } else {
          return `${varnamme}.strip()`;
        }
      }
    }
    return varname;
  };

  const unescp = str =>
    str.replaceAll('"', (match, offset, string) => {
      const before = string.substring(0, offset);
      if (before.endsWith(delnextchar)) return '"';
      else return delnextchar + '"';
    });

  const getExpr = it => {
    const { varname, varvalue } = lookup(it);
    if (varname) return getVarOut({ it, varname, varvalue });
  };

  if (debug_level >= 1) console.log("starting walk");

  // first replacement pass
  // walk through whole object and replace substring and numbers with variables
  walk({
    data: result,
    callback: ({ data: it, mod, type: dataType }) => {
      try {
        if (debug_level >= 2) console.log("walking", { it, dataType });
        if (typeof it === "number") {
          const { varname } = lookup(it);
          if (varname) mod(delprevchar + varname + delnextchar);
        } else if (typeof it === "undefined") {
          const expr = getExpr(it);
          if (expr) mod(delprevchar + expr + delnextchar);
          else mod(delprevchar + "undefined" + delnextchar);
        } else if (it === null) {
          const expr = getExpr(it);
          if (expr) mod(delprevchar + expr + delnextchar);
          else mod(delprevchar + "null" + delnextchar);
        } else if (typeof it === "string") {
          if (["object-key-string", "object-value-string", "array-item-string"].includes(dataType)) {
            const words = separo(it, " ", { attachSep: true }).map(word => {
              const expr = getExpr(word);
              if (expr) return { expr };
              else return { quoted: minQuote(word, { backtick: useBacktick }) };
            });
            if (words.some(word => word.expr)) {
              let modStr = delprevchar;
              if (dataType === "object-key-string" && lang === "JS") modStr += "[";
              forEach(words, ({ it: word, prev, first: firstWord }) => {
                if (word.expr) {
                  if (!firstWord) modStr += "+";
                  modStr += word.expr;
                } else {
                  // current word and previous word use the same quotes
                  if (word.quoted[0] === prev?.quoted?.[0]) {
                    modStr = modStr.slice(0, -1) + word.quoted.slice(1);
                  } else {
                    // 2 strings in a row that share different quotes
                    if (!firstWord) modStr += "+";
                    modStr += word.quoted;
                  }
                }
              });
              if (dataType === "object-key-string" && lang === "JS") modStr += "]";
              modStr += delnextchar;
              mod(unescp(modStr));
            } else {
              mod(delprevchar + unescp(minQuote(it, { backtick: useBacktick })) + delnextchar);
            }
          } else {
            console.log("[json-to-code] it:", { it, dataType });
            throw new Error("unexpected dataType:", dataType);
          }
        }
      } catch (error) {
        console.error("walking error", error);
        throw error;
      }
    }
  });

  /*
    Array to hold variables created from the concatenation of other vars
    For example A=B+C
    And the order is important
  */

  const usedVarNames = new Set(varname2token.keys());
  const all_substitutions = [];
  let pass = 1; // count previous pass for unigrams
  while (pass < max_passes) {
    // holds whether anything changed
    let changed = false;

    // repeat trying to recursively compress bigrams
    // until can't save any more space
    while (pass < max_passes) {
      if (debug_level >= 1) console.log("checking bigram saving opportunities");
      // increment pass now because might break early later if no potential savings
      pass++;

      const substitutions = {};

      // get an array of new varnames of all the same length (i.e. cost)
      const varnames = [];
      let varlen;
      const varNameGen = genVarNames();
      for (const varname of varNameGen) {
        if (usedVarNames.has(varname)) continue;
        if (skipVarNames.has(varname)) continue;
        if (!varlen) varlen = varname.length;
        if (varname.length !== varlen) break;
        varnames.push(varname);
      }
      if (debug_level >= 2) console.log(`${varnames.length} possible varnames with length ${varlen}`);

      // object with
      // key: JSON of bigram array
      // value: raw number count
      const bigram_count = {};

      // we already replaced numbers, nulls, and undefineds in the first pass
      // so we can just focus on strings
      forEachString(result, leaf => {
        let { str } = leaf;

        // remove any text operations like delprevchar and delnextchar
        // assuming text ops are only at the beginning and the end
        // is that a good assumption?
        str = striptags(str);

        // remove wrapping straight braces around variable object keys
        // like going from [a+b] to a+b
        if (isObjKeyExprFn(leaf)) str = unbrace(str);

        // from a+b to array of ["a", "b"]
        const parts = deconcat(str);

        // count sequential pairs
        const bigrams = countNGrams({ data: parts, n: 2 });

        for (let b = 0; b < bigrams.length; b++) {
          const [bigram, subcount] = bigrams[b];
          const [first, second] = bigram;

          // ignore bigrams that include raw strings
          // code currently only handles bigrams made up of 2 variables
          if (isQuoted(first) || isQuoted(second)) continue;

          // convert bigram array to JSON string representation
          const key = JSON.stringify(bigram);
          if (key in bigram_count) bigram_count[key] += subcount;
          else bigram_count[key] = subcount;
        }
      });

      const bigram_savings = [];
      Object.entries(bigram_count).forEach(([bigram, count]) => {
        // convert bigram key to actual array
        const bigram_array = JSON.parse(bigram);

        // bigram is like [ 'E', 'A' ]
        // get length of E+A or 3
        const len = bigram_array.join("+").length;

        // current character count of bigrams
        const current_cost = len * count;

        // declaration cost is , + variable + = + len
        const declaration_cost = 1 + varlen + 1 + len;

        // how many bytes bigram would take up if replaced with a variable
        const replacement_cost = declaration_cost + varlen * count;

        // how many bytes we would save if we replaced a bigram with a variable
        const savings = current_cost - replacement_cost;

        // only care if actually save space
        if (savings > 0) bigram_savings.push([bigram, savings]);
      });

      // no more opportunities to save space
      // breaks out of only inner loop for bigrams
      if (bigram_savings.length === 0) break;

      // sort bigram savings array from smallest to largest savings
      bigram_savings.sort((a, b) => Math.sign(a[1] - b[1]));

      // console.log(`bigram_savings (${bigram_savings.length}) :`, bigram_savings.slice(0, 3));

      // iterate through varnames of the same length
      // assigning bigrams to the remaining names
      const bigram_to_varname = {};
      for (let v = 0; v < varnames.length; v++) {
        const varname = varnames[v];

        // pop off the last bigram which has the biggest savings
        const bigram = bigram_savings.pop()[0];

        // bigram is already JSON stringified
        bigram_to_varname[bigram] = varname;

        // no more bigrams to replace
        // seems we have more potential variable names
        // than actual replaceable bigrams
        if (bigram_savings.length === 0) break;
      }

      // walk through data and make substitutions
      forEachString(result, leaf => {
        let { str, mod, type } = leaf;

        const hasDelPrev = str.startsWith(delprevchar);
        const hasDelNext = str.endsWith(delnextchar);

        // remove text operations
        str = striptags(str);

        let isObjKeyExpr = isObjKeyExprFn(leaf);

        // remove wrapping straight braces around variable object keys
        // like going from [a+b] to a+b
        if (isObjKeyExpr) str = unbrace(str);

        // converts D+' +lat=39'+u+CO into ["D", "' +lat=39'", "u", "CO"], so can be combined again with +
        const parts = deconcat(str);

        // parts of string with variable substitution
        const swapped = [];

        let needToMod = false;
        if (parts.length === 1) {
          swapped.push(parts[0]);
        } else {
          // can only replace bigrams if have more than one gram
          for (let p = 1; p < parts.length; p++) {
            const prev = parts[p - 1];
            const curr = parts[p];
            const bigram = [prev, curr];
            const key = JSON.stringify(bigram);
            if (key in bigram_to_varname) {
              needToMod = true;
              if (type === "object-key-string") isObjKeyExpr = true;
              const varname = bigram_to_varname[key];
              swapped.push(varname);
              usedVarNames.add(varname);
              substitutions[key] = varname;
              p++; // skip checking the next bigram (because curr would be prev for that)

              // there's only one gram left, so we know that it won't be replaced
              if (p === parts.length - 1) swapped.push(parts[p]);
            } else {
              swapped.push(prev);
              if (p === parts.length - 1) swapped.push(curr);
            }
          }
        }

        const newStr = (hasDelPrev ? delprevchar : "") + (isObjKeyExpr ? "[" : "") + swapped.join("+") + (isObjKeyExpr ? "]" : "") + (hasDelNext ? delnextchar : "");

        if (needToMod) mod(unescp(newStr));
      });
      if (hasStuff(substitutions)) {
        changed = true;
        all_substitutions.push({ type: "bigram", data: substitutions });
      }
    }

    // done trying to save space via recursive bigrams,
    // so now try to find repeated arrays
    if (debug_level >= 2) console.log("checking array saving opportunities");
    while (pass < max_passes && read_only) {
      pass++;
      const substitutions = {};
      // get an array of new varnames of all the same length (i.e. cost)
      const varnames = [];
      let varlen;
      const varNameGen = genVarNames();
      for (const varname of varNameGen) {
        if (usedVarNames.has(varname)) continue;
        if (skipVarNames.has(varname)) continue;
        if (!varlen) varlen = varname.length;
        if (varname.length !== varlen) break;
        varnames.push(varname);
      }

      // read only output, so we can re-use repetitive flat arrays
      const arr_count = {};
      forEachFlatArray(result, ({ data }) => {
        let str = toString(data);

        // str includes any embedded text operations for the array

        if (arr_count[str] === undefined) arr_count[str] = 0; // initialize to zero if necessary
        arr_count[str]++;
      });

      const arr_savings = [];
      Object.entries(arr_count).forEach(([arr, count]) => {
        // run embedded text operations
        // cleans and removes <delprevchar> and <delnextchar>
        const { text } = textops.run({ text: arr, uid: Number(uid) });

        const len = text.length;
        const current_cost = len * count;

        // declaration cost is , + variable + = + len
        const declaration_cost = 1 + varlen + 1 + len;

        const replacement_cost = declaration_cost + varlen * count;
        const savings = current_cost - replacement_cost;

        // only care if actually save space
        if (savings > 0) arr_savings.push([arr, savings]);
      });

      if (arr_savings.length === 0) {
        if (debug_level >= 2) console.log("no more opportunities to save space");
        break;
      }

      // sort bigram savings array from smallest to largest savings
      arr_savings.sort((a, b) => Math.sign(a[1] - b[1]));

      const arr_to_varname = {};
      // const actual_arr_to_varname_passes = [];
      for (let v = 0; v < varnames.length; v++) {
        const varname = varnames[v];
        const [arr, savings] = arr_savings.pop();
        arr_to_varname[arr] = varname;
        if (arr_savings.length === 0) break;
      }
      if (arr_savings.length === 1) console.log({ arr_to_varname });

      forEachFlatArray(result, ({ data, mod }) => {
        const str = toString(data);
        // if array is not worth replacing
        if (str in arr_to_varname) {
          const varname = arr_to_varname[str];
          // replace array with "<delprevchar-uid>A<delnextchar-uid>"
          mod(delprevchar + varname + delnextchar);
          usedVarNames.add(varname);
          substitutions[str] = varname;
        }
      });

      if (hasStuff(substitutions)) {
        changed = true;
        all_substitutions.push({ type: "array", data: substitutions });
      }
    }

    // if couldn't find a way to compress any further, break
    if (!changed) {
      console.log(`breaking after ${pass} passes`);
      break;
    }
  }

  // console.log("all_substitutions:", all_substitutions[0]);

  let outcode = "";

  // add in null = "None"
  // for Python
  // because JSON.stringify will write in null values
  if (lang === "PY") {
    outcode += "# special handling for Python\nnull = None\nundefined = None\n";
  }

  // first declare the first variable replacements
  outcode += declareVars({
    comment: "pass 1",
    language: lang,
    vars: Array.from(varname2token.entries()).map(([name, { token }]) => {
      if (typeof token === "string") {
        return { name, value: token };
      } else if (token === null) {
        return { name, value: "null", raw: true };
      } else if (typeof token === "undefined") {
        return { name, value: "undefined", raw: true };
      } else if (typeof token === "number") {
        return { name, value: token.toString(), raw: true };
      }
    })
  });

  all_substitutions.forEach(({ type, data }, i) => {
    outcode += "\n\n";
    outcode += declareVars({
      comment: "pass " + (i + 2) + " (" + type + ")",
      language: lang,
      vars: Object.entries(data).map(([original, varname]) => {
        const value = type === "bigram" ? JSON.parse(original).join("+") : original;
        return {
          name: varname,

          // insert value directly into declaration code
          raw: true,

          value
        };
      })
    });
  });

  // process text operations for arrays
  ({ text: outcode } = textops.run({
    ops: ["delprevchar", "delnextchar"],
    text: outcode,
    uid: Number(uid)
  }));

  if (debug_level >= 2) console.log("[json-to-code] wrote all variable declarations");
  const resultString = JSON.stringify(result, undefined, spacer);
  if (debug_level >= 2) console.log("[json-to-code] stringified result");
  const { text: processedJSON } = textops.run({
    ops: ["delprevchar", "delnextchar"],
    text: resultString,
    uid: Number(uid)
  });
  if (debug_level >= 2) console.log("[json-to-code] ran final embedded text operations");

  outcode += "\n";
  outcode += `${prefix} = ${processedJSON};`;

  return { code: outcode };
};

module.exports = { encode };

},{"advarr":4,"declare-vars":1,"deconcat":5,"deep-counter":6,"deepest-walk":8,"min-quote":9,"n-gram-counter":10,"separo":12,"striptags":13,"textops":14,"var-names":15}],4:[function(require,module,exports){
const iter = ({ inpt, func, cb, thisArg }) => {
  try {
    const length = inpt.length;

    // shallow-copy origin array
    const originalArray = Array.from(inpt);

    const firstValue = originalArray[0];
    const lastValue = originalArray[length - 1];

    return inpt[func]((value, i, array) => {
      return cb({
        value,
        currentValue: value,
        element: value,
        item: value,
        it: value,

        firstValue,
        firstElement: firstValue,
        firstItem: firstValue,
        firstIt: firstValue,

        lastValue,
        lastElement: lastValue,
        lastItem: lastValue,
        lastIt: lastValue,

        i,
        index: i,

        array,

        get percent() { return (i + 1) / length; },

        get length() { return length; },

        get previous() { return originalArray[i - 1]; },
        get prev() { return originalArray[i - 1]; },

        get next() { return originalArray[i + 1]; },

        get before() { return originalArray.slice(0, i); },
        get after() { return originalArray.slice(i + 1); },

        brk: (n=1) => { throw `[advarr] breaking ${n}`; },

        // ordinal numbers
        first: i === 0,
        second: i === 1,
        third: i === 2,
        fourth: i === 3,
        fifth: i === 4,
        sixth: i === 5,
        seventh: i === 6,
        eigth: i === 7,
        ninth: i === 8,
        tenth: i === 9,

        last: i === length - 1,
        penultimate: i === length - 2,
        antepenultimate: i === length - 3,

        odd: i % 2 === 1,
        even: i % 2 === 0,
      });
    }, thisArg);
  } catch (error) {
    let msg = error.toString();
    if (!msg.includes("[advarr] breaking 1")) {
      if (msg.includes("[advarr] breaking")) {
        const n = parseInt(msg[msg.length - 1]);
        msg = "[advarr] breaking " + (n - 1);
      }
      throw msg;
    }
  }
};

const advarr = {};
["every", "filter", "find", "findIndex", "flatMap", "forEach", "map", "some"].forEach(key => {
  advarr[key] = (inpt, cb, thisArg) => iter({ inpt, func: key, cb, thisArg });
});

if (typeof module.exports === "object") module.exports = advarr;
if (typeof window === "object") window.advarr = advarr;
if (typeof self === "object") self.advarr = advarr;

},{}],5:[function(require,module,exports){
const deconcat = (str, debug) => {
  const tokens = [];
  let inString = false;
  let current = '';
  let quotechar = null;
  for (let i = 0; i < str.length; i++) {
    const char = str[i];
    if (debug) console.log("char:", char);
    if (char === "+") {
      if (inString) {
        current += char;
      } else if (current !== '') {
        tokens.push(current);
        current = "";
      }
    } else if (char === `'` || char === `"` || char === "`") {
      current += char;
      if (inString) {
        if (char === quotechar && str[i-1] !== "\\") inString = false;
      } else {
        inString = true;
        quotechar = char;
      }
    } else if (char === ` `) {
      if (inString) current += char;
    } else {
      current += char;
    }
  }
  if (current !== '') tokens.push(current);
  return tokens;
}

if (typeof module === "object") module.exports = deconcat;
if (typeof window === "object") window.deconcat = deconcat;
if (typeof self === "object") self.deconcat = deconcat;


},{}],6:[function(require,module,exports){
const { forEach } = require("advarr");

const merge = require("./merge-counts");

const count = (options) => {
  let {
    data,
    debug_level=0,
    count_numbers=true,
    count_strings=true,
    split_strings_on=" "
  } = options;

  if (debug_level >= 1) console.log("[deep-counter] options:", options);

  if (!('data' in options)) throw new Error("[deep-counter] you called count without a data property set")

  const results = {
    strings: {},
    numbers: {},
    null: 0,
    undefined: 0
  };

  if (Array.isArray(data)) {
    forEach(data, ({ value }) => {
      merge({
        from: count({ ...options, data: value }),
        into: results
      });
    });
  } else if (data === null) {
    results.null++;
  } else if (data === undefined) {
    results.undefined++;
  } else if (typeof data === "object") {
    merge({
      from: count({ ...options, data: Object.keys(data) }),
      into: results
    });
    merge({
      from: count({ ...options, data: Object.values(data) }),
      into: results
    });
  } else if (typeof data === "string") {
    if (count_strings) {
      const tokens = data.split(split_strings_on);
      forEach(tokens, ({ value: token, last, first }) => {    
        if (token in results.strings) {
          results.strings[token].count++;
        } else {
          results.strings[token] = {
            value: token,
            count: 1,
            first: 0,
            last: 0
          };
        }
        if (first) results.strings[token].first++
        if (last) results.strings[token].last++
      });
    }
  } else if (typeof data === "number") {
    if (count_numbers) {
      if (data in results.numbers) {
        results.numbers[data].count++;
      } else {
        results.numbers[data] = { count: 1, value: data };
      }
    }
  }
  return results;
};

module.exports = count;


},{"./merge-counts":7,"advarr":4}],7:[function(require,module,exports){
module.exports = ({ from, into }) => {
  Object.entries(from).forEach(([type, counts]) => {
    if (type in into) {
      if (typeof counts === "number") {
        into[type] += counts;
      } else {
        Object.entries(counts).forEach(([token, info]) => {
          // console.log("into:", into);
          // console.log("type:", type);
          if (token in into[type]) {
            // iterate over values if it's a number add it
            Object.entries(info).forEach(([key, count]) => {
              if (key !== "value") {
                // console.log({key, count});
                if (key in into[type][token]) {
                  into[type][token][key] += count;
                } else {
                  into[type][token][key] = count;
                }
              }
            });
          } else {
            into[type][token] = info;
          }
        });
      }
    } else {
      into[type] = counts;
    }
  });
};

},{}],8:[function(require,module,exports){
const { forEach, map } = require("advarr");
const replaceKey = require("replace-key");

// utility functions
const isAry = (it) => Array.isArray(it);
const isNul = (it) => it === null;
const isObj = (it) => !Array.isArray(it) && !isNul(it) && typeof it === "object";
const isStr = (it) => typeof it === "string";
const isNum = (it) => typeof it === "number";

// doing split strings on /(?= )/ splits "a cow jumped" to [ 'a', ' cow', ' jumped' ]
function walk({
  callback,
  data,
  debug = false,
  path = [],
  split_strings_on = null, // alternative is " " if you want to split on words
  include_sep = false, // defaults to including separator in beginging if exists
  max_path_length: m = Infinity,
  split_keys = undefined,
  types,
}) {
  // saving args to pass down
  let args = arguments[0];

  if (split_keys === undefined) {
    split_keys = split_strings_on !== undefined;
  }

  if (debug) console.log("starting walk with args", args);
  const hasPath = isAry(path) && path.length > 0;
  const isArrayItem = hasPath && isNum(path[0]) && isAry(path[1]);
  const isObjValue = hasPath && isStr(path[0]) && isObj(path[1]);

  const split_str = (str) =>
    map(str.split(split_strings_on), ({ it, first }) => (include_sep && !first ? split_strings_on : "") + it);
  const join_subs = (subs) => subs.join(include_sep ? "" : split_strings_on);

  if (!hasPath && isStr(data)) throw new Error("you must pass in an object or an array to start");

  const mod_parent = (value) => {
    if (path.length === 0) throw new Error("[deepest-walk] unable to modify the starting data in place");
    if (typeof path[0] === "number") {
      // path[0] is an index in an array
      path[1][path[0]] = value;
    } else if (typeof path[0] === "string") {
      // path[0] is a key in an object
      path[1][path[0]] = value;
    }
  };

  if (isAry(data)) {
    if (!types || types.includes("array")) {
      callback({
        type: "array",
        data,
        mod: mod_parent,
      });
    }
    data.forEach((item, i) => {
      if (isStr(item)) {
        if (!types || types.includes("array-item-string")) {
          callback({
            type: "array-item-string",
            data: item,
            mod: (new_item) => (data[i] = new_item),
          });
        }
        if (split_strings_on && (!types || types.includes("array-item-substring"))) {
          const subItems = split_str(item);
          forEach(subItems, ({ it: subItem, index: ii, next, prev, first: isFirstSubstr, last: isLastSubstr }) => {
            callback({
              type: "array-item-substring",
              data: subItem,
              mod: (newSubItem) => {
                subItems[ii] = newSubItem;
                data[i] = subItems.join(include_sep ? "" : split_strings_on);
              },
              path: [ii, item, data, ...path],
              next,
              prev,
              first: isFirstSubstr,
              last: isLastSubstr,
            });
          });
        }
      } else {
        walk({ ...args, data: item, path: [i, data, ...path].slice(0, m) });
      }
    });
  } else if (isObj(data)) {
    if (!types || types.includes("object")) {
      callback({
        type: "object",
        data,
        mod: mod_parent,
      });
    }
    Object.keys(data).forEach((key) => {
      if (!types || types.includes("object-key-string")) {
        callback({
          type: "object-key-string",
          data: key,
          mod: (new_key) => {
            replaceKey({ obj: data, old_key: key, new_key });
            key = new_key;
          },
        });
      }

      if (split_keys && split_strings_on && (!types || types.includes("object-key-substring"))) {
        const subKeys = split_str(key);
        forEach(subKeys, ({ it: subkey, i, first, last, prev, next }) => {
          const mod = (newSubKey) => {
            subKeys[i] = newSubKey;
            const new_key = join_subs(subKeys);
            replaceKey({ obj: data, old_key: key, new_key });
            key = new_key;
          };
          callback({
            type: "object-key-substring",
            data: subkey,
            mod,
            first,
            last,
            prev,
            next,
          });
        });
      }
      let value = data[key];
      if (debug) console.log("value:", value);
      if (isStr(value)) {
        if (!types || types.includes("object-value-string")) {
          callback({
            type: "object-value-string",
            data: value,
            mod: (newValue) => {
              data[key] = newValue;
              value = newValue;
            },
          });
        }
        if (split_strings_on && (!types || types.includes("object-value-substring"))) {
          const subValues = split_str(value);
          forEach(subValues, ({ it: subvalue, i }) => {
            const mod = (newSubValue) => {
              subValues[i] = newSubValue;
              data[key] = join_subs(subValues);
              subvalue = newSubValue;
            };
            callback({
              type: "object-value-substring",
              data: subvalue,
              mod,
            });
          });
        }
      } else {
        // walk value
        walk({ ...args, data: data[key], path: [key, data, ...path].slice(0, m) });
      }
    });
  } else if (data === undefined || data === null || typeof data === "number") {
    if (!hasPath) {
      const dataType =
        data === undefined ? "undefined" : data === null ? "null" : typeof data === "number" ? "number" : undefined;
      if (!types || types.includes(dataType)) {
        callback({
          data,
          type: dataType,
          mod: () => {
            throw new Error("unable to mod");
          },
        });
      }
    } else if (isArrayItem || isObjValue) {
      let type;
      if (data === undefined) type = "array-item-undefined";
      else if (data === null) type = "array-item-null";
      else if (typeof data === "number") type = "array-item-number";
      if (!types || types.includes(type)) {
        callback({
          data,
          type,
          mod: (new_value) => {
            path[1][path[0]] = new_value;
            value = new_value;
          },
        });
      }
    }
  }
}

module.exports = walk;

},{"advarr":4,"replace-key":11}],9:[function(require,module,exports){
arguments[4][2][0].apply(exports,arguments)
},{"dup":2}],10:[function(require,module,exports){
const count_array = ({ arr, debug, n }) => {
    const counts = {};
    if (debug) console.log("arr:", arr);
    for (let i = n; i <= arr.length; i++) {
        const ngram = arr.slice(i - n, i);
        if (debug) console.log("ngram:", ngram);
        if (counts.hasOwnProperty(ngram)) counts[ngram].count++;
        else counts[ngram] = { original: ngram, count: 1 };
    }
    if (debug) console.log("counts:", counts);
    const sorted = Object.entries(counts).sort((a, b) => Math.sign(b[1].count - a[1].count));
    if (debug) console.log("sorted:", sorted);
    const results = sorted.map(it => [it[1].original, it[1].count]);
    if (debug) console.log("results:", results);
    return results;
}

const count_text = ({ text, debug, n }) => {
    const counts = {};
    if (debug) console.log("text: " + text.substring(0, 100).trim() + "...");
    for (let i = n; i <= text.length; i++) {
        const ngram = text.substring(i - n, i);
        if (debug) console.log("ngram:", ngram);
        if (counts.hasOwnProperty(ngram)) counts[ngram]++;
        else counts[ngram] = 1;
    }
    if (debug) console.log("counts:", counts);
    const sorted = Object.entries(counts).sort((a, b) => Math.sign(b[1] - a[1]));
    if (debug) console.log("sorted:", sorted);
    return sorted;
}

module.exports = ({ data, debug, n }) => {
    if (Array.isArray(data)) {
        return count_array({ arr: data, debug, n });
    } else {
        return count_text({ text: data, debug, n });
    }
};

},{}],11:[function(require,module,exports){
const replaceKey = ({ obj, old_key, new_key }) => {
  if (obj === null || typeof obj !== "object") throw new Error(`[replace-key] obj is not an object"`);
  if (!(old_key in obj)) throw new Error(`[replace-key] "${old_key}" is not a key of obj`);
  obj[new_key] = obj[old_key];
  delete obj[old_key];
  return obj;
}

if (typeof module === "object") module.exports = replaceKey;
if (typeof window === "object") window.replaceKey = replaceKey;
if (typeof self === "object") self.replaceKey = replaceKey;

},{}],12:[function(require,module,exports){
const separo = (str, sep=' ', { attachSep=false, keepSep=false } = { attachSep: false, keepSep: false }) => {
  if (typeof sep === 'string') sep = new Set([sep]);
  else if (Array.isArray(sep)) sep = new Set(sep);

  const result = [];
  let current = '';
  for (let i = 0; i < str.length; i++) {
    const char = str[i];
    if (sep.has(char)) {
      result.push(current);
      if (attachSep) {
        current = char;
      } else if (keepSep) {
        result.push(char);
        current = '';
      } else {
        current = '';
      }
    } else {
      current += char;
    }
  }
  if (current.length > 0) result.push(current);

  return result;
};

if (typeof module === 'object') module.exports = separo;
if (typeof window === 'object') window.separo = separo;
if (typeof self === 'object') self.separo = separo;

},{}],13:[function(require,module,exports){
'use strict';

(function (global) {

    // minimal symbol polyfill for IE11 and others
    if (typeof Symbol !== 'function') {
        var Symbol = function(name) {
            return name;
        }

        Symbol.nonNative = true;
    }

    const STATE_PLAINTEXT = Symbol('plaintext');
    const STATE_HTML      = Symbol('html');
    const STATE_COMMENT   = Symbol('comment');

    const ALLOWED_TAGS_REGEX  = /<(\w*)>/g;
    const NORMALIZE_TAG_REGEX = /<\/?([^\s\/>]+)/;

    function striptags(html, allowable_tags, tag_replacement) {
        html            = html || '';
        allowable_tags  = allowable_tags || [];
        tag_replacement = tag_replacement || '';

        let context = init_context(allowable_tags, tag_replacement);

        return striptags_internal(html, context);
    }

    function init_striptags_stream(allowable_tags, tag_replacement) {
        allowable_tags  = allowable_tags || [];
        tag_replacement = tag_replacement || '';

        let context = init_context(allowable_tags, tag_replacement);

        return function striptags_stream(html) {
            return striptags_internal(html || '', context);
        };
    }

    striptags.init_streaming_mode = init_striptags_stream;

    function init_context(allowable_tags, tag_replacement) {
        allowable_tags = parse_allowable_tags(allowable_tags);

        return {
            allowable_tags : allowable_tags,
            tag_replacement: tag_replacement,

            state         : STATE_PLAINTEXT,
            tag_buffer    : '',
            depth         : 0,
            in_quote_char : ''
        };
    }

    function striptags_internal(html, context) {
        if (typeof html != "string") {
            throw new TypeError("'html' parameter must be a string");
        }

        let allowable_tags  = context.allowable_tags;
        let tag_replacement = context.tag_replacement;

        let state         = context.state;
        let tag_buffer    = context.tag_buffer;
        let depth         = context.depth;
        let in_quote_char = context.in_quote_char;
        let output        = '';

        for (let idx = 0, length = html.length; idx < length; idx++) {
            let char = html[idx];

            if (state === STATE_PLAINTEXT) {
                switch (char) {
                    case '<':
                        state       = STATE_HTML;
                        tag_buffer += char;
                        break;

                    default:
                        output += char;
                        break;
                }
            }

            else if (state === STATE_HTML) {
                switch (char) {
                    case '<':
                        // ignore '<' if inside a quote
                        if (in_quote_char) {
                            break;
                        }

                        // we're seeing a nested '<'
                        depth++;
                        break;

                    case '>':
                        // ignore '>' if inside a quote
                        if (in_quote_char) {
                            break;
                        }

                        // something like this is happening: '<<>>'
                        if (depth) {
                            depth--;

                            break;
                        }

                        // this is closing the tag in tag_buffer
                        in_quote_char = '';
                        state         = STATE_PLAINTEXT;
                        tag_buffer   += '>';

                        if (allowable_tags.has(normalize_tag(tag_buffer))) {
                            output += tag_buffer;
                        } else {
                            output += tag_replacement;
                        }

                        tag_buffer = '';
                        break;

                    case '"':
                    case '\'':
                        // catch both single and double quotes

                        if (char === in_quote_char) {
                            in_quote_char = '';
                        } else {
                            in_quote_char = in_quote_char || char;
                        }

                        tag_buffer += char;
                        break;

                    case '-':
                        if (tag_buffer === '<!-') {
                            state = STATE_COMMENT;
                        }

                        tag_buffer += char;
                        break;

                    case ' ':
                    case '\n':
                        if (tag_buffer === '<') {
                            state      = STATE_PLAINTEXT;
                            output    += '< ';
                            tag_buffer = '';

                            break;
                        }

                        tag_buffer += char;
                        break;

                    default:
                        tag_buffer += char;
                        break;
                }
            }

            else if (state === STATE_COMMENT) {
                switch (char) {
                    case '>':
                        if (tag_buffer.slice(-2) == '--') {
                            // close the comment
                            state = STATE_PLAINTEXT;
                        }

                        tag_buffer = '';
                        break;

                    default:
                        tag_buffer += char;
                        break;
                }
            }
        }

        // save the context for future iterations
        context.state         = state;
        context.tag_buffer    = tag_buffer;
        context.depth         = depth;
        context.in_quote_char = in_quote_char;

        return output;
    }

    function parse_allowable_tags(allowable_tags) {
        let tag_set = new Set();

        if (typeof allowable_tags === 'string') {
            let match;

            while ((match = ALLOWED_TAGS_REGEX.exec(allowable_tags))) {
                tag_set.add(match[1]);
            }
        }

        else if (!Symbol.nonNative &&
                 typeof allowable_tags[Symbol.iterator] === 'function') {

            tag_set = new Set(allowable_tags);
        }

        else if (typeof allowable_tags.forEach === 'function') {
            // IE11 compatible
            allowable_tags.forEach(tag_set.add, tag_set);
        }

        return tag_set;
    }

    function normalize_tag(tag_buffer) {
        let match = NORMALIZE_TAG_REGEX.exec(tag_buffer);

        return match ? match[1].toLowerCase() : null;
    }

    if (typeof define === 'function' && define.amd) {
        // AMD
        define(function module_factory() { return striptags; });
    }

    else if (typeof module === 'object' && module.exports) {
        // Node
        module.exports = striptags;
    }

    else {
        // Browser
        global.striptags = striptags;
    }
}(this));

},{}],14:[function(require,module,exports){
function Tag({ name, uid }) {
  return `<${name}${uid ? "-" + uid : ""}>`;
}

function run({ debug, ops, text, uid }) {
  if (!text) throw new Error("[textops] can't run without text!  Please call like run({ text })");
  if (!["number", "undefined"].includes(typeof uid)) throw new Error(`[textops] for security reasons, uid must be a number or undefined.  You passed in "${typeof uid}"`);
  if (typeof uid === "number" && uid.toString().includes(".")) throw new Error("[textops] for security reasons, uid must be an integer");
  ops ??= ["delprev", "delprevchar", "delnext", "delnextchar"];

  const anychar = ".";
  const op2re = {
    delprev: anychar + "+" + Tag({ name: "delprev", uid }),
    delnext: Tag({ name: "delnext", uid }) + anychar + "+",
    delprevchar: anychar + Tag({ name: "delprevchar", uid }),
    delnextchar: Tag({ name: "delnextchar", uid }) + anychar
  };

  const restr =
    "(" +
    ops
      .map(op => op2re[op])
      .filter(Boolean)
      .join("|") +
    ")";

  if (debug) console.log(`[textops] restr: "${restr}"`);
  const re = new RegExp(restr, "g");
  text = text.replace(re, "");

  return {
    text
  };
}

if (typeof define === "function") define(() => ({ run }));
if (typeof module === "object") module.exports = { run };
if (typeof window === "object") window.textops = { run };
if (typeof self === "object") self.textops = { run };

},{}],15:[function(require,module,exports){
const alphabet_lower = "abcdefghijklmnopqrstuvwxyz";
const alphabet_upper = alphabet_lower.toUpperCase();

const DEFAULT_CHARS = Array.from(alphabet_upper + alphabet_lower);

const DEFAULT_LANG = "JS";

const DEFAULT_MAX_COUNT = 1e6;

const RESERVED_WORDS = {
  // prettier-ignore
  JS: [
    "abstract", "alert", "all", "anchor", "anchors", "area", "arguments", "assign", "Array", "await",
    "boolean", "blur", "break", "button", "byte",
    "case", "catch", "char", "checkbox", "class", "clearInterval", "clearTimeout", "clientInformation", "close", "closed", "confirm", "const", "constructor", "continue", "crypto",
    "Date", "debugger", "decodeURI", "decodeURIComponent", "default", "defaultStatus", "delete", "do", "document", "double",
    "element", "elements", "else", "embed", "embeds", "encodeURI", "encodeURIComponent", "enum", "escape", "eval", "event", "export", "extends",
    "false", "fileUpload", "final", "finally", "float", "focus", "for", "form", "forms", "frame", "frameRate", "frames", "function",
    "getClass", "goto",
    "hasOwnProperty", "hidden", "history",
    "if", "image", "images", "implements", "import", "in", "Infinity", "innerHeight", "innerWidth", "instanceof", "int", "interface", "isFinite", "isNaN", "isPrototypeOf",
    "java", "javaClass", "JavaArray", "JavaObject", "JavaPackage",
    "layer", "layers", "length", "let", "link", "location", "long",
    "Math", "mimeTypes", "module",
    "name", "NaN", "native", "navigate", "navigator", "new", "null", "Number",
    "offscreenBuffering", "Object", "open", "opener", "option", "outerHeight", "outerWidth",
    "package", "packages", "pageXOffset", "pageYOffset", "parent", "parseFloat", "parseInt", "password", "pkcs11", "plugin", "private", "prompt", "propertyIsEnum", "protected", "prototype", "public",
    "radio", "reset", "return",
    "screenX", "screenY", "scroll", "secure", "select", "self", "setInterval", "setTimeout", "short", "static", "status", "String", "submit", "super", "switch", "synchronized",
    "text", "textarea", "this", "throw", "throws", "top", "toString", "transient", "true", "try", "typeof",
    "undefined", "unescape", "untaint",
    "valueOf", "var", "void", "volatile",
    "while", "with", "window",
    "yield"
  ],
};

function* genVarNames(
  {
    chars = DEFAULT_CHARS,
    debug = false,
    language = DEFAULT_LANG,
    max_count = DEFAULT_MAX_COUNT,
  } = {
    chars: DEFAULT_CHARS,
    debug: false,
    language: DEFAULT_LANG,
    max_count: DEFAULT_MAX_COUNT,
  }
) {
  const reserved_words = new Set(RESERVED_WORDS[language]);

  let count = 0;
  let indexes = [-1];
  let i = 0;

  while (true) {
    if (count === max_count) return;

    i++;

    if (indexes[indexes.length - 1] === chars.length - 1) {
      // reset at all A's
      // so increment the previous available character by one
      // so if AAZ go to ABA
      let reset_index = null;
      for (let ii = indexes.length - 2; ii >= 0; ii--) {
        if (indexes[ii] < chars.length - 2) {
          reset_index = ii;
          break;
        }
      }
      if (reset_index === null) {
        if (debug)
          console.log(
            "[var-names] adding a character and resetting to all A's"
          );
        indexes = indexes.map((n) => 0).concat([0]);
      } else {
        indexes[reset_index]++;
        for (let ii = reset_index + 1; ii < indexes.length; ii++) {
          indexes[ii] = 0;
        }
      }
    } else {
      indexes[indexes.length - 1]++;
    }
    const new_variable_name = indexes.map((ii) => chars[ii]).join("");
    if (reserved_words.has(new_variable_name)) {
      if (debug)
        console.log(
          "[var-names] skipping " +
            new_variable_name +
            "because it is a reserved word"
        );
      continue;
    }
    if (debug) console.log("[var-names] trying to eval new_variable_name");
    try {
      eval(`const ${new_variable_name} = "test";`);
      count++;
      yield new_variable_name;
    } catch (error) {
      if (debug) console.log("[var-names] can't use " + new_variable_name);
    }
  }
}

if (typeof module === "object") module.exports = { genVarNames };
if (typeof window === "object") window.varnames = { genVarNames };
if (typeof self === "object") self.varnames = { genVarNames };

},{}]},{},[3])(3)
});

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcGFjay9fcHJlbHVkZS5qcyIsIi4uL2RlY2xhcmUtdmFycy9kZWNsYXJlLXZhcnMuanMiLCIuLi9kZWNsYXJlLXZhcnMvbm9kZV9tb2R1bGVzL21pbi1xdW90ZS9taW4tcXVvdGUuanMiLCJqc29uLXRvLWNvZGUuanMiLCJub2RlX21vZHVsZXMvLnBucG0vYWR2YXJyQDAuNC4wL25vZGVfbW9kdWxlcy9hZHZhcnIvYWR2YXJyLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2RlY29uY2F0QDAuMC4xL25vZGVfbW9kdWxlcy9kZWNvbmNhdC9kZWNvbmNhdC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9kZWVwLWNvdW50ZXJAMC4wLjIvbm9kZV9tb2R1bGVzL2RlZXAtY291bnRlci9kZWVwLWNvdW50ZXIuanMiLCJub2RlX21vZHVsZXMvLnBucG0vZGVlcC1jb3VudGVyQDAuMC4yL25vZGVfbW9kdWxlcy9kZWVwLWNvdW50ZXIvbWVyZ2UtY291bnRzLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2RlZXBlc3Qtd2Fsa0AxLjAuMi9ub2RlX21vZHVsZXMvZGVlcGVzdC13YWxrL2RlZXBlc3Qtd2Fsay5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9uLWdyYW0tY291bnRlckAwLjAuMC9ub2RlX21vZHVsZXMvbi1ncmFtLWNvdW50ZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvLnBucG0vcmVwbGFjZS1rZXlAMC4wLjAvbm9kZV9tb2R1bGVzL3JlcGxhY2Uta2V5L3JlcGxhY2Uta2V5LmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3NlcGFyb0AwLjAuMi9ub2RlX21vZHVsZXMvc2VwYXJvL3NlcGFyby5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9zdHJpcHRhZ3NAMy4yLjAvbm9kZV9tb2R1bGVzL3N0cmlwdGFncy9zcmMvc3RyaXB0YWdzLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3RleHRvcHNAMC4wLjIvbm9kZV9tb2R1bGVzL3RleHRvcHMvdGV4dG9wcy5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS92YXItbmFtZXNAMC4wLjAvbm9kZV9tb2R1bGVzL3Zhci1uYW1lcy92YXItbmFtZXMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNwTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9PQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCJjb25zdCBtaW5RdW90ZSA9IHJlcXVpcmUoXCJtaW4tcXVvdGVcIik7XG5cbmNvbnN0IGRlY2xhcmVWYXJzID0gKHsgdmFycywgY29tbWVudD1mYWxzZSwgbGFuZ3VhZ2U9XCJKYXZhU2NyaXB0XCIsIHByZXR0eSwgc2VtaSB9KSA9PiB7XG4gIGxhbmd1YWdlID0gbGFuZ3VhZ2UudG9VcHBlckNhc2UoKTtcbiAgbGV0IGxhbmc7XG4gIGlmIChsYW5ndWFnZSA9PT0gXCJKU1wiIHx8IGxhbmd1YWdlID09PSBcIkpBVkFTQ1JJUFRcIikgbGFuZyA9IFwiSlNcIjtcbiAgZWxzZSBpZiAobGFuZ3VhZ2UgPT09IFwiUFlcIiB8fCBsYW5ndWFnZSA9PT0gXCJQWVRIT05cIikgbGFuZyA9IFwiUFlcIjtcblxuICBpZiAoc2VtaSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKGxhbmcgPT09IFwiSlNcIikgc2VtaSA9IHRydWU7XG4gICAgZWxzZSBpZiAobGFuZyA9PT0gXCJQWVwiKSBzZW1pID0gZmFsc2U7XG4gIH1cblxuICBpZiAocHJldHR5ID09PSB1bmRlZmluZWQpIHtcbiAgICBpZiAobGFuZyA9PT0gXCJKU1wiKSBwcmV0dHkgPSBmYWxzZTtcbiAgICBlbHNlIGlmIChsYW5nID09PSBcIlBZXCIpIHByZXR0eSA9IHRydWU7XG4gIH1cblxuICBsZXQgb3V0ID0gXCJcIjtcbiAgaWYgKGNvbW1lbnQpIHtcbiAgICBpZiAobGFuZyA9PT0gXCJKU1wiKSBvdXQgKz0gXCIvKiBcIiArICh0eXBlb2YgY29tbWVudCA9PT0gXCJzdHJpbmdcIiA/IGNvbW1lbnQgOiBcImRlY2xhcmF0aW9uc1wiKSArIFwiICovXFxuXCI7XG4gICAgaWYgKGxhbmcgPT09IFwiUFlcIikgb3V0ICs9IFwiIyBcIiArICh0eXBlb2YgY29tbWVudCA9PT0gXCJzdHJpbmdcIiA/IGNvbW1lbnQgOiBcImRlY2xhcmF0aW9uc1wiKSArIFwiXFxuXCI7XG4gIH1cbiAgaWYgKCFwcmV0dHkgJiYgbGFuZyA9PT0gXCJKU1wiKSBvdXQgKz0gXCJjb25zdCBcIjtcbiAgdmFycy5mb3JFYWNoKCh7IG5hbWUsIHZhbHVlLCByYXc9ZmFsc2UgfSwgaSkgPT4ge1xuICAgIGlmIChwcmV0dHkpIHtcbiAgICAgIGlmIChpICE9PSAwKSBvdXQgKz0gXCJcXG5cIjtcbiAgICAgIG91dCArPSAobGFuZyA9PT0gXCJKU1wiID8gXCJjb25zdCBcIiA6IFwiXCIpICsgbmFtZSArIFwiPVwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaSAhPT0gMCkge1xuICAgICAgICBpZiAobGFuZyA9PT0gXCJKU1wiKSBvdXQgKz0gXCIsXCI7XG4gICAgICAgIGVsc2UgaWYgKGxhbmcgPT09IFwiUFlcIikgb3V0ICs9IFwiO1wiO1xuICAgICAgfVxuICAgICAgb3V0ICs9IG5hbWUgKyBcIj1cIjsgIFxuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiIHx8IHJhdykge1xuICAgICAgb3V0ICs9IHZhbHVlO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBvdXQgKz0gbWluUXVvdGUodmFsdWUsIHsgYmFja3RpY2s6IGxhbmcgPT09IFwiSlNcIiB9KTtcbiAgICB9XG4gICAgaWYgKHByZXR0eSAmJiBzZW1pKSBvdXQgKz0gXCI7XCI7XG4gIH0pO1xuICBpZiAoc2VtaSAmJiAhcHJldHR5KSBvdXQgKz0gXCI7XCJcbiAgcmV0dXJuIG91dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZGVjbGFyZVZhcnM7XG4iLCJjb25zdCBtaW5RdW90ZSA9IChzdHIsIHsgZGVidWc9ZmFsc2UsIGJhY2t0aWNrPXRydWUgfSA9IHsgYmFja3RpY2s6IGZhbHNlLCBkZWJ1ZzogZmFsc2UgfSkgPT4ge1xuICBpZiAoZGVidWcpIGNvbnNvbGUubG9nKFwiW21pbi1xdW90ZV0gc3RhcnRpbmcgd2l0aCBzdHI6XCIsIFtzdHJdKTtcbiAgbGV0IHF1b3RlY2hhcnMgPSBbXCInXCIsICdcIicsIFwiYFwiXTtcbiAgbGV0IG51bVF1b3RlcyA9IHF1b3RlY2hhcnMubGVuZ3RoO1xuICBsZXQgc2VsZWN0aW9uO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVF1b3RlczsgaSsrKSB7XG4gICAgY29uc3QgY2hhciA9IHF1b3RlY2hhcnNbaV07XG4gICAgaWYgKCFzdHIuaW5jbHVkZXMoY2hhcikpIHtcbiAgICAgIHNlbGVjdGlvbiA9IGNoYXI7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgbGV0IHJlc3VsdDtcbiAgaWYgKHNlbGVjdGlvbikge1xuICAgIHJlc3VsdCA9IHNlbGVjdGlvbiArIHN0ciArIHNlbGVjdGlvbjtcbiAgfSBlbHNlIHtcbiAgICAvLyBjaG9zZSB0aGUgcXVvdGUgdGhhdCB3b3VsZCByZXF1aXJlIHRoZSBsZWFzdCBhbW91bnQgb2YgZXNjYXBpbmdcbiAgICBjb25zdCBjb3VudHMgPSB7IFwiJ1wiOiAwLCAnXCInOiAwLCBcImBcIjogMCB9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjaGFyID0gc3RyW2ldO1xuICAgICAgaWYgKGNoYXIgPT09IFwiJ1wiIHx8IGNoYXIgPT09ICdcIicgfHwgY2hhciA9PT0gXCJgXCIpIHtcbiAgICAgICAgY291bnRzW2NoYXJdKys7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChkZWJ1ZykgY29uc29sZS5sb2coXCJbbWluLXF1b3RlXSBjb3VudHM6XCIsIGNvdW50cyk7XG4gICAgY29uc3Qgc29ydGVkQ291bnRzID0gT2JqZWN0LmVudHJpZXMoY291bnRzKS5zb3J0KChhLCBiKSA9PiBNYXRoLnNpZ24oYVsxXSAtIGJbMV0pKTtcbiAgICBjb25zdCBtaW5Db3VudCA9IHNvcnRlZENvdW50c1swXVsxXTtcbiAgICBjb25zdCBjYW5kaWRhdGVzID0gc29ydGVkQ291bnRzLmZpbHRlcigoW2NoYXIsIGNvdW50XSkgPT4gY291bnQgPT09IG1pbkNvdW50KTtcbiAgICBjb25zdCBub3RCYWNrdGlja3MgPSBjYW5kaWRhdGVzLmZpbHRlcigoW2NoYXIsIGNvdW50XSkgPT4gY2hhciAhPT0gXCJgXCIpO1xuICAgIGlmIChub3RCYWNrdGlja3MubGVuZ3RoID49IDEpIHNlbGVjdGlvbiA9IG5vdEJhY2t0aWNrc1swXVswXTtcbiAgICBlbHNlIHNlbGVjdGlvbiA9IGNhbmRpZGF0ZXNbMF1bMF07XG4gICAgaWYgKGRlYnVnKSBjb25zb2xlLmxvZyhcIlttaW4tcXVvdGVdIHNlbGVjdGlvbjpcIiwgc2VsZWN0aW9uKTtcbiAgICByZXN1bHQgPSBzZWxlY3Rpb24gKyBzdHIucmVwbGFjZShzZWxlY3Rpb24sIFwiXFxcXFwiICsgc2VsZWN0aW9uKSArIHNlbGVjdGlvbjtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuaWYgKHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIpIG1vZHVsZS5leHBvcnRzID0gbWluUXVvdGU7XG5pZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikgd2luZG93Lm1pblF1b3RlID0gbWluUXVvdGU7XG5pZiAodHlwZW9mIHNlbGYgPT09IFwib2JqZWN0XCIpIHNlbGYubWluUXVvdGUgPSBtaW5RdW90ZTsiLCJjb25zdCB7IGZvckVhY2ggfSA9IHJlcXVpcmUoXCJhZHZhcnJcIik7XG5jb25zdCBjb3VudCA9IHJlcXVpcmUoXCJkZWVwLWNvdW50ZXJcIik7XG5jb25zdCBkZWNsYXJlVmFycyA9IHJlcXVpcmUoXCJkZWNsYXJlLXZhcnNcIik7XG5jb25zdCBkZWNvbmNhdCA9IHJlcXVpcmUoXCJkZWNvbmNhdFwiKTtcbmNvbnN0IHdhbGsgPSByZXF1aXJlKFwiZGVlcGVzdC13YWxrXCIpO1xuY29uc3QgY291bnROR3JhbXMgPSByZXF1aXJlKFwibi1ncmFtLWNvdW50ZXJcIik7XG5jb25zdCBtaW5RdW90ZSA9IHJlcXVpcmUoXCJtaW4tcXVvdGVcIik7XG5jb25zdCB7IGdlblZhck5hbWVzIH0gPSByZXF1aXJlKFwidmFyLW5hbWVzXCIpO1xuY29uc3Qgc2VwYXJvID0gcmVxdWlyZShcInNlcGFyb1wiKTtcbmNvbnN0IHN0cmlwdGFncyA9IHJlcXVpcmUoXCJzdHJpcHRhZ3NcIik7XG5jb25zdCB0ZXh0b3BzID0gcmVxdWlyZShcInRleHRvcHNcIik7XG5cbmNvbnN0IGhhc1N0dWZmID0gb2JqID0+IE9iamVjdC5rZXlzKG9iaikubGVuZ3RoID4gMDtcblxuY29uc3QgaXNGbGF0QXJyYXkgPSBpdCA9PiBBcnJheS5pc0FycmF5KGl0KSAmJiBpdC5ldmVyeShzdWJpdGVtID0+IHN1Yml0ZW0gPT09IG51bGwgfHwgdHlwZW9mIHN1Yml0ZW0gIT09IFwib2JqZWN0XCIpO1xuXG5jb25zdCBpc1F1b3RlZCA9IHN0ciA9PiBzdHIubWF0Y2goL14oWydcImBdKS4qXFwxJC8pO1xuXG4vLyByZW1vdmUgd3JhcHBpbmcgYnJhY2VzXG5jb25zdCB1bmJyYWNlID0gc3RyID0+IHN0ci5yZXBsYWNlKC9eXFxbLywgXCJcIikucmVwbGFjZSgvXFxdJC8pO1xuXG5jb25zdCBmb3JFYWNoRmxhdEFycmF5ID0gKGRhdGEsIGNiKSA9PiB7XG4gIHdhbGsoe1xuICAgIGRhdGEsXG4gICAgY2FsbGJhY2s6ICh7IGRhdGEsIG1vZCwgdHlwZSB9KSA9PiB7XG4gICAgICBpZiAoaXNGbGF0QXJyYXkoZGF0YSkpIHtcbiAgICAgICAgY2IoeyBkYXRhLCBtb2QsIHR5cGUgfSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG5cbmNvbnN0IGZvckVhY2hTdHJpbmcgPSAoZGF0YSwgY2IpID0+IHtcbiAgd2Fsayh7XG4gICAgZGF0YSxcbiAgICBjYWxsYmFjazogKHsgZGF0YSwgbW9kLCB0eXBlIH0pID0+IHtcbiAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjYih7IHN0cjogZGF0YSwgbW9kLCB0eXBlIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59O1xuXG4vLyBzdHJpbmcgaW4gY29kZVxuY29uc3QgdG9TdHJpbmcgPSBpdCA9PiB7XG4gIGlmIChpdCA9PT0gbnVsbCkgcmV0dXJuIFwibnVsbFwiO1xuICBlbHNlIGlmIChpdCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gXCJ1bmRlZmluZWRcIjtcbiAgZWxzZSBpZiAodHlwZW9mIGl0ID09PSBcInN0cmluZ1wiKSByZXR1cm4gaXQ7XG4gIGVsc2UgaWYgKHR5cGVvZiBpdCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIGl0LnRvU3RyaW5nKCk7XG4gIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaXQpKSByZXR1cm4gSlNPTi5zdHJpbmdpZnkoaXQpO1xuICBlbHNlIHRocm93IG5ldyBFcnJvcihcInRvLXN0cmluZyBmYWlsZWQgYmVjYXVzZSB1bmV4cGVjdGVkIHR5cGVcIik7XG59O1xuXG5jb25zdCBlbmNvZGUgPSAoeyBkYXRhLCBkZWJ1Z19sZXZlbCA9IDAsIGxhbmd1YWdlID0gXCJKYXZhU2NyaXB0XCIsIG1heF9wYXNzZXMgPSAxMDAsIHByZWZpeCwgcmVhZF9vbmx5ID0gdHJ1ZSwgc3BhY2VyIH0pID0+IHtcbiAgaWYgKGRlYnVnX2xldmVsID49IDEpIGNvbnNvbGUubG9nKFwiW2VuY29kZV0gc3RhcnRpbmdcIik7XG4gIGlmIChkZWJ1Z19sZXZlbCA+PSAyKSBjb25zb2xlLmxvZyhcIltlbmNvZGVdIGRhdGE6XCIsIEpTT04uc3RyaW5naWZ5KGRhdGEpLnN1YnN0cmluZygwLCAyMDApLCBcIi4uLlwiKTtcblxuICAvLyBub3JtYWxpemluZyBsYW5ndWFnZVxuICBsYW5ndWFnZSA9IGxhbmd1YWdlLnRvVXBwZXJDYXNlKCk7XG4gIGxldCBsYW5nO1xuICBpZiAobGFuZ3VhZ2UgPT09IFwiSlNcIiB8fCBsYW5ndWFnZSA9PT0gXCJKQVZBU0NSSVBUXCIpIGxhbmcgPSBcIkpTXCI7XG4gIGVsc2UgaWYgKGxhbmd1YWdlID09PSBcIlBZXCIgfHwgbGFuZ3VhZ2UgPT09IFwiUFlUSE9OXCIpIGxhbmcgPSBcIlBZXCI7XG5cbiAgaWYgKHByZWZpeCA9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAobGFuZyA9PT0gXCJKU1wiKSBwcmVmaXggPSBcIm1vZHVsZS5leHBvcnRzXCI7XG4gICAgZWxzZSBpZiAobGFuZyA9PT0gXCJQWVwiKSBwcmVmaXggPSBcImRhdGFcIjtcbiAgfVxuXG4gIGNvbnN0IHVzZUJhY2t0aWNrID0gbGFuZyA9PT0gXCJKU1wiO1xuXG4gIGNvbnN0IGNvdW50cyA9IGNvdW50KHsgZGF0YSwgZGVidWdfbGV2ZWw6IGRlYnVnX2xldmVsIC0gMSB9KTtcbiAgaWYgKGRlYnVnX2xldmVsID49IDEpIGNvbnNvbGUubG9nKFwiY291bnRzOlwiLCBjb3VudHMpO1xuXG4gIGNvbnN0IHN0cmluZ2lmaWVkID0gdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgPyBkYXRhIDogSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gIGlmIChkZWJ1Z19sZXZlbCA+PSAxKSBjb25zb2xlLmxvZyhcIltlbmNvZGVdIHN0cmluZ2lmaWVkOlwiLCBzdHJpbmdpZmllZC5zdWJzdHJpbmcoMCwgMjAwKSwgXCIuLi5cIik7XG5cbiAgLyogZ2VuZXJhdGUgYSBVSUQgZm9yIHRleHQgb3BlcmF0aW9ucyAqL1xuICBsZXQgdWlkO1xuICB3aGlsZSAoIXVpZCkge1xuICAgIGNvbnN0IG51bSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDFlNSkudG9TdHJpbmcoKTtcbiAgICBpZiAoIXN0cmluZ2lmaWVkLmluY2x1ZGVzKG51bSkpIHVpZCA9IG51bTtcbiAgfVxuICBpZiAoZGVidWdfbGV2ZWwgPj0gMSkgY29uc29sZS5sb2coXCJ1aWQ6XCIsIHVpZCk7XG5cbiAgLy8gYSBudW1iZXIgaXMgYWx3YXlzIHRoZSBmaXJzdCBhbmQgbGFzdCBiZWNhdXNlIHRoZXJlJ3Mgbm90IHN1Y2ggdGhpbmcgYXMgYSBzdWItbnVtYmVyICh1bmxpa2UgYSBzdWItc3RyaW5nKVxuICBjb25zdCBudW1iZXJfY291bnRzID0gT2JqZWN0LnZhbHVlcyhjb3VudHMubnVtYmVycykubWFwKGl0ID0+ICh7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICB2YWx1ZTogaXQudmFsdWUsXG4gICAgY291bnQ6IGl0LmNvdW50XG4gIH0pKTtcblxuICBjb25zdCBzdHJpbmdfY291bnRzID0gT2JqZWN0LnZhbHVlcyhjb3VudHMuc3RyaW5ncykubWFwKGl0ID0+ICh7XG4gICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICB2YWx1ZTogaXQudmFsdWUsXG4gICAgY291bnQ6IGl0LmNvdW50LFxuICAgIGZpcnN0OiBpdC5maXJzdCxcbiAgICBsYXN0OiBpdC5sYXN0XG4gIH0pKTtcblxuICBjb25zdCBhbGxfY291bnRzID0gWy4uLm51bWJlcl9jb3VudHMsIC4uLnN0cmluZ19jb3VudHNdO1xuICBpZiAoY291bnRzLm51bGwpIHtcbiAgICBhbGxfY291bnRzLnB1c2goe1xuICAgICAgdHlwZTogXCJudWxsXCIsXG4gICAgICB2YWx1ZTogbnVsbCxcbiAgICAgIGNvdW50OiBjb3VudHMubnVsbFxuICAgIH0pO1xuICB9XG4gIGlmIChjb3VudHMudW5kZWZpbmVkKSB7XG4gICAgYWxsX2NvdW50cy5wdXNoKHtcbiAgICAgIHR5cGU6IFwidW5kZWZpbmVkXCIsXG4gICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgY291bnQ6IGNvdW50cy51bmRlZmluZWRcbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0IHNvcnRlZF9jb3VudHMgPSBhbGxfY291bnRzLnNvcnQoKGEsIGIpID0+IE1hdGguc2lnbihiLmNvdW50IC0gYS5jb3VudCkpO1xuICBpZiAoZGVidWdfbGV2ZWwgPj0gMSkgY29uc29sZS5sb2coXCJbZW5jb2RlXSBzb3J0ZWQgY291bnRzXCIpO1xuICBpZiAoZGVidWdfbGV2ZWwgPj0gMikgY29uc29sZS5sb2coXCJbZW5jb2RlXSBzb3J0ZWRfY291bnRzOlwiLCBzb3J0ZWRfY291bnRzKTtcblxuICBjb25zdCB0b2tlbnMgPSBzb3J0ZWRfY291bnRzLm1hcChpdCA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChkZWJ1Z19sZXZlbCA+PSAyKSBjb25zb2xlLmxvZyhcIml0OlwiLCBpdCk7XG5cbiAgICAgIGNvbnN0IHsgdmFsdWUsIGNvdW50LCB0eXBlIH0gPSBpdDtcblxuICAgICAgY29uc3QgdmFsdWVfc3RyaW5nID0gdG9TdHJpbmcodmFsdWUpO1xuXG4gICAgICBpZiAoW1wibnVsbFwiLCBcIm51bWJlclwiLCBcInVuZGVmaW5lZFwiXS5pbmNsdWRlcyh0eXBlKSkge1xuICAgICAgICBjb25zdCB2YWx1ZV9sZW5ndGggPSB2YWx1ZV9zdHJpbmcubGVuZ3RoO1xuICAgICAgICBjb25zdCBjdXJyZW50X2Nvc3QgPSBjb3VudCAqIHZhbHVlX2xlbmd0aDtcbiAgICAgICAgY29uc3Qgc2F2aW5ncyA9IHt9O1xuICAgICAgICBmb3IgKGxldCB2YXJpYWJsZV9sZW5ndGggPSAxOyB2YXJpYWJsZV9sZW5ndGggPD0gNTsgdmFyaWFibGVfbGVuZ3RoKyspIHtcbiAgICAgICAgICAvLyBsaWtlICxBPTEyMzsgb3IgLEJhPW51bGwgb3IgLEFiPXVuZGVmaW5lZDtcbiAgICAgICAgICBjb25zdCBkZWNsYXJhdGlvbl9jb3N0ID0gMSArIHZhcmlhYmxlX2xlbmd0aCArIDEgKyB2YWx1ZV9sZW5ndGg7XG4gICAgICAgICAgY29uc3QgcmVwbGFjZW1lbnRfY29zdCA9IGRlY2xhcmF0aW9uX2Nvc3QgKyBjb3VudCAqIHZhcmlhYmxlX2xlbmd0aDtcbiAgICAgICAgICBzYXZpbmdzW3ZhcmlhYmxlX2xlbmd0aF0gPSBjdXJyZW50X2Nvc3QgLSByZXBsYWNlbWVudF9jb3N0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHZhbHVlLCBjb3VudCwgc2F2aW5ncyB9O1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGNvbnN0IHsgZmlyc3QsIGxhc3QgfSA9IGl0O1xuICAgICAgICBjb25zdCBwZXJjZW50X3N0YXJ0ID0gZmlyc3QgLyBjb3VudDtcbiAgICAgICAgY29uc3QgcGVyY2VudF9lbmQgPSBsYXN0IC8gY291bnQ7XG4gICAgICAgIGNvbnN0IG5vdF9wZXJjZW50X3N0YXJ0ID0gMSAtIHBlcmNlbnRfc3RhcnQ7XG4gICAgICAgIGNvbnN0IG5vdF9wZXJjZW50X2VuZCA9IDEgLSBwZXJjZW50X2VuZDtcblxuICAgICAgICAvLyBpZiBpdCBpcyBhbHdheXMgcHJlY2VlZGVkIGJ5IGEgc3BhY2UsIHdlIHdpbGwgbGF0ZXIgcHJlcGVuZCBhIFwiIFwiIHNwYWNlXG4gICAgICAgIGNvbnN0IHBhZCA9IGZpcnN0ID09PSAwO1xuICAgICAgICBpZiAoZGVidWdfbGV2ZWwgPj0gMikgY29uc29sZS5sb2coXCJwYWQ6XCIsIHBhZCk7XG5cbiAgICAgICAgLy8gaG93IG1hbnkgY2hhcmFjdGVycyB0aGUgY3VycmVudCB2YWx1ZSB0YWtlcyB1cFxuICAgICAgICBjb25zdCB2YWx1ZV9sZW5ndGggPSBgJHtwYWQgPyBcIiBcIiA6IFwiXCJ9JHt2YWx1ZV9zdHJpbmd9YC5sZW5ndGg7XG4gICAgICAgIGlmIChkZWJ1Z19sZXZlbCA+PSAyKSBjb25zb2xlLmxvZyhcInZhbHVlX2xlbmd0aDpcIiwgdmFsdWVfbGVuZ3RoKTtcblxuICAgICAgICBjb25zdCBjdXJyZW50X2Nvc3QgPSBjb3VudCAqIHZhbHVlX2xlbmd0aDtcbiAgICAgICAgaWYgKGRlYnVnX2xldmVsID49IDIpIGNvbnNvbGUubG9nKFwiY3VycmVudF9jb3N0OlwiLCBjdXJyZW50X2Nvc3QpO1xuXG4gICAgICAgIGNvbnN0IHNhdmluZ3MgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgdmFyaWFibGVfbGVuZ3RoID0gMTsgdmFyaWFibGVfbGVuZ3RoIDw9IDU7IHZhcmlhYmxlX2xlbmd0aCsrKSB7XG4gICAgICAgICAgLy8gbGlrZSAsQT0nK2xvbl8wPTEwNSdcbiAgICAgICAgICBsZXQgZGVjbGFyYXRpb25fbGVuZ3RoID0gMSArIHZhcmlhYmxlX2xlbmd0aCArIDEgKyAxICsgdmFsdWVfbGVuZ3RoICsgMTtcblxuICAgICAgICAgIC8vIG5vdCBmYWN0b3JpbmcgaW4gdGhhdCBzdHJpbmdzIGNhbiBiZSBrZXlzIGFzIHdlbGxcbiAgICAgICAgICAvLyB3aWxsIG5lZWQgdG8gdXBncmFkZSBkZWVwLWNvdW50ZXIgdG8gdHJhY2sgYWRkaXRpb25hbCBzdGF0cyBsaWtlIGlzIHRoZSBzdHJpbmcgYSBjb21wbGV0ZSBrZXksIGlzIHRoZSBzdHJpbmcgcGFydCBvZiBhIGtleSBhbmQgcG9zaXRpb24sIGFuZCBpcyBzdHJpbmcgYSBzdWJzdHJpbmcgaW4gYSBzdHJpbmdcbiAgICAgICAgICAvLyBhbHNvIG5lZWQgdG8gZmFjdG9yIGluIHdoZXRoZXIgdG8gcHJlcGVuZCBzcGFjZSBvciBub3RcbiAgICAgICAgICAvLyA/PyBtYXliZSBzaG91bGQgZmFjdG9yIGluIGFzc3VtaW5nIHN0cmluZ3MgYXJlIHJlcGxhY2VkIGJlZm9yZSBhbmQgYWZ0ZXIgd2l0aCB2YXJpYWJsZXMgPz9cbiAgICAgICAgICBjb25zdCBhdmVyYWdlX3JlcGxhY2VtZW50X2xlbmd0aCA9IGBcIitgLmxlbmd0aCAqIG5vdF9wZXJjZW50X3N0YXJ0ICsgdmFyaWFibGVfbGVuZ3RoICsgYFwiK2AubGVuZ3RoICogbm90X3BlcmNlbnRfZW5kO1xuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiYXZlcmFnZV9yZXBsYWNlbWVudF9sZW5ndGg6XCIsIGF2ZXJhZ2VfcmVwbGFjZW1lbnRfbGVuZ3RoKTtcblxuICAgICAgICAgIGNvbnN0IHRvdGFsX3JlcGxhY2VtZW50X3NpemUgPSBkZWNsYXJhdGlvbl9sZW5ndGggKyBhdmVyYWdlX3JlcGxhY2VtZW50X2xlbmd0aCAqIGNvdW50O1xuICAgICAgICAgIGlmIChkZWJ1Z19sZXZlbCA+PSAzKSBjb25zb2xlLmxvZyhcInRvdGFsX3JlcGxhY2VtZW50X3NpemU6XCIsIHRvdGFsX3JlcGxhY2VtZW50X3NpemUpO1xuICAgICAgICAgIHNhdmluZ3NbdmFyaWFibGVfbGVuZ3RoXSA9IGN1cnJlbnRfY29zdCAtIHRvdGFsX3JlcGxhY2VtZW50X3NpemU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlYnVnX2xldmVsID49IDIpIGNvbnNvbGUubG9nKFwic2F2aW5nczpcIiwgc2F2aW5ncyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsdWU6IChwYWQgPyBcIiBcIiA6IFwiXCIpICsgaXQudmFsdWUsXG4gICAgICAgICAgY291bnQ6IGNvdW50LFxuICAgICAgICAgIGZpcnN0LFxuICAgICAgICAgIGxhc3QsXG4gICAgICAgICAgcGFkLFxuICAgICAgICAgIHNhdmluZ3NcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9KTtcbiAgaWYgKGRlYnVnX2xldmVsID49IDEpIGNvbnNvbGUubG9nKHRva2Vucyk7XG5cbiAgY29uc3Qgc2tpcFZhck5hbWVzID0gbmV3IFNldCgpO1xuICBpZiAobGFuZyA9PT0gXCJQWVwiKSB7XG4gICAgW1wiYW5kXCIsIFwiYXNcIiwgXCJpc1wiLCBcIm9yXCIsIFwibnVsbFwiXS5mb3JFYWNoKHNraXB3b3JkID0+IHtcbiAgICAgIHNraXBWYXJOYW1lcy5hZGQoc2tpcHdvcmQpO1xuICAgIH0pO1xuICB9XG5cbiAgY29uc3QgdmFybmFtZTJ0b2tlbiA9IG5ldyBNYXAoKTtcbiAgY29uc3QgdG9rZW4ydmFybmFtZSA9IG5ldyBNYXAoKTtcblxuICBjb25zdCBnZW4gPSBnZW5WYXJOYW1lcygpO1xuICBmb3IgKGNvbnN0IHZhcm5hbWUgb2YgZ2VuKSB7XG4gICAgaWYgKGRlYnVnX2xldmVsID49IDIpIGNvbnNvbGUubG9nKFwidmFybmFtZTpcIiwgdmFybmFtZSk7XG4gICAgaWYgKHNraXBWYXJOYW1lcy5oYXModmFybmFtZSkpIGNvbnRpbnVlO1xuXG4gICAgY29uc3QgdmFybGVuID0gdmFybmFtZS5sZW5ndGg7XG5cbiAgICAvLyBzb3J0IHRva2VucyBieSBzYXZpbmcgZm9yIHRoZSBnaXZlbiB2YXJpYWJsZSdzIGxlbmd0aFxuICAgIHRva2Vucy5zb3J0KChhLCBiKSA9PiBNYXRoLnNpZ24oYi5zYXZpbmdzW3Zhcmxlbl0gLSBhLnNhdmluZ3NbdmFybGVuXSkpO1xuXG4gICAgLy8gcG9wIG91dCB0aGUgZmlyc3QgdG9rZW5cbiAgICBjb25zdCB0b2tlbiA9IHRva2Vucy5zaGlmdCgpO1xuXG4gICAgLy8gaWYgd2UgY2FuIHNhdmUgYW55IHNwYWNlIHdpdGggdGhlIHRva2VuIHdpdGggdGhlIG1vc3QgcG90ZW50aWFsIHNhdmluZ3MsIGJyZWFrXG4gICAgaWYgKHRva2VuLnNhdmluZ3NbdmFybGVuXSA8PSAwKSBicmVhaztcblxuICAgIC8vIGNvbnNvbGUubG9nKFwidG9rZW46XCIsIHRva2VuKTtcbiAgICAvLyBzYXZlIHRoZSBzZWxlY3Rpb25cblxuICAgIHZhcm5hbWUydG9rZW4uc2V0KHZhcm5hbWUsIHsgZmlyc3Q6IHRva2VuLmZpcnN0LCB0b2tlbjogdG9rZW4udmFsdWUgfSk7XG4gICAgdG9rZW4ydmFybmFtZS5zZXQodG9rZW4udmFsdWUsIHsgdmFybmFtZSwgZmlyc3Q6IHRva2VuLmZpcnN0LCB2YWx1ZTogdG9rZW4udmFsdWUgfSk7XG4gIH1cbiAgaWYgKGRlYnVnX2xldmVsID49IDEpIGNvbnNvbGUubG9nKFwiYXNzaWduZWQgdmFyaWFibGUgbmFtZXMgdG8gdG9rZW5zXCIpO1xuICBpZiAoZGVidWdfbGV2ZWwgPj0gMikgY29uc29sZS5sb2coXCJ0b2tlbjJuYW1lOlwiLCB0b2tlbjJ2YXJuYW1lKTtcblxuICAvLyBjb25zb2xlLmxvZyhcInZhcm5hbWUydG9rZW5bJ1UnXTpcIiwgdmFybmFtZTJ0b2tlblsnVSddKTtcblxuICAvLyBnZXQgYSBjbG9uZSBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuICBjb25zdCByZXN1bHQgPSBKU09OLnBhcnNlKHN0cmluZ2lmaWVkKTtcbiAgaWYgKGRlYnVnX2xldmVsID49IDEpIGNvbnNvbGUubG9nKFwiY2xvbmVkIG9yaWdpbmFsIGRhdGFcIik7XG4gIGlmIChkZWJ1Z19sZXZlbCA+PSAyKSBjb25zb2xlLmxvZyhcImNsb25lZCBkYXRhOlwiLCByZXN1bHQpO1xuXG4gIGNvbnN0IGRlbHByZXZjaGFyID0gYDxkZWxwcmV2Y2hhci0ke3VpZH0+YDtcbiAgY29uc3QgZGVsbmV4dGNoYXIgPSBgPGRlbG5leHRjaGFyLSR7dWlkfT5gO1xuXG4gIC8vIGlzIHRoZSBzdHJpbmcgYW4gZXhwcmVzc2lvbiBmb3IgYW4gb2JqZWN0IGtleVxuICAvLyBsaWtlIFthK2IrY10gaW4geyBbYStiK2NdOiB2YWx1ZSB9XG4gIGNvbnN0IGlzT2JqS2V5RXhwckZuID0gKHsgc3RyLCB0eXBlIH0pID0+IHtcbiAgICByZXR1cm4gdHlwZSA9PT0gXCJvYmplY3Qta2V5LXN0cmluZ1wiICYmIHN0ci5zdGFydHNXaXRoKGRlbHByZXZjaGFyICsgXCJbXCIpICYmIHN0ci5lbmRzV2l0aChkZWxuZXh0Y2hhciArIFwiXVwiKTtcbiAgfTtcblxuICBjb25zdCBsb29rdXAgPSB4ID0+IHtcbiAgICBsZXQgdmFybmFtZTtcbiAgICBsZXQgdmFydmFsdWU7XG4gICAgaWYgKHRva2VuMnZhcm5hbWUuaGFzKHgpKSB7XG4gICAgICB2YXJuYW1lID0gdG9rZW4ydmFybmFtZS5nZXQoeCkudmFybmFtZTtcbiAgICAgIHZhcnZhbHVlID0geDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB4ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBpZiAoeC5zdGFydHNXaXRoKFwiIFwiKSAmJiB0b2tlbjJ2YXJuYW1lLmhhcyh4LnN1YnN0cigxKSkpIHtcbiAgICAgICAgdmFybmFtZSA9IHRva2VuMnZhcm5hbWUuZ2V0KHguc3Vic3RyKDEpKS52YXJuYW1lO1xuICAgICAgICB2YXJ2YWx1ZSA9IHguc3Vic3RyKDEpO1xuICAgICAgfSBlbHNlIGlmICgheC5zdGFydHNXaXRoKFwiIFwiKSAmJiB0b2tlbjJ2YXJuYW1lLmdldChcIiBcIiArIHgpKSB7XG4gICAgICAgIHZhcm5hbWUgPSB0b2tlbjJ2YXJuYW1lLmdldChcIiBcIiArIHgpLnZhcm5hbWU7XG4gICAgICAgIHZhcnZhbHVlID0gXCIgXCIgKyB4O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyB2YXJuYW1lLCB2YXJ2YWx1ZSB9O1xuICB9O1xuXG4gIGNvbnN0IGdldFZhck91dCA9ICh7IGl0LCB2YXJuYW1lLCB2YXJ2YWx1ZSB9KSA9PiB7XG4gICAgaWYgKHR5cGVvZiBpdCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgaWYgKGl0LnN0YXJ0c1dpdGgoXCIgXCIpKSB7XG4gICAgICAgIGlmICh2YXJ2YWx1ZS5zdGFydHNXaXRoKFwiIFwiKSkge1xuICAgICAgICAgIHJldHVybiB2YXJuYW1lO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBgXCIgXCIrJHt2YXJuYW1lfWA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodmFydmFsdWUuc3RhcnRzV2l0aChcIiBcIikpIHtcbiAgICAgICAgaWYgKGxhbmcgPT09IFwiSlNcIikge1xuICAgICAgICAgIHJldHVybiBgJHt2YXJuYW1lfS50cmltKClgO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBgJHt2YXJuYW1tZX0uc3RyaXAoKWA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhcm5hbWU7XG4gIH07XG5cbiAgY29uc3QgdW5lc2NwID0gc3RyID0+XG4gICAgc3RyLnJlcGxhY2VBbGwoJ1wiJywgKG1hdGNoLCBvZmZzZXQsIHN0cmluZykgPT4ge1xuICAgICAgY29uc3QgYmVmb3JlID0gc3RyaW5nLnN1YnN0cmluZygwLCBvZmZzZXQpO1xuICAgICAgaWYgKGJlZm9yZS5lbmRzV2l0aChkZWxuZXh0Y2hhcikpIHJldHVybiAnXCInO1xuICAgICAgZWxzZSByZXR1cm4gZGVsbmV4dGNoYXIgKyAnXCInO1xuICAgIH0pO1xuXG4gIGNvbnN0IGdldEV4cHIgPSBpdCA9PiB7XG4gICAgY29uc3QgeyB2YXJuYW1lLCB2YXJ2YWx1ZSB9ID0gbG9va3VwKGl0KTtcbiAgICBpZiAodmFybmFtZSkgcmV0dXJuIGdldFZhck91dCh7IGl0LCB2YXJuYW1lLCB2YXJ2YWx1ZSB9KTtcbiAgfTtcblxuICBpZiAoZGVidWdfbGV2ZWwgPj0gMSkgY29uc29sZS5sb2coXCJzdGFydGluZyB3YWxrXCIpO1xuXG4gIC8vIGZpcnN0IHJlcGxhY2VtZW50IHBhc3NcbiAgLy8gd2FsayB0aHJvdWdoIHdob2xlIG9iamVjdCBhbmQgcmVwbGFjZSBzdWJzdHJpbmcgYW5kIG51bWJlcnMgd2l0aCB2YXJpYWJsZXNcbiAgd2Fsayh7XG4gICAgZGF0YTogcmVzdWx0LFxuICAgIGNhbGxiYWNrOiAoeyBkYXRhOiBpdCwgbW9kLCB0eXBlOiBkYXRhVHlwZSB9KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoZGVidWdfbGV2ZWwgPj0gMikgY29uc29sZS5sb2coXCJ3YWxraW5nXCIsIHsgaXQsIGRhdGFUeXBlIH0pO1xuICAgICAgICBpZiAodHlwZW9mIGl0ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgY29uc3QgeyB2YXJuYW1lIH0gPSBsb29rdXAoaXQpO1xuICAgICAgICAgIGlmICh2YXJuYW1lKSBtb2QoZGVscHJldmNoYXIgKyB2YXJuYW1lICsgZGVsbmV4dGNoYXIpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpdCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIGNvbnN0IGV4cHIgPSBnZXRFeHByKGl0KTtcbiAgICAgICAgICBpZiAoZXhwcikgbW9kKGRlbHByZXZjaGFyICsgZXhwciArIGRlbG5leHRjaGFyKTtcbiAgICAgICAgICBlbHNlIG1vZChkZWxwcmV2Y2hhciArIFwidW5kZWZpbmVkXCIgKyBkZWxuZXh0Y2hhcik7XG4gICAgICAgIH0gZWxzZSBpZiAoaXQgPT09IG51bGwpIHtcbiAgICAgICAgICBjb25zdCBleHByID0gZ2V0RXhwcihpdCk7XG4gICAgICAgICAgaWYgKGV4cHIpIG1vZChkZWxwcmV2Y2hhciArIGV4cHIgKyBkZWxuZXh0Y2hhcik7XG4gICAgICAgICAgZWxzZSBtb2QoZGVscHJldmNoYXIgKyBcIm51bGxcIiArIGRlbG5leHRjaGFyKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaXQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBpZiAoW1wib2JqZWN0LWtleS1zdHJpbmdcIiwgXCJvYmplY3QtdmFsdWUtc3RyaW5nXCIsIFwiYXJyYXktaXRlbS1zdHJpbmdcIl0uaW5jbHVkZXMoZGF0YVR5cGUpKSB7XG4gICAgICAgICAgICBjb25zdCB3b3JkcyA9IHNlcGFybyhpdCwgXCIgXCIsIHsgYXR0YWNoU2VwOiB0cnVlIH0pLm1hcCh3b3JkID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgZXhwciA9IGdldEV4cHIod29yZCk7XG4gICAgICAgICAgICAgIGlmIChleHByKSByZXR1cm4geyBleHByIH07XG4gICAgICAgICAgICAgIGVsc2UgcmV0dXJuIHsgcXVvdGVkOiBtaW5RdW90ZSh3b3JkLCB7IGJhY2t0aWNrOiB1c2VCYWNrdGljayB9KSB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAod29yZHMuc29tZSh3b3JkID0+IHdvcmQuZXhwcikpIHtcbiAgICAgICAgICAgICAgbGV0IG1vZFN0ciA9IGRlbHByZXZjaGFyO1xuICAgICAgICAgICAgICBpZiAoZGF0YVR5cGUgPT09IFwib2JqZWN0LWtleS1zdHJpbmdcIiAmJiBsYW5nID09PSBcIkpTXCIpIG1vZFN0ciArPSBcIltcIjtcbiAgICAgICAgICAgICAgZm9yRWFjaCh3b3JkcywgKHsgaXQ6IHdvcmQsIHByZXYsIGZpcnN0OiBmaXJzdFdvcmQgfSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh3b3JkLmV4cHIpIHtcbiAgICAgICAgICAgICAgICAgIGlmICghZmlyc3RXb3JkKSBtb2RTdHIgKz0gXCIrXCI7XG4gICAgICAgICAgICAgICAgICBtb2RTdHIgKz0gd29yZC5leHByO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAvLyBjdXJyZW50IHdvcmQgYW5kIHByZXZpb3VzIHdvcmQgdXNlIHRoZSBzYW1lIHF1b3Rlc1xuICAgICAgICAgICAgICAgICAgaWYgKHdvcmQucXVvdGVkWzBdID09PSBwcmV2Py5xdW90ZWQ/LlswXSkge1xuICAgICAgICAgICAgICAgICAgICBtb2RTdHIgPSBtb2RTdHIuc2xpY2UoMCwgLTEpICsgd29yZC5xdW90ZWQuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyAyIHN0cmluZ3MgaW4gYSByb3cgdGhhdCBzaGFyZSBkaWZmZXJlbnQgcXVvdGVzXG4gICAgICAgICAgICAgICAgICAgIGlmICghZmlyc3RXb3JkKSBtb2RTdHIgKz0gXCIrXCI7XG4gICAgICAgICAgICAgICAgICAgIG1vZFN0ciArPSB3b3JkLnF1b3RlZDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBpZiAoZGF0YVR5cGUgPT09IFwib2JqZWN0LWtleS1zdHJpbmdcIiAmJiBsYW5nID09PSBcIkpTXCIpIG1vZFN0ciArPSBcIl1cIjtcbiAgICAgICAgICAgICAgbW9kU3RyICs9IGRlbG5leHRjaGFyO1xuICAgICAgICAgICAgICBtb2QodW5lc2NwKG1vZFN0cikpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbW9kKGRlbHByZXZjaGFyICsgdW5lc2NwKG1pblF1b3RlKGl0LCB7IGJhY2t0aWNrOiB1c2VCYWNrdGljayB9KSkgKyBkZWxuZXh0Y2hhcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiW2pzb24tdG8tY29kZV0gaXQ6XCIsIHsgaXQsIGRhdGFUeXBlIH0pO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5leHBlY3RlZCBkYXRhVHlwZTpcIiwgZGF0YVR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIndhbGtpbmcgZXJyb3JcIiwgZXJyb3IpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIC8qXG4gICAgQXJyYXkgdG8gaG9sZCB2YXJpYWJsZXMgY3JlYXRlZCBmcm9tIHRoZSBjb25jYXRlbmF0aW9uIG9mIG90aGVyIHZhcnNcbiAgICBGb3IgZXhhbXBsZSBBPUIrQ1xuICAgIEFuZCB0aGUgb3JkZXIgaXMgaW1wb3J0YW50XG4gICovXG5cbiAgY29uc3QgdXNlZFZhck5hbWVzID0gbmV3IFNldCh2YXJuYW1lMnRva2VuLmtleXMoKSk7XG4gIGNvbnN0IGFsbF9zdWJzdGl0dXRpb25zID0gW107XG4gIGxldCBwYXNzID0gMTsgLy8gY291bnQgcHJldmlvdXMgcGFzcyBmb3IgdW5pZ3JhbXNcbiAgd2hpbGUgKHBhc3MgPCBtYXhfcGFzc2VzKSB7XG4gICAgLy8gaG9sZHMgd2hldGhlciBhbnl0aGluZyBjaGFuZ2VkXG4gICAgbGV0IGNoYW5nZWQgPSBmYWxzZTtcblxuICAgIC8vIHJlcGVhdCB0cnlpbmcgdG8gcmVjdXJzaXZlbHkgY29tcHJlc3MgYmlncmFtc1xuICAgIC8vIHVudGlsIGNhbid0IHNhdmUgYW55IG1vcmUgc3BhY2VcbiAgICB3aGlsZSAocGFzcyA8IG1heF9wYXNzZXMpIHtcbiAgICAgIGlmIChkZWJ1Z19sZXZlbCA+PSAxKSBjb25zb2xlLmxvZyhcImNoZWNraW5nIGJpZ3JhbSBzYXZpbmcgb3Bwb3J0dW5pdGllc1wiKTtcbiAgICAgIC8vIGluY3JlbWVudCBwYXNzIG5vdyBiZWNhdXNlIG1pZ2h0IGJyZWFrIGVhcmx5IGxhdGVyIGlmIG5vIHBvdGVudGlhbCBzYXZpbmdzXG4gICAgICBwYXNzKys7XG5cbiAgICAgIGNvbnN0IHN1YnN0aXR1dGlvbnMgPSB7fTtcblxuICAgICAgLy8gZ2V0IGFuIGFycmF5IG9mIG5ldyB2YXJuYW1lcyBvZiBhbGwgdGhlIHNhbWUgbGVuZ3RoIChpLmUuIGNvc3QpXG4gICAgICBjb25zdCB2YXJuYW1lcyA9IFtdO1xuICAgICAgbGV0IHZhcmxlbjtcbiAgICAgIGNvbnN0IHZhck5hbWVHZW4gPSBnZW5WYXJOYW1lcygpO1xuICAgICAgZm9yIChjb25zdCB2YXJuYW1lIG9mIHZhck5hbWVHZW4pIHtcbiAgICAgICAgaWYgKHVzZWRWYXJOYW1lcy5oYXModmFybmFtZSkpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoc2tpcFZhck5hbWVzLmhhcyh2YXJuYW1lKSkgY29udGludWU7XG4gICAgICAgIGlmICghdmFybGVuKSB2YXJsZW4gPSB2YXJuYW1lLmxlbmd0aDtcbiAgICAgICAgaWYgKHZhcm5hbWUubGVuZ3RoICE9PSB2YXJsZW4pIGJyZWFrO1xuICAgICAgICB2YXJuYW1lcy5wdXNoKHZhcm5hbWUpO1xuICAgICAgfVxuICAgICAgaWYgKGRlYnVnX2xldmVsID49IDIpIGNvbnNvbGUubG9nKGAke3Zhcm5hbWVzLmxlbmd0aH0gcG9zc2libGUgdmFybmFtZXMgd2l0aCBsZW5ndGggJHt2YXJsZW59YCk7XG5cbiAgICAgIC8vIG9iamVjdCB3aXRoXG4gICAgICAvLyBrZXk6IEpTT04gb2YgYmlncmFtIGFycmF5XG4gICAgICAvLyB2YWx1ZTogcmF3IG51bWJlciBjb3VudFxuICAgICAgY29uc3QgYmlncmFtX2NvdW50ID0ge307XG5cbiAgICAgIC8vIHdlIGFscmVhZHkgcmVwbGFjZWQgbnVtYmVycywgbnVsbHMsIGFuZCB1bmRlZmluZWRzIGluIHRoZSBmaXJzdCBwYXNzXG4gICAgICAvLyBzbyB3ZSBjYW4ganVzdCBmb2N1cyBvbiBzdHJpbmdzXG4gICAgICBmb3JFYWNoU3RyaW5nKHJlc3VsdCwgbGVhZiA9PiB7XG4gICAgICAgIGxldCB7IHN0ciB9ID0gbGVhZjtcblxuICAgICAgICAvLyByZW1vdmUgYW55IHRleHQgb3BlcmF0aW9ucyBsaWtlIGRlbHByZXZjaGFyIGFuZCBkZWxuZXh0Y2hhclxuICAgICAgICAvLyBhc3N1bWluZyB0ZXh0IG9wcyBhcmUgb25seSBhdCB0aGUgYmVnaW5uaW5nIGFuZCB0aGUgZW5kXG4gICAgICAgIC8vIGlzIHRoYXQgYSBnb29kIGFzc3VtcHRpb24/XG4gICAgICAgIHN0ciA9IHN0cmlwdGFncyhzdHIpO1xuXG4gICAgICAgIC8vIHJlbW92ZSB3cmFwcGluZyBzdHJhaWdodCBicmFjZXMgYXJvdW5kIHZhcmlhYmxlIG9iamVjdCBrZXlzXG4gICAgICAgIC8vIGxpa2UgZ29pbmcgZnJvbSBbYStiXSB0byBhK2JcbiAgICAgICAgaWYgKGlzT2JqS2V5RXhwckZuKGxlYWYpKSBzdHIgPSB1bmJyYWNlKHN0cik7XG5cbiAgICAgICAgLy8gZnJvbSBhK2IgdG8gYXJyYXkgb2YgW1wiYVwiLCBcImJcIl1cbiAgICAgICAgY29uc3QgcGFydHMgPSBkZWNvbmNhdChzdHIpO1xuXG4gICAgICAgIC8vIGNvdW50IHNlcXVlbnRpYWwgcGFpcnNcbiAgICAgICAgY29uc3QgYmlncmFtcyA9IGNvdW50TkdyYW1zKHsgZGF0YTogcGFydHMsIG46IDIgfSk7XG5cbiAgICAgICAgZm9yIChsZXQgYiA9IDA7IGIgPCBiaWdyYW1zLmxlbmd0aDsgYisrKSB7XG4gICAgICAgICAgY29uc3QgW2JpZ3JhbSwgc3ViY291bnRdID0gYmlncmFtc1tiXTtcbiAgICAgICAgICBjb25zdCBbZmlyc3QsIHNlY29uZF0gPSBiaWdyYW07XG5cbiAgICAgICAgICAvLyBpZ25vcmUgYmlncmFtcyB0aGF0IGluY2x1ZGUgcmF3IHN0cmluZ3NcbiAgICAgICAgICAvLyBjb2RlIGN1cnJlbnRseSBvbmx5IGhhbmRsZXMgYmlncmFtcyBtYWRlIHVwIG9mIDIgdmFyaWFibGVzXG4gICAgICAgICAgaWYgKGlzUXVvdGVkKGZpcnN0KSB8fCBpc1F1b3RlZChzZWNvbmQpKSBjb250aW51ZTtcblxuICAgICAgICAgIC8vIGNvbnZlcnQgYmlncmFtIGFycmF5IHRvIEpTT04gc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gICAgICAgICAgY29uc3Qga2V5ID0gSlNPTi5zdHJpbmdpZnkoYmlncmFtKTtcbiAgICAgICAgICBpZiAoa2V5IGluIGJpZ3JhbV9jb3VudCkgYmlncmFtX2NvdW50W2tleV0gKz0gc3ViY291bnQ7XG4gICAgICAgICAgZWxzZSBiaWdyYW1fY291bnRba2V5XSA9IHN1YmNvdW50O1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgYmlncmFtX3NhdmluZ3MgPSBbXTtcbiAgICAgIE9iamVjdC5lbnRyaWVzKGJpZ3JhbV9jb3VudCkuZm9yRWFjaCgoW2JpZ3JhbSwgY291bnRdKSA9PiB7XG4gICAgICAgIC8vIGNvbnZlcnQgYmlncmFtIGtleSB0byBhY3R1YWwgYXJyYXlcbiAgICAgICAgY29uc3QgYmlncmFtX2FycmF5ID0gSlNPTi5wYXJzZShiaWdyYW0pO1xuXG4gICAgICAgIC8vIGJpZ3JhbSBpcyBsaWtlIFsgJ0UnLCAnQScgXVxuICAgICAgICAvLyBnZXQgbGVuZ3RoIG9mIEUrQSBvciAzXG4gICAgICAgIGNvbnN0IGxlbiA9IGJpZ3JhbV9hcnJheS5qb2luKFwiK1wiKS5sZW5ndGg7XG5cbiAgICAgICAgLy8gY3VycmVudCBjaGFyYWN0ZXIgY291bnQgb2YgYmlncmFtc1xuICAgICAgICBjb25zdCBjdXJyZW50X2Nvc3QgPSBsZW4gKiBjb3VudDtcblxuICAgICAgICAvLyBkZWNsYXJhdGlvbiBjb3N0IGlzICwgKyB2YXJpYWJsZSArID0gKyBsZW5cbiAgICAgICAgY29uc3QgZGVjbGFyYXRpb25fY29zdCA9IDEgKyB2YXJsZW4gKyAxICsgbGVuO1xuXG4gICAgICAgIC8vIGhvdyBtYW55IGJ5dGVzIGJpZ3JhbSB3b3VsZCB0YWtlIHVwIGlmIHJlcGxhY2VkIHdpdGggYSB2YXJpYWJsZVxuICAgICAgICBjb25zdCByZXBsYWNlbWVudF9jb3N0ID0gZGVjbGFyYXRpb25fY29zdCArIHZhcmxlbiAqIGNvdW50O1xuXG4gICAgICAgIC8vIGhvdyBtYW55IGJ5dGVzIHdlIHdvdWxkIHNhdmUgaWYgd2UgcmVwbGFjZWQgYSBiaWdyYW0gd2l0aCBhIHZhcmlhYmxlXG4gICAgICAgIGNvbnN0IHNhdmluZ3MgPSBjdXJyZW50X2Nvc3QgLSByZXBsYWNlbWVudF9jb3N0O1xuXG4gICAgICAgIC8vIG9ubHkgY2FyZSBpZiBhY3R1YWxseSBzYXZlIHNwYWNlXG4gICAgICAgIGlmIChzYXZpbmdzID4gMCkgYmlncmFtX3NhdmluZ3MucHVzaChbYmlncmFtLCBzYXZpbmdzXSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gbm8gbW9yZSBvcHBvcnR1bml0aWVzIHRvIHNhdmUgc3BhY2VcbiAgICAgIC8vIGJyZWFrcyBvdXQgb2Ygb25seSBpbm5lciBsb29wIGZvciBiaWdyYW1zXG4gICAgICBpZiAoYmlncmFtX3NhdmluZ3MubGVuZ3RoID09PSAwKSBicmVhaztcblxuICAgICAgLy8gc29ydCBiaWdyYW0gc2F2aW5ncyBhcnJheSBmcm9tIHNtYWxsZXN0IHRvIGxhcmdlc3Qgc2F2aW5nc1xuICAgICAgYmlncmFtX3NhdmluZ3Muc29ydCgoYSwgYikgPT4gTWF0aC5zaWduKGFbMV0gLSBiWzFdKSk7XG5cbiAgICAgIC8vIGNvbnNvbGUubG9nKGBiaWdyYW1fc2F2aW5ncyAoJHtiaWdyYW1fc2F2aW5ncy5sZW5ndGh9KSA6YCwgYmlncmFtX3NhdmluZ3Muc2xpY2UoMCwgMykpO1xuXG4gICAgICAvLyBpdGVyYXRlIHRocm91Z2ggdmFybmFtZXMgb2YgdGhlIHNhbWUgbGVuZ3RoXG4gICAgICAvLyBhc3NpZ25pbmcgYmlncmFtcyB0byB0aGUgcmVtYWluaW5nIG5hbWVzXG4gICAgICBjb25zdCBiaWdyYW1fdG9fdmFybmFtZSA9IHt9O1xuICAgICAgZm9yIChsZXQgdiA9IDA7IHYgPCB2YXJuYW1lcy5sZW5ndGg7IHYrKykge1xuICAgICAgICBjb25zdCB2YXJuYW1lID0gdmFybmFtZXNbdl07XG5cbiAgICAgICAgLy8gcG9wIG9mZiB0aGUgbGFzdCBiaWdyYW0gd2hpY2ggaGFzIHRoZSBiaWdnZXN0IHNhdmluZ3NcbiAgICAgICAgY29uc3QgYmlncmFtID0gYmlncmFtX3NhdmluZ3MucG9wKClbMF07XG5cbiAgICAgICAgLy8gYmlncmFtIGlzIGFscmVhZHkgSlNPTiBzdHJpbmdpZmllZFxuICAgICAgICBiaWdyYW1fdG9fdmFybmFtZVtiaWdyYW1dID0gdmFybmFtZTtcblxuICAgICAgICAvLyBubyBtb3JlIGJpZ3JhbXMgdG8gcmVwbGFjZVxuICAgICAgICAvLyBzZWVtcyB3ZSBoYXZlIG1vcmUgcG90ZW50aWFsIHZhcmlhYmxlIG5hbWVzXG4gICAgICAgIC8vIHRoYW4gYWN0dWFsIHJlcGxhY2VhYmxlIGJpZ3JhbXNcbiAgICAgICAgaWYgKGJpZ3JhbV9zYXZpbmdzLmxlbmd0aCA9PT0gMCkgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIC8vIHdhbGsgdGhyb3VnaCBkYXRhIGFuZCBtYWtlIHN1YnN0aXR1dGlvbnNcbiAgICAgIGZvckVhY2hTdHJpbmcocmVzdWx0LCBsZWFmID0+IHtcbiAgICAgICAgbGV0IHsgc3RyLCBtb2QsIHR5cGUgfSA9IGxlYWY7XG5cbiAgICAgICAgY29uc3QgaGFzRGVsUHJldiA9IHN0ci5zdGFydHNXaXRoKGRlbHByZXZjaGFyKTtcbiAgICAgICAgY29uc3QgaGFzRGVsTmV4dCA9IHN0ci5lbmRzV2l0aChkZWxuZXh0Y2hhcik7XG5cbiAgICAgICAgLy8gcmVtb3ZlIHRleHQgb3BlcmF0aW9uc1xuICAgICAgICBzdHIgPSBzdHJpcHRhZ3Moc3RyKTtcblxuICAgICAgICBsZXQgaXNPYmpLZXlFeHByID0gaXNPYmpLZXlFeHByRm4obGVhZik7XG5cbiAgICAgICAgLy8gcmVtb3ZlIHdyYXBwaW5nIHN0cmFpZ2h0IGJyYWNlcyBhcm91bmQgdmFyaWFibGUgb2JqZWN0IGtleXNcbiAgICAgICAgLy8gbGlrZSBnb2luZyBmcm9tIFthK2JdIHRvIGErYlxuICAgICAgICBpZiAoaXNPYmpLZXlFeHByKSBzdHIgPSB1bmJyYWNlKHN0cik7XG5cbiAgICAgICAgLy8gY29udmVydHMgRCsnICtsYXQ9MzknK3UrQ08gaW50byBbXCJEXCIsIFwiJyArbGF0PTM5J1wiLCBcInVcIiwgXCJDT1wiXSwgc28gY2FuIGJlIGNvbWJpbmVkIGFnYWluIHdpdGggK1xuICAgICAgICBjb25zdCBwYXJ0cyA9IGRlY29uY2F0KHN0cik7XG5cbiAgICAgICAgLy8gcGFydHMgb2Ygc3RyaW5nIHdpdGggdmFyaWFibGUgc3Vic3RpdHV0aW9uXG4gICAgICAgIGNvbnN0IHN3YXBwZWQgPSBbXTtcblxuICAgICAgICBsZXQgbmVlZFRvTW9kID0gZmFsc2U7XG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBzd2FwcGVkLnB1c2gocGFydHNbMF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGNhbiBvbmx5IHJlcGxhY2UgYmlncmFtcyBpZiBoYXZlIG1vcmUgdGhhbiBvbmUgZ3JhbVxuICAgICAgICAgIGZvciAobGV0IHAgPSAxOyBwIDwgcGFydHMubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHByZXYgPSBwYXJ0c1twIC0gMV07XG4gICAgICAgICAgICBjb25zdCBjdXJyID0gcGFydHNbcF07XG4gICAgICAgICAgICBjb25zdCBiaWdyYW0gPSBbcHJldiwgY3Vycl07XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBKU09OLnN0cmluZ2lmeShiaWdyYW0pO1xuICAgICAgICAgICAgaWYgKGtleSBpbiBiaWdyYW1fdG9fdmFybmFtZSkge1xuICAgICAgICAgICAgICBuZWVkVG9Nb2QgPSB0cnVlO1xuICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJvYmplY3Qta2V5LXN0cmluZ1wiKSBpc09iaktleUV4cHIgPSB0cnVlO1xuICAgICAgICAgICAgICBjb25zdCB2YXJuYW1lID0gYmlncmFtX3RvX3Zhcm5hbWVba2V5XTtcbiAgICAgICAgICAgICAgc3dhcHBlZC5wdXNoKHZhcm5hbWUpO1xuICAgICAgICAgICAgICB1c2VkVmFyTmFtZXMuYWRkKHZhcm5hbWUpO1xuICAgICAgICAgICAgICBzdWJzdGl0dXRpb25zW2tleV0gPSB2YXJuYW1lO1xuICAgICAgICAgICAgICBwKys7IC8vIHNraXAgY2hlY2tpbmcgdGhlIG5leHQgYmlncmFtIChiZWNhdXNlIGN1cnIgd291bGQgYmUgcHJldiBmb3IgdGhhdClcblxuICAgICAgICAgICAgICAvLyB0aGVyZSdzIG9ubHkgb25lIGdyYW0gbGVmdCwgc28gd2Uga25vdyB0aGF0IGl0IHdvbid0IGJlIHJlcGxhY2VkXG4gICAgICAgICAgICAgIGlmIChwID09PSBwYXJ0cy5sZW5ndGggLSAxKSBzd2FwcGVkLnB1c2gocGFydHNbcF0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3dhcHBlZC5wdXNoKHByZXYpO1xuICAgICAgICAgICAgICBpZiAocCA9PT0gcGFydHMubGVuZ3RoIC0gMSkgc3dhcHBlZC5wdXNoKGN1cnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG5ld1N0ciA9IChoYXNEZWxQcmV2ID8gZGVscHJldmNoYXIgOiBcIlwiKSArIChpc09iaktleUV4cHIgPyBcIltcIiA6IFwiXCIpICsgc3dhcHBlZC5qb2luKFwiK1wiKSArIChpc09iaktleUV4cHIgPyBcIl1cIiA6IFwiXCIpICsgKGhhc0RlbE5leHQgPyBkZWxuZXh0Y2hhciA6IFwiXCIpO1xuXG4gICAgICAgIGlmIChuZWVkVG9Nb2QpIG1vZCh1bmVzY3AobmV3U3RyKSk7XG4gICAgICB9KTtcbiAgICAgIGlmIChoYXNTdHVmZihzdWJzdGl0dXRpb25zKSkge1xuICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgYWxsX3N1YnN0aXR1dGlvbnMucHVzaCh7IHR5cGU6IFwiYmlncmFtXCIsIGRhdGE6IHN1YnN0aXR1dGlvbnMgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZG9uZSB0cnlpbmcgdG8gc2F2ZSBzcGFjZSB2aWEgcmVjdXJzaXZlIGJpZ3JhbXMsXG4gICAgLy8gc28gbm93IHRyeSB0byBmaW5kIHJlcGVhdGVkIGFycmF5c1xuICAgIGlmIChkZWJ1Z19sZXZlbCA+PSAyKSBjb25zb2xlLmxvZyhcImNoZWNraW5nIGFycmF5IHNhdmluZyBvcHBvcnR1bml0aWVzXCIpO1xuICAgIHdoaWxlIChwYXNzIDwgbWF4X3Bhc3NlcyAmJiByZWFkX29ubHkpIHtcbiAgICAgIHBhc3MrKztcbiAgICAgIGNvbnN0IHN1YnN0aXR1dGlvbnMgPSB7fTtcbiAgICAgIC8vIGdldCBhbiBhcnJheSBvZiBuZXcgdmFybmFtZXMgb2YgYWxsIHRoZSBzYW1lIGxlbmd0aCAoaS5lLiBjb3N0KVxuICAgICAgY29uc3QgdmFybmFtZXMgPSBbXTtcbiAgICAgIGxldCB2YXJsZW47XG4gICAgICBjb25zdCB2YXJOYW1lR2VuID0gZ2VuVmFyTmFtZXMoKTtcbiAgICAgIGZvciAoY29uc3QgdmFybmFtZSBvZiB2YXJOYW1lR2VuKSB7XG4gICAgICAgIGlmICh1c2VkVmFyTmFtZXMuaGFzKHZhcm5hbWUpKSBjb250aW51ZTtcbiAgICAgICAgaWYgKHNraXBWYXJOYW1lcy5oYXModmFybmFtZSkpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIXZhcmxlbikgdmFybGVuID0gdmFybmFtZS5sZW5ndGg7XG4gICAgICAgIGlmICh2YXJuYW1lLmxlbmd0aCAhPT0gdmFybGVuKSBicmVhaztcbiAgICAgICAgdmFybmFtZXMucHVzaCh2YXJuYW1lKTtcbiAgICAgIH1cblxuICAgICAgLy8gcmVhZCBvbmx5IG91dHB1dCwgc28gd2UgY2FuIHJlLXVzZSByZXBldGl0aXZlIGZsYXQgYXJyYXlzXG4gICAgICBjb25zdCBhcnJfY291bnQgPSB7fTtcbiAgICAgIGZvckVhY2hGbGF0QXJyYXkocmVzdWx0LCAoeyBkYXRhIH0pID0+IHtcbiAgICAgICAgbGV0IHN0ciA9IHRvU3RyaW5nKGRhdGEpO1xuXG4gICAgICAgIC8vIHN0ciBpbmNsdWRlcyBhbnkgZW1iZWRkZWQgdGV4dCBvcGVyYXRpb25zIGZvciB0aGUgYXJyYXlcblxuICAgICAgICBpZiAoYXJyX2NvdW50W3N0cl0gPT09IHVuZGVmaW5lZCkgYXJyX2NvdW50W3N0cl0gPSAwOyAvLyBpbml0aWFsaXplIHRvIHplcm8gaWYgbmVjZXNzYXJ5XG4gICAgICAgIGFycl9jb3VudFtzdHJdKys7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgYXJyX3NhdmluZ3MgPSBbXTtcbiAgICAgIE9iamVjdC5lbnRyaWVzKGFycl9jb3VudCkuZm9yRWFjaCgoW2FyciwgY291bnRdKSA9PiB7XG4gICAgICAgIC8vIHJ1biBlbWJlZGRlZCB0ZXh0IG9wZXJhdGlvbnNcbiAgICAgICAgLy8gY2xlYW5zIGFuZCByZW1vdmVzIDxkZWxwcmV2Y2hhcj4gYW5kIDxkZWxuZXh0Y2hhcj5cbiAgICAgICAgY29uc3QgeyB0ZXh0IH0gPSB0ZXh0b3BzLnJ1bih7IHRleHQ6IGFyciwgdWlkOiBOdW1iZXIodWlkKSB9KTtcblxuICAgICAgICBjb25zdCBsZW4gPSB0ZXh0Lmxlbmd0aDtcbiAgICAgICAgY29uc3QgY3VycmVudF9jb3N0ID0gbGVuICogY291bnQ7XG5cbiAgICAgICAgLy8gZGVjbGFyYXRpb24gY29zdCBpcyAsICsgdmFyaWFibGUgKyA9ICsgbGVuXG4gICAgICAgIGNvbnN0IGRlY2xhcmF0aW9uX2Nvc3QgPSAxICsgdmFybGVuICsgMSArIGxlbjtcblxuICAgICAgICBjb25zdCByZXBsYWNlbWVudF9jb3N0ID0gZGVjbGFyYXRpb25fY29zdCArIHZhcmxlbiAqIGNvdW50O1xuICAgICAgICBjb25zdCBzYXZpbmdzID0gY3VycmVudF9jb3N0IC0gcmVwbGFjZW1lbnRfY29zdDtcblxuICAgICAgICAvLyBvbmx5IGNhcmUgaWYgYWN0dWFsbHkgc2F2ZSBzcGFjZVxuICAgICAgICBpZiAoc2F2aW5ncyA+IDApIGFycl9zYXZpbmdzLnB1c2goW2Fyciwgc2F2aW5nc10pO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChhcnJfc2F2aW5ncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaWYgKGRlYnVnX2xldmVsID49IDIpIGNvbnNvbGUubG9nKFwibm8gbW9yZSBvcHBvcnR1bml0aWVzIHRvIHNhdmUgc3BhY2VcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICAvLyBzb3J0IGJpZ3JhbSBzYXZpbmdzIGFycmF5IGZyb20gc21hbGxlc3QgdG8gbGFyZ2VzdCBzYXZpbmdzXG4gICAgICBhcnJfc2F2aW5ncy5zb3J0KChhLCBiKSA9PiBNYXRoLnNpZ24oYVsxXSAtIGJbMV0pKTtcblxuICAgICAgY29uc3QgYXJyX3RvX3Zhcm5hbWUgPSB7fTtcbiAgICAgIC8vIGNvbnN0IGFjdHVhbF9hcnJfdG9fdmFybmFtZV9wYXNzZXMgPSBbXTtcbiAgICAgIGZvciAobGV0IHYgPSAwOyB2IDwgdmFybmFtZXMubGVuZ3RoOyB2KyspIHtcbiAgICAgICAgY29uc3QgdmFybmFtZSA9IHZhcm5hbWVzW3ZdO1xuICAgICAgICBjb25zdCBbYXJyLCBzYXZpbmdzXSA9IGFycl9zYXZpbmdzLnBvcCgpO1xuICAgICAgICBhcnJfdG9fdmFybmFtZVthcnJdID0gdmFybmFtZTtcbiAgICAgICAgaWYgKGFycl9zYXZpbmdzLmxlbmd0aCA9PT0gMCkgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoYXJyX3NhdmluZ3MubGVuZ3RoID09PSAxKSBjb25zb2xlLmxvZyh7IGFycl90b192YXJuYW1lIH0pO1xuXG4gICAgICBmb3JFYWNoRmxhdEFycmF5KHJlc3VsdCwgKHsgZGF0YSwgbW9kIH0pID0+IHtcbiAgICAgICAgY29uc3Qgc3RyID0gdG9TdHJpbmcoZGF0YSk7XG4gICAgICAgIC8vIGlmIGFycmF5IGlzIG5vdCB3b3J0aCByZXBsYWNpbmdcbiAgICAgICAgaWYgKHN0ciBpbiBhcnJfdG9fdmFybmFtZSkge1xuICAgICAgICAgIGNvbnN0IHZhcm5hbWUgPSBhcnJfdG9fdmFybmFtZVtzdHJdO1xuICAgICAgICAgIC8vIHJlcGxhY2UgYXJyYXkgd2l0aCBcIjxkZWxwcmV2Y2hhci11aWQ+QTxkZWxuZXh0Y2hhci11aWQ+XCJcbiAgICAgICAgICBtb2QoZGVscHJldmNoYXIgKyB2YXJuYW1lICsgZGVsbmV4dGNoYXIpO1xuICAgICAgICAgIHVzZWRWYXJOYW1lcy5hZGQodmFybmFtZSk7XG4gICAgICAgICAgc3Vic3RpdHV0aW9uc1tzdHJdID0gdmFybmFtZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChoYXNTdHVmZihzdWJzdGl0dXRpb25zKSkge1xuICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgYWxsX3N1YnN0aXR1dGlvbnMucHVzaCh7IHR5cGU6IFwiYXJyYXlcIiwgZGF0YTogc3Vic3RpdHV0aW9ucyB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpZiBjb3VsZG4ndCBmaW5kIGEgd2F5IHRvIGNvbXByZXNzIGFueSBmdXJ0aGVyLCBicmVha1xuICAgIGlmICghY2hhbmdlZCkge1xuICAgICAgY29uc29sZS5sb2coYGJyZWFraW5nIGFmdGVyICR7cGFzc30gcGFzc2VzYCk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICAvLyBjb25zb2xlLmxvZyhcImFsbF9zdWJzdGl0dXRpb25zOlwiLCBhbGxfc3Vic3RpdHV0aW9uc1swXSk7XG5cbiAgbGV0IG91dGNvZGUgPSBcIlwiO1xuXG4gIC8vIGFkZCBpbiBudWxsID0gXCJOb25lXCJcbiAgLy8gZm9yIFB5dGhvblxuICAvLyBiZWNhdXNlIEpTT04uc3RyaW5naWZ5IHdpbGwgd3JpdGUgaW4gbnVsbCB2YWx1ZXNcbiAgaWYgKGxhbmcgPT09IFwiUFlcIikge1xuICAgIG91dGNvZGUgKz0gXCIjIHNwZWNpYWwgaGFuZGxpbmcgZm9yIFB5dGhvblxcbm51bGwgPSBOb25lXFxudW5kZWZpbmVkID0gTm9uZVxcblwiO1xuICB9XG5cbiAgLy8gZmlyc3QgZGVjbGFyZSB0aGUgZmlyc3QgdmFyaWFibGUgcmVwbGFjZW1lbnRzXG4gIG91dGNvZGUgKz0gZGVjbGFyZVZhcnMoe1xuICAgIGNvbW1lbnQ6IFwicGFzcyAxXCIsXG4gICAgbGFuZ3VhZ2U6IGxhbmcsXG4gICAgdmFyczogQXJyYXkuZnJvbSh2YXJuYW1lMnRva2VuLmVudHJpZXMoKSkubWFwKChbbmFtZSwgeyB0b2tlbiB9XSkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4geyBuYW1lLCB2YWx1ZTogdG9rZW4gfTtcbiAgICAgIH0gZWxzZSBpZiAodG9rZW4gPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHsgbmFtZSwgdmFsdWU6IFwibnVsbFwiLCByYXc6IHRydWUgfTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRva2VuID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHJldHVybiB7IG5hbWUsIHZhbHVlOiBcInVuZGVmaW5lZFwiLCByYXc6IHRydWUgfTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRva2VuID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiB7IG5hbWUsIHZhbHVlOiB0b2tlbi50b1N0cmluZygpLCByYXc6IHRydWUgfTtcbiAgICAgIH1cbiAgICB9KVxuICB9KTtcblxuICBhbGxfc3Vic3RpdHV0aW9ucy5mb3JFYWNoKCh7IHR5cGUsIGRhdGEgfSwgaSkgPT4ge1xuICAgIG91dGNvZGUgKz0gXCJcXG5cXG5cIjtcbiAgICBvdXRjb2RlICs9IGRlY2xhcmVWYXJzKHtcbiAgICAgIGNvbW1lbnQ6IFwicGFzcyBcIiArIChpICsgMikgKyBcIiAoXCIgKyB0eXBlICsgXCIpXCIsXG4gICAgICBsYW5ndWFnZTogbGFuZyxcbiAgICAgIHZhcnM6IE9iamVjdC5lbnRyaWVzKGRhdGEpLm1hcCgoW29yaWdpbmFsLCB2YXJuYW1lXSkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHR5cGUgPT09IFwiYmlncmFtXCIgPyBKU09OLnBhcnNlKG9yaWdpbmFsKS5qb2luKFwiK1wiKSA6IG9yaWdpbmFsO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5hbWU6IHZhcm5hbWUsXG5cbiAgICAgICAgICAvLyBpbnNlcnQgdmFsdWUgZGlyZWN0bHkgaW50byBkZWNsYXJhdGlvbiBjb2RlXG4gICAgICAgICAgcmF3OiB0cnVlLFxuXG4gICAgICAgICAgdmFsdWVcbiAgICAgICAgfTtcbiAgICAgIH0pXG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIHByb2Nlc3MgdGV4dCBvcGVyYXRpb25zIGZvciBhcnJheXNcbiAgKHsgdGV4dDogb3V0Y29kZSB9ID0gdGV4dG9wcy5ydW4oe1xuICAgIG9wczogW1wiZGVscHJldmNoYXJcIiwgXCJkZWxuZXh0Y2hhclwiXSxcbiAgICB0ZXh0OiBvdXRjb2RlLFxuICAgIHVpZDogTnVtYmVyKHVpZClcbiAgfSkpO1xuXG4gIGlmIChkZWJ1Z19sZXZlbCA+PSAyKSBjb25zb2xlLmxvZyhcIltqc29uLXRvLWNvZGVdIHdyb3RlIGFsbCB2YXJpYWJsZSBkZWNsYXJhdGlvbnNcIik7XG4gIGNvbnN0IHJlc3VsdFN0cmluZyA9IEpTT04uc3RyaW5naWZ5KHJlc3VsdCwgdW5kZWZpbmVkLCBzcGFjZXIpO1xuICBpZiAoZGVidWdfbGV2ZWwgPj0gMikgY29uc29sZS5sb2coXCJbanNvbi10by1jb2RlXSBzdHJpbmdpZmllZCByZXN1bHRcIik7XG4gIGNvbnN0IHsgdGV4dDogcHJvY2Vzc2VkSlNPTiB9ID0gdGV4dG9wcy5ydW4oe1xuICAgIG9wczogW1wiZGVscHJldmNoYXJcIiwgXCJkZWxuZXh0Y2hhclwiXSxcbiAgICB0ZXh0OiByZXN1bHRTdHJpbmcsXG4gICAgdWlkOiBOdW1iZXIodWlkKVxuICB9KTtcbiAgaWYgKGRlYnVnX2xldmVsID49IDIpIGNvbnNvbGUubG9nKFwiW2pzb24tdG8tY29kZV0gcmFuIGZpbmFsIGVtYmVkZGVkIHRleHQgb3BlcmF0aW9uc1wiKTtcblxuICBvdXRjb2RlICs9IFwiXFxuXCI7XG4gIG91dGNvZGUgKz0gYCR7cHJlZml4fSA9ICR7cHJvY2Vzc2VkSlNPTn07YDtcblxuICByZXR1cm4geyBjb2RlOiBvdXRjb2RlIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHsgZW5jb2RlIH07XG4iLCJjb25zdCBpdGVyID0gKHsgaW5wdCwgZnVuYywgY2IsIHRoaXNBcmcgfSkgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IGxlbmd0aCA9IGlucHQubGVuZ3RoO1xuXG4gICAgLy8gc2hhbGxvdy1jb3B5IG9yaWdpbiBhcnJheVxuICAgIGNvbnN0IG9yaWdpbmFsQXJyYXkgPSBBcnJheS5mcm9tKGlucHQpO1xuXG4gICAgY29uc3QgZmlyc3RWYWx1ZSA9IG9yaWdpbmFsQXJyYXlbMF07XG4gICAgY29uc3QgbGFzdFZhbHVlID0gb3JpZ2luYWxBcnJheVtsZW5ndGggLSAxXTtcblxuICAgIHJldHVybiBpbnB0W2Z1bmNdKCh2YWx1ZSwgaSwgYXJyYXkpID0+IHtcbiAgICAgIHJldHVybiBjYih7XG4gICAgICAgIHZhbHVlLFxuICAgICAgICBjdXJyZW50VmFsdWU6IHZhbHVlLFxuICAgICAgICBlbGVtZW50OiB2YWx1ZSxcbiAgICAgICAgaXRlbTogdmFsdWUsXG4gICAgICAgIGl0OiB2YWx1ZSxcblxuICAgICAgICBmaXJzdFZhbHVlLFxuICAgICAgICBmaXJzdEVsZW1lbnQ6IGZpcnN0VmFsdWUsXG4gICAgICAgIGZpcnN0SXRlbTogZmlyc3RWYWx1ZSxcbiAgICAgICAgZmlyc3RJdDogZmlyc3RWYWx1ZSxcblxuICAgICAgICBsYXN0VmFsdWUsXG4gICAgICAgIGxhc3RFbGVtZW50OiBsYXN0VmFsdWUsXG4gICAgICAgIGxhc3RJdGVtOiBsYXN0VmFsdWUsXG4gICAgICAgIGxhc3RJdDogbGFzdFZhbHVlLFxuXG4gICAgICAgIGksXG4gICAgICAgIGluZGV4OiBpLFxuXG4gICAgICAgIGFycmF5LFxuXG4gICAgICAgIGdldCBwZXJjZW50KCkgeyByZXR1cm4gKGkgKyAxKSAvIGxlbmd0aDsgfSxcblxuICAgICAgICBnZXQgbGVuZ3RoKCkgeyByZXR1cm4gbGVuZ3RoOyB9LFxuXG4gICAgICAgIGdldCBwcmV2aW91cygpIHsgcmV0dXJuIG9yaWdpbmFsQXJyYXlbaSAtIDFdOyB9LFxuICAgICAgICBnZXQgcHJldigpIHsgcmV0dXJuIG9yaWdpbmFsQXJyYXlbaSAtIDFdOyB9LFxuXG4gICAgICAgIGdldCBuZXh0KCkgeyByZXR1cm4gb3JpZ2luYWxBcnJheVtpICsgMV07IH0sXG5cbiAgICAgICAgZ2V0IGJlZm9yZSgpIHsgcmV0dXJuIG9yaWdpbmFsQXJyYXkuc2xpY2UoMCwgaSk7IH0sXG4gICAgICAgIGdldCBhZnRlcigpIHsgcmV0dXJuIG9yaWdpbmFsQXJyYXkuc2xpY2UoaSArIDEpOyB9LFxuXG4gICAgICAgIGJyazogKG49MSkgPT4geyB0aHJvdyBgW2FkdmFycl0gYnJlYWtpbmcgJHtufWA7IH0sXG5cbiAgICAgICAgLy8gb3JkaW5hbCBudW1iZXJzXG4gICAgICAgIGZpcnN0OiBpID09PSAwLFxuICAgICAgICBzZWNvbmQ6IGkgPT09IDEsXG4gICAgICAgIHRoaXJkOiBpID09PSAyLFxuICAgICAgICBmb3VydGg6IGkgPT09IDMsXG4gICAgICAgIGZpZnRoOiBpID09PSA0LFxuICAgICAgICBzaXh0aDogaSA9PT0gNSxcbiAgICAgICAgc2V2ZW50aDogaSA9PT0gNixcbiAgICAgICAgZWlndGg6IGkgPT09IDcsXG4gICAgICAgIG5pbnRoOiBpID09PSA4LFxuICAgICAgICB0ZW50aDogaSA9PT0gOSxcblxuICAgICAgICBsYXN0OiBpID09PSBsZW5ndGggLSAxLFxuICAgICAgICBwZW51bHRpbWF0ZTogaSA9PT0gbGVuZ3RoIC0gMixcbiAgICAgICAgYW50ZXBlbnVsdGltYXRlOiBpID09PSBsZW5ndGggLSAzLFxuXG4gICAgICAgIG9kZDogaSAlIDIgPT09IDEsXG4gICAgICAgIGV2ZW46IGkgJSAyID09PSAwLFxuICAgICAgfSk7XG4gICAgfSwgdGhpc0FyZyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgbGV0IG1zZyA9IGVycm9yLnRvU3RyaW5nKCk7XG4gICAgaWYgKCFtc2cuaW5jbHVkZXMoXCJbYWR2YXJyXSBicmVha2luZyAxXCIpKSB7XG4gICAgICBpZiAobXNnLmluY2x1ZGVzKFwiW2FkdmFycl0gYnJlYWtpbmdcIikpIHtcbiAgICAgICAgY29uc3QgbiA9IHBhcnNlSW50KG1zZ1ttc2cubGVuZ3RoIC0gMV0pO1xuICAgICAgICBtc2cgPSBcIlthZHZhcnJdIGJyZWFraW5nIFwiICsgKG4gLSAxKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG1zZztcbiAgICB9XG4gIH1cbn07XG5cbmNvbnN0IGFkdmFyciA9IHt9O1xuW1wiZXZlcnlcIiwgXCJmaWx0ZXJcIiwgXCJmaW5kXCIsIFwiZmluZEluZGV4XCIsIFwiZmxhdE1hcFwiLCBcImZvckVhY2hcIiwgXCJtYXBcIiwgXCJzb21lXCJdLmZvckVhY2goa2V5ID0+IHtcbiAgYWR2YXJyW2tleV0gPSAoaW5wdCwgY2IsIHRoaXNBcmcpID0+IGl0ZXIoeyBpbnB0LCBmdW5jOiBrZXksIGNiLCB0aGlzQXJnIH0pO1xufSk7XG5cbmlmICh0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIpIG1vZHVsZS5leHBvcnRzID0gYWR2YXJyO1xuaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpIHdpbmRvdy5hZHZhcnIgPSBhZHZhcnI7XG5pZiAodHlwZW9mIHNlbGYgPT09IFwib2JqZWN0XCIpIHNlbGYuYWR2YXJyID0gYWR2YXJyO1xuIiwiY29uc3QgZGVjb25jYXQgPSAoc3RyLCBkZWJ1ZykgPT4ge1xuICBjb25zdCB0b2tlbnMgPSBbXTtcbiAgbGV0IGluU3RyaW5nID0gZmFsc2U7XG4gIGxldCBjdXJyZW50ID0gJyc7XG4gIGxldCBxdW90ZWNoYXIgPSBudWxsO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNoYXIgPSBzdHJbaV07XG4gICAgaWYgKGRlYnVnKSBjb25zb2xlLmxvZyhcImNoYXI6XCIsIGNoYXIpO1xuICAgIGlmIChjaGFyID09PSBcIitcIikge1xuICAgICAgaWYgKGluU3RyaW5nKSB7XG4gICAgICAgIGN1cnJlbnQgKz0gY2hhcjtcbiAgICAgIH0gZWxzZSBpZiAoY3VycmVudCAhPT0gJycpIHtcbiAgICAgICAgdG9rZW5zLnB1c2goY3VycmVudCk7XG4gICAgICAgIGN1cnJlbnQgPSBcIlwiO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2hhciA9PT0gYCdgIHx8IGNoYXIgPT09IGBcImAgfHwgY2hhciA9PT0gXCJgXCIpIHtcbiAgICAgIGN1cnJlbnQgKz0gY2hhcjtcbiAgICAgIGlmIChpblN0cmluZykge1xuICAgICAgICBpZiAoY2hhciA9PT0gcXVvdGVjaGFyICYmIHN0cltpLTFdICE9PSBcIlxcXFxcIikgaW5TdHJpbmcgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluU3RyaW5nID0gdHJ1ZTtcbiAgICAgICAgcXVvdGVjaGFyID0gY2hhcjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNoYXIgPT09IGAgYCkge1xuICAgICAgaWYgKGluU3RyaW5nKSBjdXJyZW50ICs9IGNoYXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnQgKz0gY2hhcjtcbiAgICB9XG4gIH1cbiAgaWYgKGN1cnJlbnQgIT09ICcnKSB0b2tlbnMucHVzaChjdXJyZW50KTtcbiAgcmV0dXJuIHRva2Vucztcbn1cblxuaWYgKHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIpIG1vZHVsZS5leHBvcnRzID0gZGVjb25jYXQ7XG5pZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikgd2luZG93LmRlY29uY2F0ID0gZGVjb25jYXQ7XG5pZiAodHlwZW9mIHNlbGYgPT09IFwib2JqZWN0XCIpIHNlbGYuZGVjb25jYXQgPSBkZWNvbmNhdDtcblxuIiwiY29uc3QgeyBmb3JFYWNoIH0gPSByZXF1aXJlKFwiYWR2YXJyXCIpO1xuXG5jb25zdCBtZXJnZSA9IHJlcXVpcmUoXCIuL21lcmdlLWNvdW50c1wiKTtcblxuY29uc3QgY291bnQgPSAob3B0aW9ucykgPT4ge1xuICBsZXQge1xuICAgIGRhdGEsXG4gICAgZGVidWdfbGV2ZWw9MCxcbiAgICBjb3VudF9udW1iZXJzPXRydWUsXG4gICAgY291bnRfc3RyaW5ncz10cnVlLFxuICAgIHNwbGl0X3N0cmluZ3Nfb249XCIgXCJcbiAgfSA9IG9wdGlvbnM7XG5cbiAgaWYgKGRlYnVnX2xldmVsID49IDEpIGNvbnNvbGUubG9nKFwiW2RlZXAtY291bnRlcl0gb3B0aW9uczpcIiwgb3B0aW9ucyk7XG5cbiAgaWYgKCEoJ2RhdGEnIGluIG9wdGlvbnMpKSB0aHJvdyBuZXcgRXJyb3IoXCJbZGVlcC1jb3VudGVyXSB5b3UgY2FsbGVkIGNvdW50IHdpdGhvdXQgYSBkYXRhIHByb3BlcnR5IHNldFwiKVxuXG4gIGNvbnN0IHJlc3VsdHMgPSB7XG4gICAgc3RyaW5nczoge30sXG4gICAgbnVtYmVyczoge30sXG4gICAgbnVsbDogMCxcbiAgICB1bmRlZmluZWQ6IDBcbiAgfTtcblxuICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgIGZvckVhY2goZGF0YSwgKHsgdmFsdWUgfSkgPT4ge1xuICAgICAgbWVyZ2Uoe1xuICAgICAgICBmcm9tOiBjb3VudCh7IC4uLm9wdGlvbnMsIGRhdGE6IHZhbHVlIH0pLFxuICAgICAgICBpbnRvOiByZXN1bHRzXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChkYXRhID09PSBudWxsKSB7XG4gICAgcmVzdWx0cy5udWxsKys7XG4gIH0gZWxzZSBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmVzdWx0cy51bmRlZmluZWQrKztcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJvYmplY3RcIikge1xuICAgIG1lcmdlKHtcbiAgICAgIGZyb206IGNvdW50KHsgLi4ub3B0aW9ucywgZGF0YTogT2JqZWN0LmtleXMoZGF0YSkgfSksXG4gICAgICBpbnRvOiByZXN1bHRzXG4gICAgfSk7XG4gICAgbWVyZ2Uoe1xuICAgICAgZnJvbTogY291bnQoeyAuLi5vcHRpb25zLCBkYXRhOiBPYmplY3QudmFsdWVzKGRhdGEpIH0pLFxuICAgICAgaW50bzogcmVzdWx0c1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgaWYgKGNvdW50X3N0cmluZ3MpIHtcbiAgICAgIGNvbnN0IHRva2VucyA9IGRhdGEuc3BsaXQoc3BsaXRfc3RyaW5nc19vbik7XG4gICAgICBmb3JFYWNoKHRva2VucywgKHsgdmFsdWU6IHRva2VuLCBsYXN0LCBmaXJzdCB9KSA9PiB7ICAgIFxuICAgICAgICBpZiAodG9rZW4gaW4gcmVzdWx0cy5zdHJpbmdzKSB7XG4gICAgICAgICAgcmVzdWx0cy5zdHJpbmdzW3Rva2VuXS5jb3VudCsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdHMuc3RyaW5nc1t0b2tlbl0gPSB7XG4gICAgICAgICAgICB2YWx1ZTogdG9rZW4sXG4gICAgICAgICAgICBjb3VudDogMSxcbiAgICAgICAgICAgIGZpcnN0OiAwLFxuICAgICAgICAgICAgbGFzdDogMFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpcnN0KSByZXN1bHRzLnN0cmluZ3NbdG9rZW5dLmZpcnN0KytcbiAgICAgICAgaWYgKGxhc3QpIHJlc3VsdHMuc3RyaW5nc1t0b2tlbl0ubGFzdCsrXG4gICAgICB9KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIGRhdGEgPT09IFwibnVtYmVyXCIpIHtcbiAgICBpZiAoY291bnRfbnVtYmVycykge1xuICAgICAgaWYgKGRhdGEgaW4gcmVzdWx0cy5udW1iZXJzKSB7XG4gICAgICAgIHJlc3VsdHMubnVtYmVyc1tkYXRhXS5jb3VudCsrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0cy5udW1iZXJzW2RhdGFdID0geyBjb3VudDogMSwgdmFsdWU6IGRhdGEgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdHM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvdW50O1xuXG4iLCJtb2R1bGUuZXhwb3J0cyA9ICh7IGZyb20sIGludG8gfSkgPT4ge1xuICBPYmplY3QuZW50cmllcyhmcm9tKS5mb3JFYWNoKChbdHlwZSwgY291bnRzXSkgPT4ge1xuICAgIGlmICh0eXBlIGluIGludG8pIHtcbiAgICAgIGlmICh0eXBlb2YgY291bnRzID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGludG9bdHlwZV0gKz0gY291bnRzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgT2JqZWN0LmVudHJpZXMoY291bnRzKS5mb3JFYWNoKChbdG9rZW4sIGluZm9dKSA9PiB7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coXCJpbnRvOlwiLCBpbnRvKTtcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcInR5cGU6XCIsIHR5cGUpO1xuICAgICAgICAgIGlmICh0b2tlbiBpbiBpbnRvW3R5cGVdKSB7XG4gICAgICAgICAgICAvLyBpdGVyYXRlIG92ZXIgdmFsdWVzIGlmIGl0J3MgYSBudW1iZXIgYWRkIGl0XG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyhpbmZvKS5mb3JFYWNoKChba2V5LCBjb3VudF0pID0+IHtcbiAgICAgICAgICAgICAgaWYgKGtleSAhPT0gXCJ2YWx1ZVwiKSB7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coe2tleSwgY291bnR9KTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5IGluIGludG9bdHlwZV1bdG9rZW5dKSB7XG4gICAgICAgICAgICAgICAgICBpbnRvW3R5cGVdW3Rva2VuXVtrZXldICs9IGNvdW50O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpbnRvW3R5cGVdW3Rva2VuXVtrZXldID0gY291bnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW50b1t0eXBlXVt0b2tlbl0gPSBpbmZvO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGludG9bdHlwZV0gPSBjb3VudHM7XG4gICAgfVxuICB9KTtcbn07XG4iLCJjb25zdCB7IGZvckVhY2gsIG1hcCB9ID0gcmVxdWlyZShcImFkdmFyclwiKTtcbmNvbnN0IHJlcGxhY2VLZXkgPSByZXF1aXJlKFwicmVwbGFjZS1rZXlcIik7XG5cbi8vIHV0aWxpdHkgZnVuY3Rpb25zXG5jb25zdCBpc0FyeSA9IChpdCkgPT4gQXJyYXkuaXNBcnJheShpdCk7XG5jb25zdCBpc051bCA9IChpdCkgPT4gaXQgPT09IG51bGw7XG5jb25zdCBpc09iaiA9IChpdCkgPT4gIUFycmF5LmlzQXJyYXkoaXQpICYmICFpc051bChpdCkgJiYgdHlwZW9mIGl0ID09PSBcIm9iamVjdFwiO1xuY29uc3QgaXNTdHIgPSAoaXQpID0+IHR5cGVvZiBpdCA9PT0gXCJzdHJpbmdcIjtcbmNvbnN0IGlzTnVtID0gKGl0KSA9PiB0eXBlb2YgaXQgPT09IFwibnVtYmVyXCI7XG5cbi8vIGRvaW5nIHNwbGl0IHN0cmluZ3Mgb24gLyg/PSApLyBzcGxpdHMgXCJhIGNvdyBqdW1wZWRcIiB0byBbICdhJywgJyBjb3cnLCAnIGp1bXBlZCcgXVxuZnVuY3Rpb24gd2Fsayh7XG4gIGNhbGxiYWNrLFxuICBkYXRhLFxuICBkZWJ1ZyA9IGZhbHNlLFxuICBwYXRoID0gW10sXG4gIHNwbGl0X3N0cmluZ3Nfb24gPSBudWxsLCAvLyBhbHRlcm5hdGl2ZSBpcyBcIiBcIiBpZiB5b3Ugd2FudCB0byBzcGxpdCBvbiB3b3Jkc1xuICBpbmNsdWRlX3NlcCA9IGZhbHNlLCAvLyBkZWZhdWx0cyB0byBpbmNsdWRpbmcgc2VwYXJhdG9yIGluIGJlZ2luZ2luZyBpZiBleGlzdHNcbiAgbWF4X3BhdGhfbGVuZ3RoOiBtID0gSW5maW5pdHksXG4gIHNwbGl0X2tleXMgPSB1bmRlZmluZWQsXG4gIHR5cGVzLFxufSkge1xuICAvLyBzYXZpbmcgYXJncyB0byBwYXNzIGRvd25cbiAgbGV0IGFyZ3MgPSBhcmd1bWVudHNbMF07XG5cbiAgaWYgKHNwbGl0X2tleXMgPT09IHVuZGVmaW5lZCkge1xuICAgIHNwbGl0X2tleXMgPSBzcGxpdF9zdHJpbmdzX29uICE9PSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAoZGVidWcpIGNvbnNvbGUubG9nKFwic3RhcnRpbmcgd2FsayB3aXRoIGFyZ3NcIiwgYXJncyk7XG4gIGNvbnN0IGhhc1BhdGggPSBpc0FyeShwYXRoKSAmJiBwYXRoLmxlbmd0aCA+IDA7XG4gIGNvbnN0IGlzQXJyYXlJdGVtID0gaGFzUGF0aCAmJiBpc051bShwYXRoWzBdKSAmJiBpc0FyeShwYXRoWzFdKTtcbiAgY29uc3QgaXNPYmpWYWx1ZSA9IGhhc1BhdGggJiYgaXNTdHIocGF0aFswXSkgJiYgaXNPYmoocGF0aFsxXSk7XG5cbiAgY29uc3Qgc3BsaXRfc3RyID0gKHN0cikgPT5cbiAgICBtYXAoc3RyLnNwbGl0KHNwbGl0X3N0cmluZ3Nfb24pLCAoeyBpdCwgZmlyc3QgfSkgPT4gKGluY2x1ZGVfc2VwICYmICFmaXJzdCA/IHNwbGl0X3N0cmluZ3Nfb24gOiBcIlwiKSArIGl0KTtcbiAgY29uc3Qgam9pbl9zdWJzID0gKHN1YnMpID0+IHN1YnMuam9pbihpbmNsdWRlX3NlcCA/IFwiXCIgOiBzcGxpdF9zdHJpbmdzX29uKTtcblxuICBpZiAoIWhhc1BhdGggJiYgaXNTdHIoZGF0YSkpIHRocm93IG5ldyBFcnJvcihcInlvdSBtdXN0IHBhc3MgaW4gYW4gb2JqZWN0IG9yIGFuIGFycmF5IHRvIHN0YXJ0XCIpO1xuXG4gIGNvbnN0IG1vZF9wYXJlbnQgPSAodmFsdWUpID0+IHtcbiAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHRocm93IG5ldyBFcnJvcihcIltkZWVwZXN0LXdhbGtdIHVuYWJsZSB0byBtb2RpZnkgdGhlIHN0YXJ0aW5nIGRhdGEgaW4gcGxhY2VcIik7XG4gICAgaWYgKHR5cGVvZiBwYXRoWzBdID09PSBcIm51bWJlclwiKSB7XG4gICAgICAvLyBwYXRoWzBdIGlzIGFuIGluZGV4IGluIGFuIGFycmF5XG4gICAgICBwYXRoWzFdW3BhdGhbMF1dID0gdmFsdWU7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcGF0aFswXSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgLy8gcGF0aFswXSBpcyBhIGtleSBpbiBhbiBvYmplY3RcbiAgICAgIHBhdGhbMV1bcGF0aFswXV0gPSB2YWx1ZTtcbiAgICB9XG4gIH07XG5cbiAgaWYgKGlzQXJ5KGRhdGEpKSB7XG4gICAgaWYgKCF0eXBlcyB8fCB0eXBlcy5pbmNsdWRlcyhcImFycmF5XCIpKSB7XG4gICAgICBjYWxsYmFjayh7XG4gICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgZGF0YSxcbiAgICAgICAgbW9kOiBtb2RfcGFyZW50LFxuICAgICAgfSk7XG4gICAgfVxuICAgIGRhdGEuZm9yRWFjaCgoaXRlbSwgaSkgPT4ge1xuICAgICAgaWYgKGlzU3RyKGl0ZW0pKSB7XG4gICAgICAgIGlmICghdHlwZXMgfHwgdHlwZXMuaW5jbHVkZXMoXCJhcnJheS1pdGVtLXN0cmluZ1wiKSkge1xuICAgICAgICAgIGNhbGxiYWNrKHtcbiAgICAgICAgICAgIHR5cGU6IFwiYXJyYXktaXRlbS1zdHJpbmdcIixcbiAgICAgICAgICAgIGRhdGE6IGl0ZW0sXG4gICAgICAgICAgICBtb2Q6IChuZXdfaXRlbSkgPT4gKGRhdGFbaV0gPSBuZXdfaXRlbSksXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNwbGl0X3N0cmluZ3Nfb24gJiYgKCF0eXBlcyB8fCB0eXBlcy5pbmNsdWRlcyhcImFycmF5LWl0ZW0tc3Vic3RyaW5nXCIpKSkge1xuICAgICAgICAgIGNvbnN0IHN1Ykl0ZW1zID0gc3BsaXRfc3RyKGl0ZW0pO1xuICAgICAgICAgIGZvckVhY2goc3ViSXRlbXMsICh7IGl0OiBzdWJJdGVtLCBpbmRleDogaWksIG5leHQsIHByZXYsIGZpcnN0OiBpc0ZpcnN0U3Vic3RyLCBsYXN0OiBpc0xhc3RTdWJzdHIgfSkgPT4ge1xuICAgICAgICAgICAgY2FsbGJhY2soe1xuICAgICAgICAgICAgICB0eXBlOiBcImFycmF5LWl0ZW0tc3Vic3RyaW5nXCIsXG4gICAgICAgICAgICAgIGRhdGE6IHN1Ykl0ZW0sXG4gICAgICAgICAgICAgIG1vZDogKG5ld1N1Ykl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICBzdWJJdGVtc1tpaV0gPSBuZXdTdWJJdGVtO1xuICAgICAgICAgICAgICAgIGRhdGFbaV0gPSBzdWJJdGVtcy5qb2luKGluY2x1ZGVfc2VwID8gXCJcIiA6IHNwbGl0X3N0cmluZ3Nfb24pO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBwYXRoOiBbaWksIGl0ZW0sIGRhdGEsIC4uLnBhdGhdLFxuICAgICAgICAgICAgICBuZXh0LFxuICAgICAgICAgICAgICBwcmV2LFxuICAgICAgICAgICAgICBmaXJzdDogaXNGaXJzdFN1YnN0cixcbiAgICAgICAgICAgICAgbGFzdDogaXNMYXN0U3Vic3RyLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhbGsoeyAuLi5hcmdzLCBkYXRhOiBpdGVtLCBwYXRoOiBbaSwgZGF0YSwgLi4ucGF0aF0uc2xpY2UoMCwgbSkgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoaXNPYmooZGF0YSkpIHtcbiAgICBpZiAoIXR5cGVzIHx8IHR5cGVzLmluY2x1ZGVzKFwib2JqZWN0XCIpKSB7XG4gICAgICBjYWxsYmFjayh7XG4gICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIG1vZDogbW9kX3BhcmVudCxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBPYmplY3Qua2V5cyhkYXRhKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGlmICghdHlwZXMgfHwgdHlwZXMuaW5jbHVkZXMoXCJvYmplY3Qta2V5LXN0cmluZ1wiKSkge1xuICAgICAgICBjYWxsYmFjayh7XG4gICAgICAgICAgdHlwZTogXCJvYmplY3Qta2V5LXN0cmluZ1wiLFxuICAgICAgICAgIGRhdGE6IGtleSxcbiAgICAgICAgICBtb2Q6IChuZXdfa2V5KSA9PiB7XG4gICAgICAgICAgICByZXBsYWNlS2V5KHsgb2JqOiBkYXRhLCBvbGRfa2V5OiBrZXksIG5ld19rZXkgfSk7XG4gICAgICAgICAgICBrZXkgPSBuZXdfa2V5O1xuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3BsaXRfa2V5cyAmJiBzcGxpdF9zdHJpbmdzX29uICYmICghdHlwZXMgfHwgdHlwZXMuaW5jbHVkZXMoXCJvYmplY3Qta2V5LXN1YnN0cmluZ1wiKSkpIHtcbiAgICAgICAgY29uc3Qgc3ViS2V5cyA9IHNwbGl0X3N0cihrZXkpO1xuICAgICAgICBmb3JFYWNoKHN1YktleXMsICh7IGl0OiBzdWJrZXksIGksIGZpcnN0LCBsYXN0LCBwcmV2LCBuZXh0IH0pID0+IHtcbiAgICAgICAgICBjb25zdCBtb2QgPSAobmV3U3ViS2V5KSA9PiB7XG4gICAgICAgICAgICBzdWJLZXlzW2ldID0gbmV3U3ViS2V5O1xuICAgICAgICAgICAgY29uc3QgbmV3X2tleSA9IGpvaW5fc3VicyhzdWJLZXlzKTtcbiAgICAgICAgICAgIHJlcGxhY2VLZXkoeyBvYmo6IGRhdGEsIG9sZF9rZXk6IGtleSwgbmV3X2tleSB9KTtcbiAgICAgICAgICAgIGtleSA9IG5ld19rZXk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBjYWxsYmFjayh7XG4gICAgICAgICAgICB0eXBlOiBcIm9iamVjdC1rZXktc3Vic3RyaW5nXCIsXG4gICAgICAgICAgICBkYXRhOiBzdWJrZXksXG4gICAgICAgICAgICBtb2QsXG4gICAgICAgICAgICBmaXJzdCxcbiAgICAgICAgICAgIGxhc3QsXG4gICAgICAgICAgICBwcmV2LFxuICAgICAgICAgICAgbmV4dCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBsZXQgdmFsdWUgPSBkYXRhW2tleV07XG4gICAgICBpZiAoZGVidWcpIGNvbnNvbGUubG9nKFwidmFsdWU6XCIsIHZhbHVlKTtcbiAgICAgIGlmIChpc1N0cih2YWx1ZSkpIHtcbiAgICAgICAgaWYgKCF0eXBlcyB8fCB0eXBlcy5pbmNsdWRlcyhcIm9iamVjdC12YWx1ZS1zdHJpbmdcIikpIHtcbiAgICAgICAgICBjYWxsYmFjayh7XG4gICAgICAgICAgICB0eXBlOiBcIm9iamVjdC12YWx1ZS1zdHJpbmdcIixcbiAgICAgICAgICAgIGRhdGE6IHZhbHVlLFxuICAgICAgICAgICAgbW9kOiAobmV3VmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgZGF0YVtrZXldID0gbmV3VmFsdWU7XG4gICAgICAgICAgICAgIHZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzcGxpdF9zdHJpbmdzX29uICYmICghdHlwZXMgfHwgdHlwZXMuaW5jbHVkZXMoXCJvYmplY3QtdmFsdWUtc3Vic3RyaW5nXCIpKSkge1xuICAgICAgICAgIGNvbnN0IHN1YlZhbHVlcyA9IHNwbGl0X3N0cih2YWx1ZSk7XG4gICAgICAgICAgZm9yRWFjaChzdWJWYWx1ZXMsICh7IGl0OiBzdWJ2YWx1ZSwgaSB9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtb2QgPSAobmV3U3ViVmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgc3ViVmFsdWVzW2ldID0gbmV3U3ViVmFsdWU7XG4gICAgICAgICAgICAgIGRhdGFba2V5XSA9IGpvaW5fc3VicyhzdWJWYWx1ZXMpO1xuICAgICAgICAgICAgICBzdWJ2YWx1ZSA9IG5ld1N1YlZhbHVlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhbGxiYWNrKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3QtdmFsdWUtc3Vic3RyaW5nXCIsXG4gICAgICAgICAgICAgIGRhdGE6IHN1YnZhbHVlLFxuICAgICAgICAgICAgICBtb2QsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gd2FsayB2YWx1ZVxuICAgICAgICB3YWxrKHsgLi4uYXJncywgZGF0YTogZGF0YVtrZXldLCBwYXRoOiBba2V5LCBkYXRhLCAuLi5wYXRoXS5zbGljZSgwLCBtKSB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBlbHNlIGlmIChkYXRhID09PSB1bmRlZmluZWQgfHwgZGF0YSA9PT0gbnVsbCB8fCB0eXBlb2YgZGF0YSA9PT0gXCJudW1iZXJcIikge1xuICAgIGlmICghaGFzUGF0aCkge1xuICAgICAgY29uc3QgZGF0YVR5cGUgPVxuICAgICAgICBkYXRhID09PSB1bmRlZmluZWQgPyBcInVuZGVmaW5lZFwiIDogZGF0YSA9PT0gbnVsbCA/IFwibnVsbFwiIDogdHlwZW9mIGRhdGEgPT09IFwibnVtYmVyXCIgPyBcIm51bWJlclwiIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKCF0eXBlcyB8fCB0eXBlcy5pbmNsdWRlcyhkYXRhVHlwZSkpIHtcbiAgICAgICAgY2FsbGJhY2soe1xuICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgdHlwZTogZGF0YVR5cGUsXG4gICAgICAgICAgbW9kOiAoKSA9PiB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmFibGUgdG8gbW9kXCIpO1xuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNBcnJheUl0ZW0gfHwgaXNPYmpWYWx1ZSkge1xuICAgICAgbGV0IHR5cGU7XG4gICAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB0eXBlID0gXCJhcnJheS1pdGVtLXVuZGVmaW5lZFwiO1xuICAgICAgZWxzZSBpZiAoZGF0YSA9PT0gbnVsbCkgdHlwZSA9IFwiYXJyYXktaXRlbS1udWxsXCI7XG4gICAgICBlbHNlIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJudW1iZXJcIikgdHlwZSA9IFwiYXJyYXktaXRlbS1udW1iZXJcIjtcbiAgICAgIGlmICghdHlwZXMgfHwgdHlwZXMuaW5jbHVkZXModHlwZSkpIHtcbiAgICAgICAgY2FsbGJhY2soe1xuICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICBtb2Q6IChuZXdfdmFsdWUpID0+IHtcbiAgICAgICAgICAgIHBhdGhbMV1bcGF0aFswXV0gPSBuZXdfdmFsdWU7XG4gICAgICAgICAgICB2YWx1ZSA9IG5ld192YWx1ZTtcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3YWxrO1xuIiwiY29uc3QgY291bnRfYXJyYXkgPSAoeyBhcnIsIGRlYnVnLCBuIH0pID0+IHtcbiAgICBjb25zdCBjb3VudHMgPSB7fTtcbiAgICBpZiAoZGVidWcpIGNvbnNvbGUubG9nKFwiYXJyOlwiLCBhcnIpO1xuICAgIGZvciAobGV0IGkgPSBuOyBpIDw9IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBuZ3JhbSA9IGFyci5zbGljZShpIC0gbiwgaSk7XG4gICAgICAgIGlmIChkZWJ1ZykgY29uc29sZS5sb2coXCJuZ3JhbTpcIiwgbmdyYW0pO1xuICAgICAgICBpZiAoY291bnRzLmhhc093blByb3BlcnR5KG5ncmFtKSkgY291bnRzW25ncmFtXS5jb3VudCsrO1xuICAgICAgICBlbHNlIGNvdW50c1tuZ3JhbV0gPSB7IG9yaWdpbmFsOiBuZ3JhbSwgY291bnQ6IDEgfTtcbiAgICB9XG4gICAgaWYgKGRlYnVnKSBjb25zb2xlLmxvZyhcImNvdW50czpcIiwgY291bnRzKTtcbiAgICBjb25zdCBzb3J0ZWQgPSBPYmplY3QuZW50cmllcyhjb3VudHMpLnNvcnQoKGEsIGIpID0+IE1hdGguc2lnbihiWzFdLmNvdW50IC0gYVsxXS5jb3VudCkpO1xuICAgIGlmIChkZWJ1ZykgY29uc29sZS5sb2coXCJzb3J0ZWQ6XCIsIHNvcnRlZCk7XG4gICAgY29uc3QgcmVzdWx0cyA9IHNvcnRlZC5tYXAoaXQgPT4gW2l0WzFdLm9yaWdpbmFsLCBpdFsxXS5jb3VudF0pO1xuICAgIGlmIChkZWJ1ZykgY29uc29sZS5sb2coXCJyZXN1bHRzOlwiLCByZXN1bHRzKTtcbiAgICByZXR1cm4gcmVzdWx0cztcbn1cblxuY29uc3QgY291bnRfdGV4dCA9ICh7IHRleHQsIGRlYnVnLCBuIH0pID0+IHtcbiAgICBjb25zdCBjb3VudHMgPSB7fTtcbiAgICBpZiAoZGVidWcpIGNvbnNvbGUubG9nKFwidGV4dDogXCIgKyB0ZXh0LnN1YnN0cmluZygwLCAxMDApLnRyaW0oKSArIFwiLi4uXCIpO1xuICAgIGZvciAobGV0IGkgPSBuOyBpIDw9IHRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgbmdyYW0gPSB0ZXh0LnN1YnN0cmluZyhpIC0gbiwgaSk7XG4gICAgICAgIGlmIChkZWJ1ZykgY29uc29sZS5sb2coXCJuZ3JhbTpcIiwgbmdyYW0pO1xuICAgICAgICBpZiAoY291bnRzLmhhc093blByb3BlcnR5KG5ncmFtKSkgY291bnRzW25ncmFtXSsrO1xuICAgICAgICBlbHNlIGNvdW50c1tuZ3JhbV0gPSAxO1xuICAgIH1cbiAgICBpZiAoZGVidWcpIGNvbnNvbGUubG9nKFwiY291bnRzOlwiLCBjb3VudHMpO1xuICAgIGNvbnN0IHNvcnRlZCA9IE9iamVjdC5lbnRyaWVzKGNvdW50cykuc29ydCgoYSwgYikgPT4gTWF0aC5zaWduKGJbMV0gLSBhWzFdKSk7XG4gICAgaWYgKGRlYnVnKSBjb25zb2xlLmxvZyhcInNvcnRlZDpcIiwgc29ydGVkKTtcbiAgICByZXR1cm4gc29ydGVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9ICh7IGRhdGEsIGRlYnVnLCBuIH0pID0+IHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICByZXR1cm4gY291bnRfYXJyYXkoeyBhcnI6IGRhdGEsIGRlYnVnLCBuIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjb3VudF90ZXh0KHsgdGV4dDogZGF0YSwgZGVidWcsIG4gfSk7XG4gICAgfVxufTtcbiIsImNvbnN0IHJlcGxhY2VLZXkgPSAoeyBvYmosIG9sZF9rZXksIG5ld19rZXkgfSkgPT4ge1xuICBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogIT09IFwib2JqZWN0XCIpIHRocm93IG5ldyBFcnJvcihgW3JlcGxhY2Uta2V5XSBvYmogaXMgbm90IGFuIG9iamVjdFwiYCk7XG4gIGlmICghKG9sZF9rZXkgaW4gb2JqKSkgdGhyb3cgbmV3IEVycm9yKGBbcmVwbGFjZS1rZXldIFwiJHtvbGRfa2V5fVwiIGlzIG5vdCBhIGtleSBvZiBvYmpgKTtcbiAgb2JqW25ld19rZXldID0gb2JqW29sZF9rZXldO1xuICBkZWxldGUgb2JqW29sZF9rZXldO1xuICByZXR1cm4gb2JqO1xufVxuXG5pZiAodHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIikgbW9kdWxlLmV4cG9ydHMgPSByZXBsYWNlS2V5O1xuaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpIHdpbmRvdy5yZXBsYWNlS2V5ID0gcmVwbGFjZUtleTtcbmlmICh0eXBlb2Ygc2VsZiA9PT0gXCJvYmplY3RcIikgc2VsZi5yZXBsYWNlS2V5ID0gcmVwbGFjZUtleTtcbiIsImNvbnN0IHNlcGFybyA9IChzdHIsIHNlcD0nICcsIHsgYXR0YWNoU2VwPWZhbHNlLCBrZWVwU2VwPWZhbHNlIH0gPSB7IGF0dGFjaFNlcDogZmFsc2UsIGtlZXBTZXA6IGZhbHNlIH0pID0+IHtcbiAgaWYgKHR5cGVvZiBzZXAgPT09ICdzdHJpbmcnKSBzZXAgPSBuZXcgU2V0KFtzZXBdKTtcbiAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShzZXApKSBzZXAgPSBuZXcgU2V0KHNlcCk7XG5cbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGxldCBjdXJyZW50ID0gJyc7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2hhciA9IHN0cltpXTtcbiAgICBpZiAoc2VwLmhhcyhjaGFyKSkge1xuICAgICAgcmVzdWx0LnB1c2goY3VycmVudCk7XG4gICAgICBpZiAoYXR0YWNoU2VwKSB7XG4gICAgICAgIGN1cnJlbnQgPSBjaGFyO1xuICAgICAgfSBlbHNlIGlmIChrZWVwU2VwKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGNoYXIpO1xuICAgICAgICBjdXJyZW50ID0gJyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyZW50ID0gJyc7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnQgKz0gY2hhcjtcbiAgICB9XG4gIH1cbiAgaWYgKGN1cnJlbnQubGVuZ3RoID4gMCkgcmVzdWx0LnB1c2goY3VycmVudCk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JykgbW9kdWxlLmV4cG9ydHMgPSBzZXBhcm87XG5pZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcpIHdpbmRvdy5zZXBhcm8gPSBzZXBhcm87XG5pZiAodHlwZW9mIHNlbGYgPT09ICdvYmplY3QnKSBzZWxmLnNlcGFybyA9IHNlcGFybztcbiIsIid1c2Ugc3RyaWN0JztcblxuKGZ1bmN0aW9uIChnbG9iYWwpIHtcblxuICAgIC8vIG1pbmltYWwgc3ltYm9sIHBvbHlmaWxsIGZvciBJRTExIGFuZCBvdGhlcnNcbiAgICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgU3ltYm9sID0gZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICBTeW1ib2wubm9uTmF0aXZlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBjb25zdCBTVEFURV9QTEFJTlRFWFQgPSBTeW1ib2woJ3BsYWludGV4dCcpO1xuICAgIGNvbnN0IFNUQVRFX0hUTUwgICAgICA9IFN5bWJvbCgnaHRtbCcpO1xuICAgIGNvbnN0IFNUQVRFX0NPTU1FTlQgICA9IFN5bWJvbCgnY29tbWVudCcpO1xuXG4gICAgY29uc3QgQUxMT1dFRF9UQUdTX1JFR0VYICA9IC88KFxcdyopPi9nO1xuICAgIGNvbnN0IE5PUk1BTElaRV9UQUdfUkVHRVggPSAvPFxcLz8oW15cXHNcXC8+XSspLztcblxuICAgIGZ1bmN0aW9uIHN0cmlwdGFncyhodG1sLCBhbGxvd2FibGVfdGFncywgdGFnX3JlcGxhY2VtZW50KSB7XG4gICAgICAgIGh0bWwgICAgICAgICAgICA9IGh0bWwgfHwgJyc7XG4gICAgICAgIGFsbG93YWJsZV90YWdzICA9IGFsbG93YWJsZV90YWdzIHx8IFtdO1xuICAgICAgICB0YWdfcmVwbGFjZW1lbnQgPSB0YWdfcmVwbGFjZW1lbnQgfHwgJyc7XG5cbiAgICAgICAgbGV0IGNvbnRleHQgPSBpbml0X2NvbnRleHQoYWxsb3dhYmxlX3RhZ3MsIHRhZ19yZXBsYWNlbWVudCk7XG5cbiAgICAgICAgcmV0dXJuIHN0cmlwdGFnc19pbnRlcm5hbChodG1sLCBjb250ZXh0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbml0X3N0cmlwdGFnc19zdHJlYW0oYWxsb3dhYmxlX3RhZ3MsIHRhZ19yZXBsYWNlbWVudCkge1xuICAgICAgICBhbGxvd2FibGVfdGFncyAgPSBhbGxvd2FibGVfdGFncyB8fCBbXTtcbiAgICAgICAgdGFnX3JlcGxhY2VtZW50ID0gdGFnX3JlcGxhY2VtZW50IHx8ICcnO1xuXG4gICAgICAgIGxldCBjb250ZXh0ID0gaW5pdF9jb250ZXh0KGFsbG93YWJsZV90YWdzLCB0YWdfcmVwbGFjZW1lbnQpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBzdHJpcHRhZ3Nfc3RyZWFtKGh0bWwpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJpcHRhZ3NfaW50ZXJuYWwoaHRtbCB8fCAnJywgY29udGV4dCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgc3RyaXB0YWdzLmluaXRfc3RyZWFtaW5nX21vZGUgPSBpbml0X3N0cmlwdGFnc19zdHJlYW07XG5cbiAgICBmdW5jdGlvbiBpbml0X2NvbnRleHQoYWxsb3dhYmxlX3RhZ3MsIHRhZ19yZXBsYWNlbWVudCkge1xuICAgICAgICBhbGxvd2FibGVfdGFncyA9IHBhcnNlX2FsbG93YWJsZV90YWdzKGFsbG93YWJsZV90YWdzKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWxsb3dhYmxlX3RhZ3MgOiBhbGxvd2FibGVfdGFncyxcbiAgICAgICAgICAgIHRhZ19yZXBsYWNlbWVudDogdGFnX3JlcGxhY2VtZW50LFxuXG4gICAgICAgICAgICBzdGF0ZSAgICAgICAgIDogU1RBVEVfUExBSU5URVhULFxuICAgICAgICAgICAgdGFnX2J1ZmZlciAgICA6ICcnLFxuICAgICAgICAgICAgZGVwdGggICAgICAgICA6IDAsXG4gICAgICAgICAgICBpbl9xdW90ZV9jaGFyIDogJydcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdHJpcHRhZ3NfaW50ZXJuYWwoaHRtbCwgY29udGV4dCkge1xuICAgICAgICBpZiAodHlwZW9mIGh0bWwgIT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIidodG1sJyBwYXJhbWV0ZXIgbXVzdCBiZSBhIHN0cmluZ1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBhbGxvd2FibGVfdGFncyAgPSBjb250ZXh0LmFsbG93YWJsZV90YWdzO1xuICAgICAgICBsZXQgdGFnX3JlcGxhY2VtZW50ID0gY29udGV4dC50YWdfcmVwbGFjZW1lbnQ7XG5cbiAgICAgICAgbGV0IHN0YXRlICAgICAgICAgPSBjb250ZXh0LnN0YXRlO1xuICAgICAgICBsZXQgdGFnX2J1ZmZlciAgICA9IGNvbnRleHQudGFnX2J1ZmZlcjtcbiAgICAgICAgbGV0IGRlcHRoICAgICAgICAgPSBjb250ZXh0LmRlcHRoO1xuICAgICAgICBsZXQgaW5fcXVvdGVfY2hhciA9IGNvbnRleHQuaW5fcXVvdGVfY2hhcjtcbiAgICAgICAgbGV0IG91dHB1dCAgICAgICAgPSAnJztcblxuICAgICAgICBmb3IgKGxldCBpZHggPSAwLCBsZW5ndGggPSBodG1sLmxlbmd0aDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAgICAgbGV0IGNoYXIgPSBodG1sW2lkeF07XG5cbiAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gU1RBVEVfUExBSU5URVhUKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJzwnOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgICAgICAgPSBTVEFURV9IVE1MO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFnX2J1ZmZlciArPSBjaGFyO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dCArPSBjaGFyO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlbHNlIGlmIChzdGF0ZSA9PT0gU1RBVEVfSFRNTCkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZSAnPCcgaWYgaW5zaWRlIGEgcXVvdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbl9xdW90ZV9jaGFyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlJ3JlIHNlZWluZyBhIG5lc3RlZCAnPCdcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcHRoKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICc+JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZSAnPicgaWYgaW5zaWRlIGEgcXVvdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbl9xdW90ZV9jaGFyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNvbWV0aGluZyBsaWtlIHRoaXMgaXMgaGFwcGVuaW5nOiAnPDw+PidcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZXB0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlcHRoLS07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBjbG9zaW5nIHRoZSB0YWcgaW4gdGFnX2J1ZmZlclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5fcXVvdGVfY2hhciA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgICAgICAgICA9IFNUQVRFX1BMQUlOVEVYVDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZ19idWZmZXIgICArPSAnPic7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbGxvd2FibGVfdGFncy5oYXMobm9ybWFsaXplX3RhZyh0YWdfYnVmZmVyKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQgKz0gdGFnX2J1ZmZlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0ICs9IHRhZ19yZXBsYWNlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdGFnX2J1ZmZlciA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnXCInOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdcXCcnOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2F0Y2ggYm90aCBzaW5nbGUgYW5kIGRvdWJsZSBxdW90ZXNcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXIgPT09IGluX3F1b3RlX2NoYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbl9xdW90ZV9jaGFyID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluX3F1b3RlX2NoYXIgPSBpbl9xdW90ZV9jaGFyIHx8IGNoYXI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZ19idWZmZXIgKz0gY2hhcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhZ19idWZmZXIgPT09ICc8IS0nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBTVEFURV9DT01NRU5UO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWdfYnVmZmVyICs9IGNoYXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICcgJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnXFxuJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YWdfYnVmZmVyID09PSAnPCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSAgICAgID0gU1RBVEVfUExBSU5URVhUO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dCAgICArPSAnPCAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZ19idWZmZXIgPSAnJztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWdfYnVmZmVyICs9IGNoYXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgdGFnX2J1ZmZlciArPSBjaGFyO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlbHNlIGlmIChzdGF0ZSA9PT0gU1RBVEVfQ09NTUVOVCkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICc+JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YWdfYnVmZmVyLnNsaWNlKC0yKSA9PSAnLS0nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2xvc2UgdGhlIGNvbW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IFNUQVRFX1BMQUlOVEVYVDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdGFnX2J1ZmZlciA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZ19idWZmZXIgKz0gY2hhcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNhdmUgdGhlIGNvbnRleHQgZm9yIGZ1dHVyZSBpdGVyYXRpb25zXG4gICAgICAgIGNvbnRleHQuc3RhdGUgICAgICAgICA9IHN0YXRlO1xuICAgICAgICBjb250ZXh0LnRhZ19idWZmZXIgICAgPSB0YWdfYnVmZmVyO1xuICAgICAgICBjb250ZXh0LmRlcHRoICAgICAgICAgPSBkZXB0aDtcbiAgICAgICAgY29udGV4dC5pbl9xdW90ZV9jaGFyID0gaW5fcXVvdGVfY2hhcjtcblxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlX2FsbG93YWJsZV90YWdzKGFsbG93YWJsZV90YWdzKSB7XG4gICAgICAgIGxldCB0YWdfc2V0ID0gbmV3IFNldCgpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgYWxsb3dhYmxlX3RhZ3MgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBsZXQgbWF0Y2g7XG5cbiAgICAgICAgICAgIHdoaWxlICgobWF0Y2ggPSBBTExPV0VEX1RBR1NfUkVHRVguZXhlYyhhbGxvd2FibGVfdGFncykpKSB7XG4gICAgICAgICAgICAgICAgdGFnX3NldC5hZGQobWF0Y2hbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZWxzZSBpZiAoIVN5bWJvbC5ub25OYXRpdmUgJiZcbiAgICAgICAgICAgICAgICAgdHlwZW9mIGFsbG93YWJsZV90YWdzW1N5bWJvbC5pdGVyYXRvcl0gPT09ICdmdW5jdGlvbicpIHtcblxuICAgICAgICAgICAgdGFnX3NldCA9IG5ldyBTZXQoYWxsb3dhYmxlX3RhZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGFsbG93YWJsZV90YWdzLmZvckVhY2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIElFMTEgY29tcGF0aWJsZVxuICAgICAgICAgICAgYWxsb3dhYmxlX3RhZ3MuZm9yRWFjaCh0YWdfc2V0LmFkZCwgdGFnX3NldCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGFnX3NldDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVfdGFnKHRhZ19idWZmZXIpIHtcbiAgICAgICAgbGV0IG1hdGNoID0gTk9STUFMSVpFX1RBR19SRUdFWC5leGVjKHRhZ19idWZmZXIpO1xuXG4gICAgICAgIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdLnRvTG93ZXJDYXNlKCkgOiBudWxsO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgLy8gQU1EXG4gICAgICAgIGRlZmluZShmdW5jdGlvbiBtb2R1bGVfZmFjdG9yeSgpIHsgcmV0dXJuIHN0cmlwdGFnczsgfSk7XG4gICAgfVxuXG4gICAgZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgICAgLy8gTm9kZVxuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IHN0cmlwdGFncztcbiAgICB9XG5cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gQnJvd3NlclxuICAgICAgICBnbG9iYWwuc3RyaXB0YWdzID0gc3RyaXB0YWdzO1xuICAgIH1cbn0odGhpcykpO1xuIiwiZnVuY3Rpb24gVGFnKHsgbmFtZSwgdWlkIH0pIHtcbiAgcmV0dXJuIGA8JHtuYW1lfSR7dWlkID8gXCItXCIgKyB1aWQgOiBcIlwifT5gO1xufVxuXG5mdW5jdGlvbiBydW4oeyBkZWJ1Zywgb3BzLCB0ZXh0LCB1aWQgfSkge1xuICBpZiAoIXRleHQpIHRocm93IG5ldyBFcnJvcihcIlt0ZXh0b3BzXSBjYW4ndCBydW4gd2l0aG91dCB0ZXh0ISAgUGxlYXNlIGNhbGwgbGlrZSBydW4oeyB0ZXh0IH0pXCIpO1xuICBpZiAoIVtcIm51bWJlclwiLCBcInVuZGVmaW5lZFwiXS5pbmNsdWRlcyh0eXBlb2YgdWlkKSkgdGhyb3cgbmV3IEVycm9yKGBbdGV4dG9wc10gZm9yIHNlY3VyaXR5IHJlYXNvbnMsIHVpZCBtdXN0IGJlIGEgbnVtYmVyIG9yIHVuZGVmaW5lZC4gIFlvdSBwYXNzZWQgaW4gXCIke3R5cGVvZiB1aWR9XCJgKTtcbiAgaWYgKHR5cGVvZiB1aWQgPT09IFwibnVtYmVyXCIgJiYgdWlkLnRvU3RyaW5nKCkuaW5jbHVkZXMoXCIuXCIpKSB0aHJvdyBuZXcgRXJyb3IoXCJbdGV4dG9wc10gZm9yIHNlY3VyaXR5IHJlYXNvbnMsIHVpZCBtdXN0IGJlIGFuIGludGVnZXJcIik7XG4gIG9wcyA/Pz0gW1wiZGVscHJldlwiLCBcImRlbHByZXZjaGFyXCIsIFwiZGVsbmV4dFwiLCBcImRlbG5leHRjaGFyXCJdO1xuXG4gIGNvbnN0IGFueWNoYXIgPSBcIi5cIjtcbiAgY29uc3Qgb3AycmUgPSB7XG4gICAgZGVscHJldjogYW55Y2hhciArIFwiK1wiICsgVGFnKHsgbmFtZTogXCJkZWxwcmV2XCIsIHVpZCB9KSxcbiAgICBkZWxuZXh0OiBUYWcoeyBuYW1lOiBcImRlbG5leHRcIiwgdWlkIH0pICsgYW55Y2hhciArIFwiK1wiLFxuICAgIGRlbHByZXZjaGFyOiBhbnljaGFyICsgVGFnKHsgbmFtZTogXCJkZWxwcmV2Y2hhclwiLCB1aWQgfSksXG4gICAgZGVsbmV4dGNoYXI6IFRhZyh7IG5hbWU6IFwiZGVsbmV4dGNoYXJcIiwgdWlkIH0pICsgYW55Y2hhclxuICB9O1xuXG4gIGNvbnN0IHJlc3RyID1cbiAgICBcIihcIiArXG4gICAgb3BzXG4gICAgICAubWFwKG9wID0+IG9wMnJlW29wXSlcbiAgICAgIC5maWx0ZXIoQm9vbGVhbilcbiAgICAgIC5qb2luKFwifFwiKSArXG4gICAgXCIpXCI7XG5cbiAgaWYgKGRlYnVnKSBjb25zb2xlLmxvZyhgW3RleHRvcHNdIHJlc3RyOiBcIiR7cmVzdHJ9XCJgKTtcbiAgY29uc3QgcmUgPSBuZXcgUmVnRXhwKHJlc3RyLCBcImdcIik7XG4gIHRleHQgPSB0ZXh0LnJlcGxhY2UocmUsIFwiXCIpO1xuXG4gIHJldHVybiB7XG4gICAgdGV4dFxuICB9O1xufVxuXG5pZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiKSBkZWZpbmUoKCkgPT4gKHsgcnVuIH0pKTtcbmlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiKSBtb2R1bGUuZXhwb3J0cyA9IHsgcnVuIH07XG5pZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikgd2luZG93LnRleHRvcHMgPSB7IHJ1biB9O1xuaWYgKHR5cGVvZiBzZWxmID09PSBcIm9iamVjdFwiKSBzZWxmLnRleHRvcHMgPSB7IHJ1biB9O1xuIiwiY29uc3QgYWxwaGFiZXRfbG93ZXIgPSBcImFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6XCI7XG5jb25zdCBhbHBoYWJldF91cHBlciA9IGFscGhhYmV0X2xvd2VyLnRvVXBwZXJDYXNlKCk7XG5cbmNvbnN0IERFRkFVTFRfQ0hBUlMgPSBBcnJheS5mcm9tKGFscGhhYmV0X3VwcGVyICsgYWxwaGFiZXRfbG93ZXIpO1xuXG5jb25zdCBERUZBVUxUX0xBTkcgPSBcIkpTXCI7XG5cbmNvbnN0IERFRkFVTFRfTUFYX0NPVU5UID0gMWU2O1xuXG5jb25zdCBSRVNFUlZFRF9XT1JEUyA9IHtcbiAgLy8gcHJldHRpZXItaWdub3JlXG4gIEpTOiBbXG4gICAgXCJhYnN0cmFjdFwiLCBcImFsZXJ0XCIsIFwiYWxsXCIsIFwiYW5jaG9yXCIsIFwiYW5jaG9yc1wiLCBcImFyZWFcIiwgXCJhcmd1bWVudHNcIiwgXCJhc3NpZ25cIiwgXCJBcnJheVwiLCBcImF3YWl0XCIsXG4gICAgXCJib29sZWFuXCIsIFwiYmx1clwiLCBcImJyZWFrXCIsIFwiYnV0dG9uXCIsIFwiYnl0ZVwiLFxuICAgIFwiY2FzZVwiLCBcImNhdGNoXCIsIFwiY2hhclwiLCBcImNoZWNrYm94XCIsIFwiY2xhc3NcIiwgXCJjbGVhckludGVydmFsXCIsIFwiY2xlYXJUaW1lb3V0XCIsIFwiY2xpZW50SW5mb3JtYXRpb25cIiwgXCJjbG9zZVwiLCBcImNsb3NlZFwiLCBcImNvbmZpcm1cIiwgXCJjb25zdFwiLCBcImNvbnN0cnVjdG9yXCIsIFwiY29udGludWVcIiwgXCJjcnlwdG9cIixcbiAgICBcIkRhdGVcIiwgXCJkZWJ1Z2dlclwiLCBcImRlY29kZVVSSVwiLCBcImRlY29kZVVSSUNvbXBvbmVudFwiLCBcImRlZmF1bHRcIiwgXCJkZWZhdWx0U3RhdHVzXCIsIFwiZGVsZXRlXCIsIFwiZG9cIiwgXCJkb2N1bWVudFwiLCBcImRvdWJsZVwiLFxuICAgIFwiZWxlbWVudFwiLCBcImVsZW1lbnRzXCIsIFwiZWxzZVwiLCBcImVtYmVkXCIsIFwiZW1iZWRzXCIsIFwiZW5jb2RlVVJJXCIsIFwiZW5jb2RlVVJJQ29tcG9uZW50XCIsIFwiZW51bVwiLCBcImVzY2FwZVwiLCBcImV2YWxcIiwgXCJldmVudFwiLCBcImV4cG9ydFwiLCBcImV4dGVuZHNcIixcbiAgICBcImZhbHNlXCIsIFwiZmlsZVVwbG9hZFwiLCBcImZpbmFsXCIsIFwiZmluYWxseVwiLCBcImZsb2F0XCIsIFwiZm9jdXNcIiwgXCJmb3JcIiwgXCJmb3JtXCIsIFwiZm9ybXNcIiwgXCJmcmFtZVwiLCBcImZyYW1lUmF0ZVwiLCBcImZyYW1lc1wiLCBcImZ1bmN0aW9uXCIsXG4gICAgXCJnZXRDbGFzc1wiLCBcImdvdG9cIixcbiAgICBcImhhc093blByb3BlcnR5XCIsIFwiaGlkZGVuXCIsIFwiaGlzdG9yeVwiLFxuICAgIFwiaWZcIiwgXCJpbWFnZVwiLCBcImltYWdlc1wiLCBcImltcGxlbWVudHNcIiwgXCJpbXBvcnRcIiwgXCJpblwiLCBcIkluZmluaXR5XCIsIFwiaW5uZXJIZWlnaHRcIiwgXCJpbm5lcldpZHRoXCIsIFwiaW5zdGFuY2VvZlwiLCBcImludFwiLCBcImludGVyZmFjZVwiLCBcImlzRmluaXRlXCIsIFwiaXNOYU5cIiwgXCJpc1Byb3RvdHlwZU9mXCIsXG4gICAgXCJqYXZhXCIsIFwiamF2YUNsYXNzXCIsIFwiSmF2YUFycmF5XCIsIFwiSmF2YU9iamVjdFwiLCBcIkphdmFQYWNrYWdlXCIsXG4gICAgXCJsYXllclwiLCBcImxheWVyc1wiLCBcImxlbmd0aFwiLCBcImxldFwiLCBcImxpbmtcIiwgXCJsb2NhdGlvblwiLCBcImxvbmdcIixcbiAgICBcIk1hdGhcIiwgXCJtaW1lVHlwZXNcIiwgXCJtb2R1bGVcIixcbiAgICBcIm5hbWVcIiwgXCJOYU5cIiwgXCJuYXRpdmVcIiwgXCJuYXZpZ2F0ZVwiLCBcIm5hdmlnYXRvclwiLCBcIm5ld1wiLCBcIm51bGxcIiwgXCJOdW1iZXJcIixcbiAgICBcIm9mZnNjcmVlbkJ1ZmZlcmluZ1wiLCBcIk9iamVjdFwiLCBcIm9wZW5cIiwgXCJvcGVuZXJcIiwgXCJvcHRpb25cIiwgXCJvdXRlckhlaWdodFwiLCBcIm91dGVyV2lkdGhcIixcbiAgICBcInBhY2thZ2VcIiwgXCJwYWNrYWdlc1wiLCBcInBhZ2VYT2Zmc2V0XCIsIFwicGFnZVlPZmZzZXRcIiwgXCJwYXJlbnRcIiwgXCJwYXJzZUZsb2F0XCIsIFwicGFyc2VJbnRcIiwgXCJwYXNzd29yZFwiLCBcInBrY3MxMVwiLCBcInBsdWdpblwiLCBcInByaXZhdGVcIiwgXCJwcm9tcHRcIiwgXCJwcm9wZXJ0eUlzRW51bVwiLCBcInByb3RlY3RlZFwiLCBcInByb3RvdHlwZVwiLCBcInB1YmxpY1wiLFxuICAgIFwicmFkaW9cIiwgXCJyZXNldFwiLCBcInJldHVyblwiLFxuICAgIFwic2NyZWVuWFwiLCBcInNjcmVlbllcIiwgXCJzY3JvbGxcIiwgXCJzZWN1cmVcIiwgXCJzZWxlY3RcIiwgXCJzZWxmXCIsIFwic2V0SW50ZXJ2YWxcIiwgXCJzZXRUaW1lb3V0XCIsIFwic2hvcnRcIiwgXCJzdGF0aWNcIiwgXCJzdGF0dXNcIiwgXCJTdHJpbmdcIiwgXCJzdWJtaXRcIiwgXCJzdXBlclwiLCBcInN3aXRjaFwiLCBcInN5bmNocm9uaXplZFwiLFxuICAgIFwidGV4dFwiLCBcInRleHRhcmVhXCIsIFwidGhpc1wiLCBcInRocm93XCIsIFwidGhyb3dzXCIsIFwidG9wXCIsIFwidG9TdHJpbmdcIiwgXCJ0cmFuc2llbnRcIiwgXCJ0cnVlXCIsIFwidHJ5XCIsIFwidHlwZW9mXCIsXG4gICAgXCJ1bmRlZmluZWRcIiwgXCJ1bmVzY2FwZVwiLCBcInVudGFpbnRcIixcbiAgICBcInZhbHVlT2ZcIiwgXCJ2YXJcIiwgXCJ2b2lkXCIsIFwidm9sYXRpbGVcIixcbiAgICBcIndoaWxlXCIsIFwid2l0aFwiLCBcIndpbmRvd1wiLFxuICAgIFwieWllbGRcIlxuICBdLFxufTtcblxuZnVuY3Rpb24qIGdlblZhck5hbWVzKFxuICB7XG4gICAgY2hhcnMgPSBERUZBVUxUX0NIQVJTLFxuICAgIGRlYnVnID0gZmFsc2UsXG4gICAgbGFuZ3VhZ2UgPSBERUZBVUxUX0xBTkcsXG4gICAgbWF4X2NvdW50ID0gREVGQVVMVF9NQVhfQ09VTlQsXG4gIH0gPSB7XG4gICAgY2hhcnM6IERFRkFVTFRfQ0hBUlMsXG4gICAgZGVidWc6IGZhbHNlLFxuICAgIGxhbmd1YWdlOiBERUZBVUxUX0xBTkcsXG4gICAgbWF4X2NvdW50OiBERUZBVUxUX01BWF9DT1VOVCxcbiAgfVxuKSB7XG4gIGNvbnN0IHJlc2VydmVkX3dvcmRzID0gbmV3IFNldChSRVNFUlZFRF9XT1JEU1tsYW5ndWFnZV0pO1xuXG4gIGxldCBjb3VudCA9IDA7XG4gIGxldCBpbmRleGVzID0gWy0xXTtcbiAgbGV0IGkgPSAwO1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKGNvdW50ID09PSBtYXhfY291bnQpIHJldHVybjtcblxuICAgIGkrKztcblxuICAgIGlmIChpbmRleGVzW2luZGV4ZXMubGVuZ3RoIC0gMV0gPT09IGNoYXJzLmxlbmd0aCAtIDEpIHtcbiAgICAgIC8vIHJlc2V0IGF0IGFsbCBBJ3NcbiAgICAgIC8vIHNvIGluY3JlbWVudCB0aGUgcHJldmlvdXMgYXZhaWxhYmxlIGNoYXJhY3RlciBieSBvbmVcbiAgICAgIC8vIHNvIGlmIEFBWiBnbyB0byBBQkFcbiAgICAgIGxldCByZXNldF9pbmRleCA9IG51bGw7XG4gICAgICBmb3IgKGxldCBpaSA9IGluZGV4ZXMubGVuZ3RoIC0gMjsgaWkgPj0gMDsgaWktLSkge1xuICAgICAgICBpZiAoaW5kZXhlc1tpaV0gPCBjaGFycy5sZW5ndGggLSAyKSB7XG4gICAgICAgICAgcmVzZXRfaW5kZXggPSBpaTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHJlc2V0X2luZGV4ID09PSBudWxsKSB7XG4gICAgICAgIGlmIChkZWJ1ZylcbiAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgIFwiW3Zhci1uYW1lc10gYWRkaW5nIGEgY2hhcmFjdGVyIGFuZCByZXNldHRpbmcgdG8gYWxsIEEnc1wiXG4gICAgICAgICAgKTtcbiAgICAgICAgaW5kZXhlcyA9IGluZGV4ZXMubWFwKChuKSA9PiAwKS5jb25jYXQoWzBdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluZGV4ZXNbcmVzZXRfaW5kZXhdKys7XG4gICAgICAgIGZvciAobGV0IGlpID0gcmVzZXRfaW5kZXggKyAxOyBpaSA8IGluZGV4ZXMubGVuZ3RoOyBpaSsrKSB7XG4gICAgICAgICAgaW5kZXhlc1tpaV0gPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGluZGV4ZXNbaW5kZXhlcy5sZW5ndGggLSAxXSsrO1xuICAgIH1cbiAgICBjb25zdCBuZXdfdmFyaWFibGVfbmFtZSA9IGluZGV4ZXMubWFwKChpaSkgPT4gY2hhcnNbaWldKS5qb2luKFwiXCIpO1xuICAgIGlmIChyZXNlcnZlZF93b3Jkcy5oYXMobmV3X3ZhcmlhYmxlX25hbWUpKSB7XG4gICAgICBpZiAoZGVidWcpXG4gICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgIFwiW3Zhci1uYW1lc10gc2tpcHBpbmcgXCIgK1xuICAgICAgICAgICAgbmV3X3ZhcmlhYmxlX25hbWUgK1xuICAgICAgICAgICAgXCJiZWNhdXNlIGl0IGlzIGEgcmVzZXJ2ZWQgd29yZFwiXG4gICAgICAgICk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGRlYnVnKSBjb25zb2xlLmxvZyhcIlt2YXItbmFtZXNdIHRyeWluZyB0byBldmFsIG5ld192YXJpYWJsZV9uYW1lXCIpO1xuICAgIHRyeSB7XG4gICAgICBldmFsKGBjb25zdCAke25ld192YXJpYWJsZV9uYW1lfSA9IFwidGVzdFwiO2ApO1xuICAgICAgY291bnQrKztcbiAgICAgIHlpZWxkIG5ld192YXJpYWJsZV9uYW1lO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoZGVidWcpIGNvbnNvbGUubG9nKFwiW3Zhci1uYW1lc10gY2FuJ3QgdXNlIFwiICsgbmV3X3ZhcmlhYmxlX25hbWUpO1xuICAgIH1cbiAgfVxufVxuXG5pZiAodHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIikgbW9kdWxlLmV4cG9ydHMgPSB7IGdlblZhck5hbWVzIH07XG5pZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikgd2luZG93LnZhcm5hbWVzID0geyBnZW5WYXJOYW1lcyB9O1xuaWYgKHR5cGVvZiBzZWxmID09PSBcIm9iamVjdFwiKSBzZWxmLnZhcm5hbWVzID0geyBnZW5WYXJOYW1lcyB9O1xuIl19
