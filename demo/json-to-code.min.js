(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.jsonToCode = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
const minQuote = require("min-quote");

const declareVars = ({ vars, comment=false, language="JavaScript", pretty, semi }) => {
  language = language.toUpperCase();
  let lang;
  if (language === "JS" || language === "JAVASCRIPT") lang = "JS";
  else if (language === "PY" || language === "PYTHON") lang = "PY";
  console.log("declare vars:", lang)

  if (semi === undefined) {
    if (lang === "JS") semi = true;
    else if (lang === "PY") semi = false;
  }

  if (pretty === undefined) {
    if (lang === "JS") pretty = false;
    else if (lang === "PY") pretty = true;
  }

  let out = "";
  if (comment) {
    if (lang === "JS") out += "/* " + (typeof comment === "string" ? comment : "declarations") + " */\n";
    if (lang === "PY") out += "# " + (typeof comment === "string" ? comment : "declarations") + "\n";
  }
  if (!pretty && lang === "JS") out += "const ";
  vars.forEach(({ name, value, raw=false }, i) => {
    if (pretty) {
      if (i !== 0) out += "\n";
      out += (lang === "JS" ? "const " : "") + name + "=";
    } else {
      if (i !== 0) {
        if (lang === "JS") out += ",";
        else if (lang === "PY") out += ";";
      }
      out += name + "=";  
    }
    if (typeof value === "number" || raw) {
      out += value;
    } else if (typeof value === "string") {
      out += minQuote(value, { backtick: lang === "JS" });
    }
    if (pretty && semi) out += ";";
  });
  if (semi && !pretty) out += ";"
  return out;
};

module.exports = declareVars;

},{"min-quote":2}],2:[function(require,module,exports){
const minQuote = (str, { debug=false, backtick=true } = { backtick: false, debug: false }) => {
  if (debug) console.log("[min-quote] starting with str:", [str]);
  let quotechars = ["'", '"', "`"];
  let numQuotes = quotechars.length;
  let selection;
  for (let i = 0; i < numQuotes; i++) {
    const char = quotechars[i];
    if (!str.includes(char)) {
      selection = char;
      break;
    }
  }
  let result;
  if (selection) {
    result = selection + str + selection;
  } else {
    // chose the quote that would require the least amount of escaping
    const counts = { "'": 0, '"': 0, "`": 0 };
    for (let i = 0; i < str.length; i++) {
      const char = str[i];
      if (char === "'" || char === '"' || char === "`") {
        counts[char]++;
      }
    }
    if (debug) console.log("[min-quote] counts:", counts);
    const sortedCounts = Object.entries(counts).sort((a, b) => Math.sign(a[1] - b[1]));
    const minCount = sortedCounts[0][1];
    const candidates = sortedCounts.filter(([char, count]) => count === minCount);
    const notBackticks = candidates.filter(([char, count]) => char !== "`");
    if (notBackticks.length >= 1) selection = notBackticks[0][0];
    else selection = candidates[0][0];
    if (debug) console.log("[min-quote] selection:", selection);
    result = selection + str.replace(selection, "\\" + selection) + selection;
  }
  return result;
};

if (typeof module === "object") module.exports = minQuote;
if (typeof window === "object") window.minQuote = minQuote;
if (typeof self === "object") self.minQuote = minQuote;
},{}],3:[function(require,module,exports){
const { forEach } = require("advarr");
const count = require("deep-counter");
const declareVars = require("declare-vars");
const deconcat = require("deconcat");
const walk = require("deepest-walk");
const countNGrams = require("n-gram-counter");
const minQuote = require("min-quote");
const { genVarNames } = require("var-names");
const separo = require("separo");
const striptags = require("striptags");

const isQuoted = (str) => str.match(/^(['"`]).*\1$/);

const forEachString = (data, cb) => {
  walk({
    data,
    callback: ({ data, mod, type }) => {
      if (typeof data === "string") {
        cb({ str: data, mod, dataType: type });
      }
    },
  });
};

// string in code
const toString = (it) => {
  if (it === null) return "null";
  else if (it === undefined) return "undefined";
  else if (typeof it === "string") return it;
  else if (typeof it === "number") return it.toString();
  else throw new Error("to-string failed because unexpected type");
};

const encode = ({ data, debug_level = 0, language="JavaScript", max_passes = 0, prefix, spacer }) => {
  if (debug_level >= 1) console.log("[encode] starting");
  if (debug_level >= 2) console.log("[encode] data:", JSON.stringify(data).substring(0, 200), "...");

  // normalizing language
  language = language.toUpperCase();
  let lang;
  if (language === "JS" || language === "JAVASCRIPT") lang = "JS";
  else if (language === "PY" || language === "PYTHON") lang = "PY";

  if (prefix == undefined) {
    if (lang === "JS") prefix = "module.exports";
    else if (lang === "PY") prefix = "data";
  }
  
  const useBacktick = lang === "JS";

  const counts = count({ data, debug_level: debug_level - 1 });
  if (debug_level >= 1) console.log("counts:", counts);

  const stringified = typeof data === "string" ? data : JSON.stringify(data);
  if (debug_level >= 1) console.log("[encode] stringified:", stringified.substring(0, 200), "...");

  /* generate a UID for text operations */
  let uid;
  while (!uid) {
    const num = Math.floor(Math.random() * 1e5).toString();
    if (!stringified.includes(num)) uid = num;
  }
  if (debug_level >= 1) console.log("uid:", uid);

  // a number is always the first and last because there's not such thing as a sub-number (unlike a sub-string)
  const number_counts = Object.values(counts.numbers).map((it) => ({
    type: "number",
    value: it.value,
    count: it.count,
  }));

  const string_counts = Object.values(counts.strings).map((it) => ({
    type: "string",
    value: it.value,
    count: it.count,
    first: it.first,
    last: it.last,
  }));

  const all_counts = [...number_counts, ...string_counts];
  if (counts.null) {
    all_counts.push({
      type: "null",
      value: null,
      count: counts.null,
    });
  }
  if (counts.undefined) {
    all_counts.push({
      type: "undefined",
      value: undefined,
      count: counts.undefined,
    });
  }

  const sorted_counts = all_counts.sort((a, b) => Math.sign(b.count - a.count));
  if (debug_level >= 1) console.log("[encode] sorted counts");
  if (debug_level >= 2) console.log("[encode] sorted_counts:", sorted_counts);

  const tokens = sorted_counts.map((it) => {
    try {
      if (debug_level >= 2) console.log("it:", it);

      const { value, count, type } = it;

      const value_string = toString(value);

      if (["null", "number", "undefined"].includes(type)) {
        const value_length = value_string.length;
        const current_cost = count * value_length;
        const savings = {};
        for (let variable_length = 1; variable_length <= 5; variable_length++) {
          // like ,A=123; or ,Ba=null or ,Ab=undefined;
          const declaration_cost = 1 + variable_length + 1 + value_length;
          const replacement_cost = declaration_cost + count * variable_length;
          savings[variable_length] = current_cost - replacement_cost;
        }
        return { value, count, savings };
      } else if (type === "string") {
        const { first, last } = it;
        const percent_start = first / count;
        const percent_end = last / count;
        const not_percent_start = 1 - percent_start;
        const not_percent_end = 1 - percent_end;

        // if it is always preceeded by a space, we will later prepend a " " space
        const pad = first === 0;
        if (debug_level >= 2) console.log("pad:", pad);

        // how many characters the current value takes up
        const value_length = `${pad ? " " : ""}${value_string}`.length;
        if (debug_level >= 2) console.log("value_length:", value_length);

        const current_cost = count * value_length;
        if (debug_level >= 2) console.log("current_cost:", current_cost);

        const savings = {};
        for (let variable_length = 1; variable_length <= 5; variable_length++) {
          // like ,A='+lon_0=105'
          let declaration_length = 1 + variable_length + 1 + 1 + value_length + 1;

          // not factoring in that strings can be keys as well
          // will need to upgrade deep-counter to track additional stats like is the string a complete key, is the string part of a key and position, and is string a substring in a string
          // also need to factor in whether to prepend space or not
          // ?? maybe should factor in assuming strings are replaced before and after with variables ??
          const average_replacement_length = `"+`.length * not_percent_start + variable_length + `"+`.length * not_percent_end;
          // console.log("average_replacement_length:", average_replacement_length);

          const total_replacement_size = declaration_length + average_replacement_length * count;
          if (debug_level >= 3) console.log("total_replacement_size:", total_replacement_size);
          savings[variable_length] = current_cost - total_replacement_size;
        }
        if (debug_level >= 2) console.log("savings:", savings);
        return {
          value: (pad ? " " : "") + it.value,
          count: count,
          first,
          last,
          pad,
          savings,
        };
      }
    } catch (error) {
      throw error;
    }
  });
  if (debug_level >= 1) console.log(tokens);

  const skipVarNames = new Set();
  if (lang === "PY") {
    ['and', 'as', 'is', 'or', 'null'].forEach(skipword => {
      skipVarNames.add(skipword);
    });
  }

  const varname2token = new Map();
  const token2varname = new Map();

  const gen = genVarNames();
  for (const varname of gen) {
    if (debug_level >= 2) console.log("varname:", varname);
    if (skipVarNames.has(varname)) continue;

    const varlen = varname.length;

    // sort tokens by saving for the given variable's length
    tokens.sort((a, b) => Math.sign(b.savings[varlen] - a.savings[varlen]));

    // pop out the first token
    const token = tokens.shift();

    // if we can save any space with the token with the most potential savings, break
    if (token.savings[varlen] <= 0) break;

    // console.log("token:", token);
    // save the selection

    varname2token.set(varname, { first: token.first, token: token.value });
    token2varname.set(token.value, { varname, first: token.first, value: token.value });
  }
  if (debug_level >= 1) console.log("assigned variable names to tokens");
  if (debug_level >= 2) console.log("token2name:", token2varname);

  // console.log("varname2token['U']:", varname2token['U']);

  // get a clone of the original data
  const result = JSON.parse(stringified);
  if (debug_level >= 1) console.log("cloned original data");
  if (debug_level >= 2) console.log("cloned data:", result);

  /*
    string operations
    <delprev> - deletes previous character
    <delnext> - deletes next character
  */
  const delprev = `<delprev-${uid}>`;
  const delnext = `<delnext-${uid}>`;

  const lookup = (x) => {
    let varname;
    let varvalue;
    if (token2varname.has(x)) {
      varname = token2varname.get(x).varname;
      varvalue = x;
    } else if (typeof x === "string") {
      if (x.startsWith(" ") && token2varname.has(x.substr(1))) {
        varname = token2varname.get(x.substr(1)).varname;
        varvalue = x.substr(1);
      } else if (!x.startsWith(" ") && token2varname.get(" " + x)) {
        varname = token2varname.get(" " + x).varname;
        varvalue = " " + x;
      }
    }
    return { varname, varvalue };
  };

  const getVarOut = ({ substr, varname, varvalue }) => {
    // console.log("starting getVarOut with:", { substr, varname, varvalue });
    if (substr.startsWith(" ")) {
      if (varvalue.startsWith(" ")) {
        return varname;
      } else {
        return `" "+${varname}`;
      }
    } else {
      if (varvalue.startsWith(" ")) {
        if (lang === "JS") {
          return `${varname}.trim()`;
        } else {
          return `${varnamme}.strip()`;
        }
      } else {
        return varname;
      }
    }
  };

  const unescp = (str) =>
    str.replaceAll('"', (match, offset, string) => {
      const before = string.substring(0, offset);
      // console.log({match, offset, string, before});
      if (before.endsWith(delnext)) return '"';
      else return delnext + '"';
    });

  const getExpr = (str) => {
    const { varname, varvalue } = lookup(str);
    if (varname) return getVarOut({ substr: str, varname, varvalue });
  };

  if (debug_level >= 1) console.log("starting walk");

  walk({
    data: result,
    callback: ({ data: it, mod, type: dataType }) => {
      try {
        if (debug_level >= 2) console.log("walking", { it, dataType });
        if (typeof it === "number") {
          const { varname } = lookup(it);
          if (varname) mod(delprev + varname + delnext);
        } else if (typeof it === "undefined") {
          const expr = getExpr(it);
          if (expr) mod(expr);
          else mod(delprev + "undefined" + delnext);  
        } else if (typeof it === "null") {
          const expr = getExpr(it);
          if (expr) mod(expr);
          else mod(delprev + "null" + delnext);  
        } else if (typeof it === "string") {
          if (["object-key-string", "object-value-string", "array-item-string"].includes(dataType)) {
            const words = separo(it, " ", { attachSep: true }).map((word) => {
              const expr = getExpr(word);
              if (expr) return { expr };
              else return { quoted: minQuote(word, { backtick: useBacktick }) };
            });
            if (words.some((word) => word.expr)) {
              let modStr = delprev;
              if (dataType === "object-key-string" && lang === "JS") modStr += "[";
              forEach(words, ({ it: word, prev, first: firstWord }) => {
                if (word.expr) {
                  if (!firstWord) modStr += "+";
                  modStr += word.expr;
                } else {
                  // current word and previous word use the same quotes
                  if (word.quoted[0] === prev?.quoted?.[0]) {
                    modStr = modStr.slice(0, -1) + word.quoted.slice(1);
                  } else {
                    // 2 strings in a row that share different quotes
                    if (!firstWord) modStr += "+";
                    modStr += word.quoted;
                  }
                }
              });
              if (dataType === "object-key-string" && lang === "JS") modStr += "]";
              modStr += delnext;
              mod(unescp(modStr));
            } else {
              mod(delprev + unescp(minQuote(it, { backtick: useBacktick })) + delnext);
            }
          } else {
            console.log("it:", { it, dataType });
            throw new Error("unexpected dataType:", dataType);
          }
        }
      } catch (error) {
        console.error("walking error", error);
        throw error;
      }
    },
  });

  /*
    Array to hold variables created from the concatenation of other vars
    For example A=B+C
    And the order is important
  */

  const usedVarNames = new Set(varname2token.keys());
  const actual_bigram_to_varname_passes = [];
  for (let pass = 0; pass < max_passes - 1; pass++) {
    const actual_bigram_to_varname = {};
    // get an array of new varnames of all the same length (i.e. cost)
    const varnames = [];
    let varlen;
    const varNameGen = genVarNames();
    for (const varname of varNameGen) {
      if (usedVarNames.has(varname)) continue;
      if (skipVarNames.has(varname)) continue;
      if (!varlen) varlen = varname.length;
      if (varname.length !== varlen) break;
      varnames.push(varname);
    }

    // clean text ops from strings
    const bigram_count = {};

    // we already replaced numbers, nulls, and undefineds in the first pass
    // so we can just focus on strings
    forEachString(result, ({ str }) => {
      // console.log("string:", [str]);
      // remove any text operations like delprev and delnext
      str = striptags(str);

      // remove [ ... ]
      str = str.replace(/^\[/, "").replace(/\]$/, "");

      const parts = deconcat(str);
      // console.log("parts:", parts)

      const bigrams = countNGrams({ data: parts, n: 2 });

      for (let b = 0; b < bigrams.length; b++) {
        const [bigram, subcount] = bigrams[b];
        const [first, second] = bigram;

        // ignore bigrams that include a strings
        if (isQuoted(first) || isQuoted(second)) continue;

        const key = JSON.stringify(bigram);
        if (key in bigram_count) bigram_count[key][1] += subcount;
        else bigram_count[key] = [bigram, subcount];
      }
    });

    const bigram_savings = [];
    Object.values(bigram_count).forEach(([bigram, count]) => {
      // bigram is like [ 'E', 'A' ]
      const len = bigram.join("+").length;
      const current_cost = len * count;
      // declaration cost is , + variable + = + len
      const declaration_cost = 1 + varlen + 1 + len;
      const replacement_cost = declaration_cost + varlen * count;
      const savings = current_cost - replacement_cost;

      // only care if actually save space
      if (savings > 0) bigram_savings.push([bigram, savings]);
    });

    // no more opportunities to save space
    if (bigram_savings.length === 0) break;

    // sort bigram savings array from smallest to largest savings
    bigram_savings.sort((a, b) => Math.sign(a[1] - b[1]));

    // console.log("bigram_savings", bigram_savings)

    // assign bigrams to varnames
    const bigram_to_varname = {};
    for (let v = 0; v < varnames.length; v++) {
      const varname = varnames[v];
      // console.log("varname:", varname);
      const [bigram, savings] = bigram_savings.pop();
      const key = JSON.stringify(bigram);
      bigram_to_varname[key] = { bigram, varname, savings };
      if (bigram_savings.length === 0) break;
    }
    // console.log("bigram_to_varname:", bigram_to_varname);

    // walk through data and see if replacement opportunities
    forEachString(result, ({ str, mod, dataType }) => {
      const hasDelPrev = str.startsWith(delprev);
      const hasDelNext = str.endsWith(delnext);

      if (dataType === "array-item-string") {
        // converts D+' +lat=39'+u+CO into ["D", "' +lat=39'", "u", "CO"], so can be combined again with +
        const parts = deconcat(striptags(str));

        const swapped = [];

        if (parts.length === 1) {
          swapped.push(parts[0]);
        } else {
          // can only replace bigrams if have more than one gram
          for (let p = 1; p < parts.length; p++) {
            // console.log("p:", p);
            const prev = parts[p - 1];
            const curr = parts[p];
            const bigram = [prev, curr];
            // console.log("bigram;", bigram);
            const key = JSON.stringify(bigram);
            if (key in bigram_to_varname) {
              // console.log("replacing");
              const varname = bigram_to_varname[key].varname;
              swapped.push(varname);
              usedVarNames.add(varname);
              actual_bigram_to_varname[key] = { bigram, varname };
              p++; // skip checking the next bigram (because curr would be prev for that)

              // there's only one gram left, so we know that it won't be replaced
              if (p === parts.length - 1) swapped.push(parts[p]);
            } else {
              swapped.push(prev);
              if (p === parts.length - 1) swapped.push(curr);
            }
            // console.log("swapped:", swapped);
          }
        }
        // console.log("replaced", parts, "with", swapped);

        const newStr = (hasDelPrev ? delprev : "") + swapped.join("+") + (hasDelNext ? delnext : "");

        mod(unescp(newStr));
      }
    });
    // console.log(actual_bigram_to_varname);
    if (Object.keys(actual_bigram_to_varname).length > 0) {
      actual_bigram_to_varname_passes.push(actual_bigram_to_varname);
    }
  }

  let outcode = "";

  // add in null = "None"
  // for Python
  // because JSON.stringify will write in null values
  if (lang === "PY") {
    outcode += "# special handling for Python\nnull = None\nundefined = None\n"
  }

  // first declare the first variable replacements
  outcode += declareVars({
    comment: "pass 1",
    language: lang,
    vars: Array.from(varname2token.entries()).map(([name, { token }]) => {
      if (typeof token === "string") {
        return { name, value: token };
      } else if (token === null) {
        return { name, value: "null", raw: true };
      } else if (typeof token === "undefined") {
        return { name, value: "undefined", raw: true };
      } else if (typeof token === "number") {
        return { name, value: token.toString(), raw: true };
      }
    }),
  });

  actual_bigram_to_varname_passes.forEach((actual_bigram_to_varname, i) => {
    outcode += "\n\n";
    outcode += declareVars({
      comment: "pass " + (i + 2),
      language: lang,
      vars: Object.values(actual_bigram_to_varname).map(({ bigram, varname }) => ({ name: varname, value: bigram.join("+"), raw: true })),
    });
  });

  // process the text operations
  const processedJSON = JSON.stringify(result, undefined, spacer)
    .replaceAll(new RegExp(`.${delprev}`, "g"), "")
    .replaceAll(new RegExp(`${delnext}.`, "g"), "");

  outcode += "\n";
  outcode += `${prefix} = ${processedJSON};`;

  return { code: outcode };
};

module.exports = { encode };

},{"advarr":4,"declare-vars":1,"deconcat":5,"deep-counter":6,"deepest-walk":8,"min-quote":9,"n-gram-counter":10,"separo":12,"striptags":13,"var-names":14}],4:[function(require,module,exports){
const iter = ({ inpt, func, cb, thisArg }) => {
  try {
    const length = inpt.length;

    // shallow-copy origin array
    const originalArray = Array.from(inpt);

    const firstValue = originalArray[0];
    const lastValue = originalArray[length - 1];

    return inpt[func]((value, i, array) => {
      return cb({
        value,
        currentValue: value,
        element: value,
        item: value,
        it: value,

        firstValue,
        firstElement: firstValue,
        firstItem: firstValue,
        firstIt: firstValue,

        lastValue,
        lastElement: lastValue,
        lastItem: lastValue,
        lastIt: lastValue,

        i,
        index: i,

        array,

        get percent() { return (i + 1) / length; },

        get length() { return length; },

        get previous() { return originalArray[i - 1]; },
        get prev() { return originalArray[i - 1]; },

        get next() { return originalArray[i + 1]; },

        get before() { return originalArray.slice(0, i); },
        get after() { return originalArray.slice(i + 1); },

        brk: (n=1) => { throw `[advarr] breaking ${n}`; },

        // ordinal numbers
        first: i === 0,
        second: i === 1,
        third: i === 2,
        fourth: i === 3,
        fifth: i === 4,
        sixth: i === 5,
        seventh: i === 6,
        eigth: i === 7,
        ninth: i === 8,
        tenth: i === 9,

        last: i === length - 1,
        penultimate: i === length - 2,
        antepenultimate: i === length - 3,

        odd: i % 2 === 1,
        even: i % 2 === 0,
      });
    }, thisArg);
  } catch (error) {
    let msg = error.toString();
    if (!msg.includes("[advarr] breaking 1")) {
      if (msg.includes("[advarr] breaking")) {
        const n = parseInt(msg[msg.length - 1]);
        msg = "[advarr] breaking " + (n - 1);
      }
      throw msg;
    }
  }
};

const advarr = {};
["every", "filter", "find", "findIndex", "flatMap", "forEach", "map", "some"].forEach(key => {
  advarr[key] = (inpt, cb, thisArg) => iter({ inpt, func: key, cb, thisArg });
});

if (typeof module.exports === "object") module.exports = advarr;
if (typeof window === "object") window.advarr = advarr;
if (typeof self === "object") self.advarr = advarr;

},{}],5:[function(require,module,exports){
const deconcat = (str, debug) => {
  const tokens = [];
  let inString = false;
  let current = '';
  let quotechar = null;
  for (let i = 0; i < str.length; i++) {
    const char = str[i];
    if (debug) console.log("char:", char);
    if (char === "+") {
      if (inString) {
        current += char;
      } else if (current !== '') {
        tokens.push(current);
        current = "";
      }
    } else if (char === `'` || char === `"` || char === "`") {
      current += char;
      if (inString) {
        if (char === quotechar && str[i-1] !== "\\") inString = false;
      } else {
        inString = true;
        quotechar = char;
      }
    } else if (char === ` `) {
      if (inString) current += char;
    } else {
      current += char;
    }
  }
  if (current !== '') tokens.push(current);
  return tokens;
}

if (typeof module === "object") module.exports = deconcat;
if (typeof window === "object") window.deconcat = deconcat;
if (typeof self === "object") self.deconcat = deconcat;


},{}],6:[function(require,module,exports){
const { forEach } = require("advarr");

const merge = require("./merge-counts");

const count = (options) => {
  let {
    data,
    debug_level=0,
    count_numbers=true,
    count_strings=true,
    split_strings_on=" "
  } = options;

  if (debug_level >= 1) console.log("[deep-counter] options:", options);

  if (!('data' in options)) throw new Error("[deep-counter] you called count without a data property set")

  const results = {
    strings: {},
    numbers: {},
    null: 0,
    undefined: 0
  };

  if (Array.isArray(data)) {
    forEach(data, ({ value }) => {
      merge({
        from: count({ ...options, data: value }),
        into: results
      });
    });
  } else if (data === null) {
    results.null++;
  } else if (data === undefined) {
    results.undefined++;
  } else if (typeof data === "object") {
    merge({
      from: count({ ...options, data: Object.keys(data) }),
      into: results
    });
    merge({
      from: count({ ...options, data: Object.values(data) }),
      into: results
    });
  } else if (typeof data === "string") {
    if (count_strings) {
      const tokens = data.split(split_strings_on);
      forEach(tokens, ({ value: token, last, first }) => {    
        if (token in results.strings) {
          results.strings[token].count++;
        } else {
          results.strings[token] = {
            value: token,
            count: 1,
            first: 0,
            last: 0
          };
        }
        if (first) results.strings[token].first++
        if (last) results.strings[token].last++
      });
    }
  } else if (typeof data === "number") {
    if (count_numbers) {
      if (data in results.numbers) {
        results.numbers[data].count++;
      } else {
        results.numbers[data] = { count: 1, value: data };
      }
    }
  }
  return results;
};

module.exports = count;


},{"./merge-counts":7,"advarr":4}],7:[function(require,module,exports){
module.exports = ({ from, into }) => {
  Object.entries(from).forEach(([type, counts]) => {
    if (type in into) {
      if (typeof counts === "number") {
        into[type] += counts;
      } else {
        Object.entries(counts).forEach(([token, info]) => {
          // console.log("into:", into);
          // console.log("type:", type);
          if (token in into[type]) {
            // iterate over values if it's a number add it
            Object.entries(info).forEach(([key, count]) => {
              if (key !== "value") {
                // console.log({key, count});
                if (key in into[type][token]) {
                  into[type][token][key] += count;
                } else {
                  into[type][token][key] = count;
                }
              }
            });
          } else {
            into[type][token] = info;
          }
        });
      }
    } else {
      into[type] = counts;
    }
  });
};

},{}],8:[function(require,module,exports){
const { forEach, map } = require("advarr");
const replaceKey = require("replace-key");

// utility functions
const isAry = (it) => Array.isArray(it);
const isNul = (it) => it === null;
const isObj = (it) => !Array.isArray(it) && !isNul(it) && typeof it === "object";
const isStr = (it) => typeof it === "string";
const isNum = (it) => typeof it === "number";

// doing split strings on /(?= )/ splits "a cow jumped" to [ 'a', ' cow', ' jumped' ]
function walk({
  callback,
  data,
  debug = false,
  path = [],
  split_strings_on = null, // alternative is " " if you want to split on words
  include_sep = false, // defaults to including separator in beginging if exists
  max_path_length: m = Infinity,
  split_keys = undefined,
}) {
  // saving args to pass down
  let args = arguments[0];

  if (split_keys === undefined) {
    split_keys = split_strings_on !== undefined;
  }

  if (debug) console.log("starting walk with args", args);
  const hasPath = isAry(path) && path.length > 0;
  const isArrayItem = hasPath && isNum(path[0]) && isAry(path[1]);
  const isObjValue = hasPath && isStr(path[0]) && isObj(path[1]);

  const split_str = (str) =>
    map(str.split(split_strings_on), ({ it, first }) => (include_sep && !first ? split_strings_on : "") + it);
  const join_subs = (subs) => subs.join(include_sep ? "" : split_strings_on);

  if (!hasPath && isStr(data)) throw new Error("you must pass in an object or an array to start");

  if (isAry(data)) {
    data.forEach((item, i) => {
      if (isStr(item)) {
        callback({
          type: "array-item-string",
          data: item,
          mod: (new_item) => (data[i] = new_item),
        });
        if (split_strings_on) {
          const subItems = split_str(item);
          forEach(subItems, ({ it: subItem, index: ii, next, prev, first: isFirstSubstr, last: isLastSubstr }) => {
            callback({
              type: "array-item-substring",
              data: subItem,
              mod: (newSubItem) => {
                subItems[ii] = newSubItem;
                data[i] = subItems.join(include_sep ? "" : split_strings_on);
              },
              path: [ii, item, data, ...path],
              next,
              prev,
              first: isFirstSubstr,
              last: isLastSubstr,
            });
          });
        }
      } else {
        walk({ ...args, data: item, path: [i, data, ...path].slice(0, m) });
      }
    });
  } else if (isObj(data)) {
    Object.keys(data).forEach((key) => {
      callback({
        type: "object-key-string",
        data: key,
        mod: (new_key) => {
          replaceKey({ obj: data, old_key: key, new_key });
          key = new_key;
        },
      });

      if (split_keys && split_strings_on) {
        const subKeys = split_str(key);
        forEach(subKeys, ({ it: subkey, i, first, last, prev, next }) => {
          const mod = (newSubKey) => {
            subKeys[i] = newSubKey;
            const new_key = join_subs(subKeys);
            replaceKey({ obj: data, old_key: key, new_key });
            key = new_key;
          };
          callback({
            type: "object-key-substring",
            data: subkey,
            mod,
            first,
            last,
            prev,
            next,
          });
        });
      }
      let value = data[key];
      if (debug) console.log("value:", value);
      if (isStr(value)) {
        callback({
          type: "object-value-string",
          data: value,
          mod: (newValue) => {
            data[key] = newValue;
            value = newValue;
          },
        });
        if (split_strings_on) {
          const subValues = split_str(value);
          forEach(subValues, ({ it: subvalue, i }) => {
            const mod = (newSubValue) => {
              subValues[i] = newSubValue;
              data[key] = join_subs(subValues);
              subvalue = newSubValue;
            };
            callback({
              type: "object-value-substring",
              data: subvalue,
              mod,
            });
          });
        }
      } else {
        // walk value
        walk({ ...args, data: data[key], path: [...key, data, ...path].slice(0, m) });
      }
    });
  } else if (data === undefined || data === null || typeof data === "number") {
    if (!hasPath) {
      callback({
        data,
        mod: () => {
          throw new Error("unable to mod");
        },
      });
    } else if (isArrayItem || isObjValue) {
      let type;
      if (data === undefined) type = "array-item-undefined";
      else if (data === null) type = "array-item-null";
      else if (typeof data === "number") type = "array-item-number";
      callback({
        data,
        type,
        mod: (new_value) => {
          path[1][path[0]] = new_value;
          value = new_value;
        },
      });
    }
  }
}

module.exports = walk;

},{"advarr":4,"replace-key":11}],9:[function(require,module,exports){
arguments[4][2][0].apply(exports,arguments)
},{"dup":2}],10:[function(require,module,exports){
const count_array = ({ arr, debug, n }) => {
    const counts = {};
    if (debug) console.log("arr:", arr);
    for (let i = n; i <= arr.length; i++) {
        const ngram = arr.slice(i - n, i);
        if (debug) console.log("ngram:", ngram);
        if (counts.hasOwnProperty(ngram)) counts[ngram].count++;
        else counts[ngram] = { original: ngram, count: 1 };
    }
    if (debug) console.log("counts:", counts);
    const sorted = Object.entries(counts).sort((a, b) => Math.sign(b[1].count - a[1].count));
    if (debug) console.log("sorted:", sorted);
    const results = sorted.map(it => [it[1].original, it[1].count]);
    if (debug) console.log("results:", results);
    return results;
}

const count_text = ({ text, debug, n }) => {
    const counts = {};
    if (debug) console.log("text: " + text.substring(0, 100).trim() + "...");
    for (let i = n; i <= text.length; i++) {
        const ngram = text.substring(i - n, i);
        if (debug) console.log("ngram:", ngram);
        if (counts.hasOwnProperty(ngram)) counts[ngram]++;
        else counts[ngram] = 1;
    }
    if (debug) console.log("counts:", counts);
    const sorted = Object.entries(counts).sort((a, b) => Math.sign(b[1] - a[1]));
    if (debug) console.log("sorted:", sorted);
    return sorted;
}

module.exports = ({ data, debug, n }) => {
    if (Array.isArray(data)) {
        return count_array({ arr: data, debug, n });
    } else {
        return count_text({ text: data, debug, n });
    }
};

},{}],11:[function(require,module,exports){
const replaceKey = ({ obj, old_key, new_key }) => {
  if (obj === null || typeof obj !== "object") throw new Error(`[replace-key] obj is not an object"`);
  if (!(old_key in obj)) throw new Error(`[replace-key] "${old_key}" is not a key of obj`);
  obj[new_key] = obj[old_key];
  delete obj[old_key];
  return obj;
}

if (typeof module === "object") module.exports = replaceKey;
if (typeof window === "object") window.replaceKey = replaceKey;
if (typeof self === "object") self.replaceKey = replaceKey;

},{}],12:[function(require,module,exports){
const separo = (str, sep=' ', { attachSep=false, keepSep=false } = { attachSep: false, keepSep: false }) => {
  if (typeof sep === 'string') sep = new Set([sep]);
  else if (Array.isArray(sep)) sep = new Set(sep);

  const result = [];
  let current = '';
  for (let i = 0; i < str.length; i++) {
    const char = str[i];
    if (sep.has(char)) {
      result.push(current);
      if (attachSep) {
        current = char;
      } else if (keepSep) {
        result.push(char);
        current = '';
      } else {
        current = '';
      }
    } else {
      current += char;
    }
  }
  if (current.length > 0) result.push(current);

  return result;
};

if (typeof module === 'object') module.exports = separo;
if (typeof window === 'object') window.separo = separo;
if (typeof self === 'object') self.separo = separo;

},{}],13:[function(require,module,exports){
'use strict';

(function (global) {

    // minimal symbol polyfill for IE11 and others
    if (typeof Symbol !== 'function') {
        var Symbol = function(name) {
            return name;
        }

        Symbol.nonNative = true;
    }

    const STATE_PLAINTEXT = Symbol('plaintext');
    const STATE_HTML      = Symbol('html');
    const STATE_COMMENT   = Symbol('comment');

    const ALLOWED_TAGS_REGEX  = /<(\w*)>/g;
    const NORMALIZE_TAG_REGEX = /<\/?([^\s\/>]+)/;

    function striptags(html, allowable_tags, tag_replacement) {
        html            = html || '';
        allowable_tags  = allowable_tags || [];
        tag_replacement = tag_replacement || '';

        let context = init_context(allowable_tags, tag_replacement);

        return striptags_internal(html, context);
    }

    function init_striptags_stream(allowable_tags, tag_replacement) {
        allowable_tags  = allowable_tags || [];
        tag_replacement = tag_replacement || '';

        let context = init_context(allowable_tags, tag_replacement);

        return function striptags_stream(html) {
            return striptags_internal(html || '', context);
        };
    }

    striptags.init_streaming_mode = init_striptags_stream;

    function init_context(allowable_tags, tag_replacement) {
        allowable_tags = parse_allowable_tags(allowable_tags);

        return {
            allowable_tags : allowable_tags,
            tag_replacement: tag_replacement,

            state         : STATE_PLAINTEXT,
            tag_buffer    : '',
            depth         : 0,
            in_quote_char : ''
        };
    }

    function striptags_internal(html, context) {
        let allowable_tags  = context.allowable_tags;
        let tag_replacement = context.tag_replacement;

        let state         = context.state;
        let tag_buffer    = context.tag_buffer;
        let depth         = context.depth;
        let in_quote_char = context.in_quote_char;
        let output        = '';

        for (let idx = 0, length = html.length; idx < length; idx++) {
            let char = html[idx];

            if (state === STATE_PLAINTEXT) {
                switch (char) {
                    case '<':
                        state       = STATE_HTML;
                        tag_buffer += char;
                        break;

                    default:
                        output += char;
                        break;
                }
            }

            else if (state === STATE_HTML) {
                switch (char) {
                    case '<':
                        // ignore '<' if inside a quote
                        if (in_quote_char) {
                            break;
                        }

                        // we're seeing a nested '<'
                        depth++;
                        break;

                    case '>':
                        // ignore '>' if inside a quote
                        if (in_quote_char) {
                            break;
                        }

                        // something like this is happening: '<<>>'
                        if (depth) {
                            depth--;

                            break;
                        }

                        // this is closing the tag in tag_buffer
                        in_quote_char = '';
                        state         = STATE_PLAINTEXT;
                        tag_buffer   += '>';

                        if (allowable_tags.has(normalize_tag(tag_buffer))) {
                            output += tag_buffer;
                        } else {
                            output += tag_replacement;
                        }

                        tag_buffer = '';
                        break;

                    case '"':
                    case '\'':
                        // catch both single and double quotes

                        if (char === in_quote_char) {
                            in_quote_char = '';
                        } else {
                            in_quote_char = in_quote_char || char;
                        }

                        tag_buffer += char;
                        break;

                    case '-':
                        if (tag_buffer === '<!-') {
                            state = STATE_COMMENT;
                        }

                        tag_buffer += char;
                        break;

                    case ' ':
                    case '\n':
                        if (tag_buffer === '<') {
                            state      = STATE_PLAINTEXT;
                            output    += '< ';
                            tag_buffer = '';

                            break;
                        }

                        tag_buffer += char;
                        break;

                    default:
                        tag_buffer += char;
                        break;
                }
            }

            else if (state === STATE_COMMENT) {
                switch (char) {
                    case '>':
                        if (tag_buffer.slice(-2) == '--') {
                            // close the comment
                            state = STATE_PLAINTEXT;
                        }

                        tag_buffer = '';
                        break;

                    default:
                        tag_buffer += char;
                        break;
                }
            }
        }

        // save the context for future iterations
        context.state         = state;
        context.tag_buffer    = tag_buffer;
        context.depth         = depth;
        context.in_quote_char = in_quote_char;

        return output;
    }

    function parse_allowable_tags(allowable_tags) {
        let tag_set = new Set();

        if (typeof allowable_tags === 'string') {
            let match;

            while ((match = ALLOWED_TAGS_REGEX.exec(allowable_tags))) {
                tag_set.add(match[1]);
            }
        }

        else if (!Symbol.nonNative &&
                 typeof allowable_tags[Symbol.iterator] === 'function') {

            tag_set = new Set(allowable_tags);
        }

        else if (typeof allowable_tags.forEach === 'function') {
            // IE11 compatible
            allowable_tags.forEach(tag_set.add, tag_set);
        }

        return tag_set;
    }

    function normalize_tag(tag_buffer) {
        let match = NORMALIZE_TAG_REGEX.exec(tag_buffer);

        return match ? match[1].toLowerCase() : null;
    }

    if (typeof define === 'function' && define.amd) {
        // AMD
        define(function module_factory() { return striptags; });
    }

    else if (typeof module === 'object' && module.exports) {
        // Node
        module.exports = striptags;
    }

    else {
        // Browser
        global.striptags = striptags;
    }
}(this));

},{}],14:[function(require,module,exports){
const alphabet_lower = "abcdefghijklmnopqrstuvwxyz";
const alphabet_upper = alphabet_lower.toUpperCase();

const DEFAULT_CHARS = Array.from(alphabet_upper + alphabet_lower);

const DEFAULT_LANG = "JS";

const DEFAULT_MAX_COUNT = 1e6;

const RESERVED_WORDS = {
  // prettier-ignore
  JS: [
    "abstract", "alert", "all", "anchor", "anchors", "area", "arguments", "assign", "Array", "await",
    "boolean", "blur", "break", "button", "byte",
    "case", "catch", "char", "checkbox", "class", "clearInterval", "clearTimeout", "clientInformation", "close", "closed", "confirm", "const", "constructor", "continue", "crypto",
    "Date", "debugger", "decodeURI", "decodeURIComponent", "default", "defaultStatus", "delete", "do", "document", "double",
    "element", "elements", "else", "embed", "embeds", "encodeURI", "encodeURIComponent", "enum", "escape", "eval", "event", "export", "extends",
    "false", "fileUpload", "final", "finally", "float", "focus", "for", "form", "forms", "frame", "frameRate", "frames", "function",
    "getClass", "goto",
    "hasOwnProperty", "hidden", "history",
    "if", "image", "images", "implements", "import", "in", "Infinity", "innerHeight", "innerWidth", "instanceof", "int", "interface", "isFinite", "isNaN", "isPrototypeOf",
    "java", "javaClass", "JavaArray", "JavaObject", "JavaPackage",
    "layer", "layers", "length", "let", "link", "location", "long",
    "Math", "mimeTypes", "module",
    "name", "NaN", "native", "navigate", "navigator", "new", "null", "Number",
    "offscreenBuffering", "Object", "open", "opener", "option", "outerHeight", "outerWidth",
    "package", "packages", "pageXOffset", "pageYOffset", "parent", "parseFloat", "parseInt", "password", "pkcs11", "plugin", "private", "prompt", "propertyIsEnum", "protected", "prototype", "public",
    "radio", "reset", "return",
    "screenX", "screenY", "scroll", "secure", "select", "self", "setInterval", "setTimeout", "short", "static", "status", "String", "submit", "super", "switch", "synchronized",
    "text", "textarea", "this", "throw", "throws", "top", "toString", "transient", "true", "try", "typeof",
    "undefined", "unescape", "untaint",
    "valueOf", "var", "void", "volatile",
    "while", "with", "window",
    "yield"
  ],
};

function* genVarNames(
  {
    chars = DEFAULT_CHARS,
    debug = false,
    language = DEFAULT_LANG,
    max_count = DEFAULT_MAX_COUNT,
  } = {
    chars: DEFAULT_CHARS,
    debug: false,
    language: DEFAULT_LANG,
    max_count: DEFAULT_MAX_COUNT,
  }
) {
  const reserved_words = new Set(RESERVED_WORDS[language]);

  let count = 0;
  let indexes = [-1];
  let i = 0;

  while (true) {
    if (count === max_count) return;

    i++;

    if (indexes[indexes.length - 1] === chars.length - 1) {
      // reset at all A's
      // so increment the previous available character by one
      // so if AAZ go to ABA
      let reset_index = null;
      for (let ii = indexes.length - 2; ii >= 0; ii--) {
        if (indexes[ii] < chars.length - 2) {
          reset_index = ii;
          break;
        }
      }
      if (reset_index === null) {
        if (debug)
          console.log(
            "[var-names] adding a character and resetting to all A's"
          );
        indexes = indexes.map((n) => 0).concat([0]);
      } else {
        indexes[reset_index]++;
        for (let ii = reset_index + 1; ii < indexes.length; ii++) {
          indexes[ii] = 0;
        }
      }
    } else {
      indexes[indexes.length - 1]++;
    }
    const new_variable_name = indexes.map((ii) => chars[ii]).join("");
    if (reserved_words.has(new_variable_name)) {
      if (debug)
        console.log(
          "[var-names] skipping " +
            new_variable_name +
            "because it is a reserved word"
        );
      continue;
    }
    if (debug) console.log("[var-names] trying to eval new_variable_name");
    try {
      eval(`const ${new_variable_name} = "test";`);
      count++;
      yield new_variable_name;
    } catch (error) {
      if (debug) console.log("[var-names] can't use " + new_variable_name);
    }
  }
}

if (typeof module === "object") module.exports = { genVarNames };
if (typeof window === "object") window.varnames = { genVarNames };
if (typeof self === "object") self.varnames = { genVarNames };

},{}]},{},[3])(3)
});

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcGFjay9fcHJlbHVkZS5qcyIsIi4uL2RlY2xhcmUtdmFycy9kZWNsYXJlLXZhcnMuanMiLCIuLi9kZWNsYXJlLXZhcnMvbm9kZV9tb2R1bGVzL21pbi1xdW90ZS9taW4tcXVvdGUuanMiLCJqc29uLXRvLWNvZGUuanMiLCJub2RlX21vZHVsZXMvYWR2YXJyL2FkdmFyci5qcyIsIm5vZGVfbW9kdWxlcy9kZWNvbmNhdC9kZWNvbmNhdC5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwLWNvdW50ZXIvZGVlcC1jb3VudGVyLmpzIiwibm9kZV9tb2R1bGVzL2RlZXAtY291bnRlci9tZXJnZS1jb3VudHMuanMiLCJub2RlX21vZHVsZXMvZGVlcGVzdC13YWxrL2RlZXBlc3Qtd2Fsay5qcyIsIm5vZGVfbW9kdWxlcy9uLWdyYW0tY291bnRlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yZXBsYWNlLWtleS9yZXBsYWNlLWtleS5qcyIsIm5vZGVfbW9kdWxlcy9zZXBhcm8vc2VwYXJvLmpzIiwibm9kZV9tb2R1bGVzL3N0cmlwdGFncy9zcmMvc3RyaXB0YWdzLmpzIiwibm9kZV9tb2R1bGVzL3Zhci1uYW1lcy92YXItbmFtZXMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcmdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzdKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSIsImNvbnN0IG1pblF1b3RlID0gcmVxdWlyZShcIm1pbi1xdW90ZVwiKTtcblxuY29uc3QgZGVjbGFyZVZhcnMgPSAoeyB2YXJzLCBjb21tZW50PWZhbHNlLCBsYW5ndWFnZT1cIkphdmFTY3JpcHRcIiwgcHJldHR5LCBzZW1pIH0pID0+IHtcbiAgbGFuZ3VhZ2UgPSBsYW5ndWFnZS50b1VwcGVyQ2FzZSgpO1xuICBsZXQgbGFuZztcbiAgaWYgKGxhbmd1YWdlID09PSBcIkpTXCIgfHwgbGFuZ3VhZ2UgPT09IFwiSkFWQVNDUklQVFwiKSBsYW5nID0gXCJKU1wiO1xuICBlbHNlIGlmIChsYW5ndWFnZSA9PT0gXCJQWVwiIHx8IGxhbmd1YWdlID09PSBcIlBZVEhPTlwiKSBsYW5nID0gXCJQWVwiO1xuICBjb25zb2xlLmxvZyhcImRlY2xhcmUgdmFyczpcIiwgbGFuZylcblxuICBpZiAoc2VtaSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKGxhbmcgPT09IFwiSlNcIikgc2VtaSA9IHRydWU7XG4gICAgZWxzZSBpZiAobGFuZyA9PT0gXCJQWVwiKSBzZW1pID0gZmFsc2U7XG4gIH1cblxuICBpZiAocHJldHR5ID09PSB1bmRlZmluZWQpIHtcbiAgICBpZiAobGFuZyA9PT0gXCJKU1wiKSBwcmV0dHkgPSBmYWxzZTtcbiAgICBlbHNlIGlmIChsYW5nID09PSBcIlBZXCIpIHByZXR0eSA9IHRydWU7XG4gIH1cblxuICBsZXQgb3V0ID0gXCJcIjtcbiAgaWYgKGNvbW1lbnQpIHtcbiAgICBpZiAobGFuZyA9PT0gXCJKU1wiKSBvdXQgKz0gXCIvKiBcIiArICh0eXBlb2YgY29tbWVudCA9PT0gXCJzdHJpbmdcIiA/IGNvbW1lbnQgOiBcImRlY2xhcmF0aW9uc1wiKSArIFwiICovXFxuXCI7XG4gICAgaWYgKGxhbmcgPT09IFwiUFlcIikgb3V0ICs9IFwiIyBcIiArICh0eXBlb2YgY29tbWVudCA9PT0gXCJzdHJpbmdcIiA/IGNvbW1lbnQgOiBcImRlY2xhcmF0aW9uc1wiKSArIFwiXFxuXCI7XG4gIH1cbiAgaWYgKCFwcmV0dHkgJiYgbGFuZyA9PT0gXCJKU1wiKSBvdXQgKz0gXCJjb25zdCBcIjtcbiAgdmFycy5mb3JFYWNoKCh7IG5hbWUsIHZhbHVlLCByYXc9ZmFsc2UgfSwgaSkgPT4ge1xuICAgIGlmIChwcmV0dHkpIHtcbiAgICAgIGlmIChpICE9PSAwKSBvdXQgKz0gXCJcXG5cIjtcbiAgICAgIG91dCArPSAobGFuZyA9PT0gXCJKU1wiID8gXCJjb25zdCBcIiA6IFwiXCIpICsgbmFtZSArIFwiPVwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaSAhPT0gMCkge1xuICAgICAgICBpZiAobGFuZyA9PT0gXCJKU1wiKSBvdXQgKz0gXCIsXCI7XG4gICAgICAgIGVsc2UgaWYgKGxhbmcgPT09IFwiUFlcIikgb3V0ICs9IFwiO1wiO1xuICAgICAgfVxuICAgICAgb3V0ICs9IG5hbWUgKyBcIj1cIjsgIFxuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiIHx8IHJhdykge1xuICAgICAgb3V0ICs9IHZhbHVlO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBvdXQgKz0gbWluUXVvdGUodmFsdWUsIHsgYmFja3RpY2s6IGxhbmcgPT09IFwiSlNcIiB9KTtcbiAgICB9XG4gICAgaWYgKHByZXR0eSAmJiBzZW1pKSBvdXQgKz0gXCI7XCI7XG4gIH0pO1xuICBpZiAoc2VtaSAmJiAhcHJldHR5KSBvdXQgKz0gXCI7XCJcbiAgcmV0dXJuIG91dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZGVjbGFyZVZhcnM7XG4iLCJjb25zdCBtaW5RdW90ZSA9IChzdHIsIHsgZGVidWc9ZmFsc2UsIGJhY2t0aWNrPXRydWUgfSA9IHsgYmFja3RpY2s6IGZhbHNlLCBkZWJ1ZzogZmFsc2UgfSkgPT4ge1xuICBpZiAoZGVidWcpIGNvbnNvbGUubG9nKFwiW21pbi1xdW90ZV0gc3RhcnRpbmcgd2l0aCBzdHI6XCIsIFtzdHJdKTtcbiAgbGV0IHF1b3RlY2hhcnMgPSBbXCInXCIsICdcIicsIFwiYFwiXTtcbiAgbGV0IG51bVF1b3RlcyA9IHF1b3RlY2hhcnMubGVuZ3RoO1xuICBsZXQgc2VsZWN0aW9uO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVF1b3RlczsgaSsrKSB7XG4gICAgY29uc3QgY2hhciA9IHF1b3RlY2hhcnNbaV07XG4gICAgaWYgKCFzdHIuaW5jbHVkZXMoY2hhcikpIHtcbiAgICAgIHNlbGVjdGlvbiA9IGNoYXI7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgbGV0IHJlc3VsdDtcbiAgaWYgKHNlbGVjdGlvbikge1xuICAgIHJlc3VsdCA9IHNlbGVjdGlvbiArIHN0ciArIHNlbGVjdGlvbjtcbiAgfSBlbHNlIHtcbiAgICAvLyBjaG9zZSB0aGUgcXVvdGUgdGhhdCB3b3VsZCByZXF1aXJlIHRoZSBsZWFzdCBhbW91bnQgb2YgZXNjYXBpbmdcbiAgICBjb25zdCBjb3VudHMgPSB7IFwiJ1wiOiAwLCAnXCInOiAwLCBcImBcIjogMCB9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjaGFyID0gc3RyW2ldO1xuICAgICAgaWYgKGNoYXIgPT09IFwiJ1wiIHx8IGNoYXIgPT09ICdcIicgfHwgY2hhciA9PT0gXCJgXCIpIHtcbiAgICAgICAgY291bnRzW2NoYXJdKys7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChkZWJ1ZykgY29uc29sZS5sb2coXCJbbWluLXF1b3RlXSBjb3VudHM6XCIsIGNvdW50cyk7XG4gICAgY29uc3Qgc29ydGVkQ291bnRzID0gT2JqZWN0LmVudHJpZXMoY291bnRzKS5zb3J0KChhLCBiKSA9PiBNYXRoLnNpZ24oYVsxXSAtIGJbMV0pKTtcbiAgICBjb25zdCBtaW5Db3VudCA9IHNvcnRlZENvdW50c1swXVsxXTtcbiAgICBjb25zdCBjYW5kaWRhdGVzID0gc29ydGVkQ291bnRzLmZpbHRlcigoW2NoYXIsIGNvdW50XSkgPT4gY291bnQgPT09IG1pbkNvdW50KTtcbiAgICBjb25zdCBub3RCYWNrdGlja3MgPSBjYW5kaWRhdGVzLmZpbHRlcigoW2NoYXIsIGNvdW50XSkgPT4gY2hhciAhPT0gXCJgXCIpO1xuICAgIGlmIChub3RCYWNrdGlja3MubGVuZ3RoID49IDEpIHNlbGVjdGlvbiA9IG5vdEJhY2t0aWNrc1swXVswXTtcbiAgICBlbHNlIHNlbGVjdGlvbiA9IGNhbmRpZGF0ZXNbMF1bMF07XG4gICAgaWYgKGRlYnVnKSBjb25zb2xlLmxvZyhcIlttaW4tcXVvdGVdIHNlbGVjdGlvbjpcIiwgc2VsZWN0aW9uKTtcbiAgICByZXN1bHQgPSBzZWxlY3Rpb24gKyBzdHIucmVwbGFjZShzZWxlY3Rpb24sIFwiXFxcXFwiICsgc2VsZWN0aW9uKSArIHNlbGVjdGlvbjtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuaWYgKHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIpIG1vZHVsZS5leHBvcnRzID0gbWluUXVvdGU7XG5pZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikgd2luZG93Lm1pblF1b3RlID0gbWluUXVvdGU7XG5pZiAodHlwZW9mIHNlbGYgPT09IFwib2JqZWN0XCIpIHNlbGYubWluUXVvdGUgPSBtaW5RdW90ZTsiLCJjb25zdCB7IGZvckVhY2ggfSA9IHJlcXVpcmUoXCJhZHZhcnJcIik7XG5jb25zdCBjb3VudCA9IHJlcXVpcmUoXCJkZWVwLWNvdW50ZXJcIik7XG5jb25zdCBkZWNsYXJlVmFycyA9IHJlcXVpcmUoXCJkZWNsYXJlLXZhcnNcIik7XG5jb25zdCBkZWNvbmNhdCA9IHJlcXVpcmUoXCJkZWNvbmNhdFwiKTtcbmNvbnN0IHdhbGsgPSByZXF1aXJlKFwiZGVlcGVzdC13YWxrXCIpO1xuY29uc3QgY291bnROR3JhbXMgPSByZXF1aXJlKFwibi1ncmFtLWNvdW50ZXJcIik7XG5jb25zdCBtaW5RdW90ZSA9IHJlcXVpcmUoXCJtaW4tcXVvdGVcIik7XG5jb25zdCB7IGdlblZhck5hbWVzIH0gPSByZXF1aXJlKFwidmFyLW5hbWVzXCIpO1xuY29uc3Qgc2VwYXJvID0gcmVxdWlyZShcInNlcGFyb1wiKTtcbmNvbnN0IHN0cmlwdGFncyA9IHJlcXVpcmUoXCJzdHJpcHRhZ3NcIik7XG5cbmNvbnN0IGlzUXVvdGVkID0gKHN0cikgPT4gc3RyLm1hdGNoKC9eKFsnXCJgXSkuKlxcMSQvKTtcblxuY29uc3QgZm9yRWFjaFN0cmluZyA9IChkYXRhLCBjYikgPT4ge1xuICB3YWxrKHtcbiAgICBkYXRhLFxuICAgIGNhbGxiYWNrOiAoeyBkYXRhLCBtb2QsIHR5cGUgfSkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGNiKHsgc3RyOiBkYXRhLCBtb2QsIGRhdGFUeXBlOiB0eXBlIH0pO1xuICAgICAgfVxuICAgIH0sXG4gIH0pO1xufTtcblxuLy8gc3RyaW5nIGluIGNvZGVcbmNvbnN0IHRvU3RyaW5nID0gKGl0KSA9PiB7XG4gIGlmIChpdCA9PT0gbnVsbCkgcmV0dXJuIFwibnVsbFwiO1xuICBlbHNlIGlmIChpdCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gXCJ1bmRlZmluZWRcIjtcbiAgZWxzZSBpZiAodHlwZW9mIGl0ID09PSBcInN0cmluZ1wiKSByZXR1cm4gaXQ7XG4gIGVsc2UgaWYgKHR5cGVvZiBpdCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIGl0LnRvU3RyaW5nKCk7XG4gIGVsc2UgdGhyb3cgbmV3IEVycm9yKFwidG8tc3RyaW5nIGZhaWxlZCBiZWNhdXNlIHVuZXhwZWN0ZWQgdHlwZVwiKTtcbn07XG5cbmNvbnN0IGVuY29kZSA9ICh7IGRhdGEsIGRlYnVnX2xldmVsID0gMCwgbGFuZ3VhZ2U9XCJKYXZhU2NyaXB0XCIsIG1heF9wYXNzZXMgPSAwLCBwcmVmaXgsIHNwYWNlciB9KSA9PiB7XG4gIGlmIChkZWJ1Z19sZXZlbCA+PSAxKSBjb25zb2xlLmxvZyhcIltlbmNvZGVdIHN0YXJ0aW5nXCIpO1xuICBpZiAoZGVidWdfbGV2ZWwgPj0gMikgY29uc29sZS5sb2coXCJbZW5jb2RlXSBkYXRhOlwiLCBKU09OLnN0cmluZ2lmeShkYXRhKS5zdWJzdHJpbmcoMCwgMjAwKSwgXCIuLi5cIik7XG5cbiAgLy8gbm9ybWFsaXppbmcgbGFuZ3VhZ2VcbiAgbGFuZ3VhZ2UgPSBsYW5ndWFnZS50b1VwcGVyQ2FzZSgpO1xuICBsZXQgbGFuZztcbiAgaWYgKGxhbmd1YWdlID09PSBcIkpTXCIgfHwgbGFuZ3VhZ2UgPT09IFwiSkFWQVNDUklQVFwiKSBsYW5nID0gXCJKU1wiO1xuICBlbHNlIGlmIChsYW5ndWFnZSA9PT0gXCJQWVwiIHx8IGxhbmd1YWdlID09PSBcIlBZVEhPTlwiKSBsYW5nID0gXCJQWVwiO1xuXG4gIGlmIChwcmVmaXggPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKGxhbmcgPT09IFwiSlNcIikgcHJlZml4ID0gXCJtb2R1bGUuZXhwb3J0c1wiO1xuICAgIGVsc2UgaWYgKGxhbmcgPT09IFwiUFlcIikgcHJlZml4ID0gXCJkYXRhXCI7XG4gIH1cbiAgXG4gIGNvbnN0IHVzZUJhY2t0aWNrID0gbGFuZyA9PT0gXCJKU1wiO1xuXG4gIGNvbnN0IGNvdW50cyA9IGNvdW50KHsgZGF0YSwgZGVidWdfbGV2ZWw6IGRlYnVnX2xldmVsIC0gMSB9KTtcbiAgaWYgKGRlYnVnX2xldmVsID49IDEpIGNvbnNvbGUubG9nKFwiY291bnRzOlwiLCBjb3VudHMpO1xuXG4gIGNvbnN0IHN0cmluZ2lmaWVkID0gdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgPyBkYXRhIDogSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gIGlmIChkZWJ1Z19sZXZlbCA+PSAxKSBjb25zb2xlLmxvZyhcIltlbmNvZGVdIHN0cmluZ2lmaWVkOlwiLCBzdHJpbmdpZmllZC5zdWJzdHJpbmcoMCwgMjAwKSwgXCIuLi5cIik7XG5cbiAgLyogZ2VuZXJhdGUgYSBVSUQgZm9yIHRleHQgb3BlcmF0aW9ucyAqL1xuICBsZXQgdWlkO1xuICB3aGlsZSAoIXVpZCkge1xuICAgIGNvbnN0IG51bSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDFlNSkudG9TdHJpbmcoKTtcbiAgICBpZiAoIXN0cmluZ2lmaWVkLmluY2x1ZGVzKG51bSkpIHVpZCA9IG51bTtcbiAgfVxuICBpZiAoZGVidWdfbGV2ZWwgPj0gMSkgY29uc29sZS5sb2coXCJ1aWQ6XCIsIHVpZCk7XG5cbiAgLy8gYSBudW1iZXIgaXMgYWx3YXlzIHRoZSBmaXJzdCBhbmQgbGFzdCBiZWNhdXNlIHRoZXJlJ3Mgbm90IHN1Y2ggdGhpbmcgYXMgYSBzdWItbnVtYmVyICh1bmxpa2UgYSBzdWItc3RyaW5nKVxuICBjb25zdCBudW1iZXJfY291bnRzID0gT2JqZWN0LnZhbHVlcyhjb3VudHMubnVtYmVycykubWFwKChpdCkgPT4gKHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIHZhbHVlOiBpdC52YWx1ZSxcbiAgICBjb3VudDogaXQuY291bnQsXG4gIH0pKTtcblxuICBjb25zdCBzdHJpbmdfY291bnRzID0gT2JqZWN0LnZhbHVlcyhjb3VudHMuc3RyaW5ncykubWFwKChpdCkgPT4gKHtcbiAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgIHZhbHVlOiBpdC52YWx1ZSxcbiAgICBjb3VudDogaXQuY291bnQsXG4gICAgZmlyc3Q6IGl0LmZpcnN0LFxuICAgIGxhc3Q6IGl0Lmxhc3QsXG4gIH0pKTtcblxuICBjb25zdCBhbGxfY291bnRzID0gWy4uLm51bWJlcl9jb3VudHMsIC4uLnN0cmluZ19jb3VudHNdO1xuICBpZiAoY291bnRzLm51bGwpIHtcbiAgICBhbGxfY291bnRzLnB1c2goe1xuICAgICAgdHlwZTogXCJudWxsXCIsXG4gICAgICB2YWx1ZTogbnVsbCxcbiAgICAgIGNvdW50OiBjb3VudHMubnVsbCxcbiAgICB9KTtcbiAgfVxuICBpZiAoY291bnRzLnVuZGVmaW5lZCkge1xuICAgIGFsbF9jb3VudHMucHVzaCh7XG4gICAgICB0eXBlOiBcInVuZGVmaW5lZFwiLFxuICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgIGNvdW50OiBjb3VudHMudW5kZWZpbmVkLFxuICAgIH0pO1xuICB9XG5cbiAgY29uc3Qgc29ydGVkX2NvdW50cyA9IGFsbF9jb3VudHMuc29ydCgoYSwgYikgPT4gTWF0aC5zaWduKGIuY291bnQgLSBhLmNvdW50KSk7XG4gIGlmIChkZWJ1Z19sZXZlbCA+PSAxKSBjb25zb2xlLmxvZyhcIltlbmNvZGVdIHNvcnRlZCBjb3VudHNcIik7XG4gIGlmIChkZWJ1Z19sZXZlbCA+PSAyKSBjb25zb2xlLmxvZyhcIltlbmNvZGVdIHNvcnRlZF9jb3VudHM6XCIsIHNvcnRlZF9jb3VudHMpO1xuXG4gIGNvbnN0IHRva2VucyA9IHNvcnRlZF9jb3VudHMubWFwKChpdCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBpZiAoZGVidWdfbGV2ZWwgPj0gMikgY29uc29sZS5sb2coXCJpdDpcIiwgaXQpO1xuXG4gICAgICBjb25zdCB7IHZhbHVlLCBjb3VudCwgdHlwZSB9ID0gaXQ7XG5cbiAgICAgIGNvbnN0IHZhbHVlX3N0cmluZyA9IHRvU3RyaW5nKHZhbHVlKTtcblxuICAgICAgaWYgKFtcIm51bGxcIiwgXCJudW1iZXJcIiwgXCJ1bmRlZmluZWRcIl0uaW5jbHVkZXModHlwZSkpIHtcbiAgICAgICAgY29uc3QgdmFsdWVfbGVuZ3RoID0gdmFsdWVfc3RyaW5nLmxlbmd0aDtcbiAgICAgICAgY29uc3QgY3VycmVudF9jb3N0ID0gY291bnQgKiB2YWx1ZV9sZW5ndGg7XG4gICAgICAgIGNvbnN0IHNhdmluZ3MgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgdmFyaWFibGVfbGVuZ3RoID0gMTsgdmFyaWFibGVfbGVuZ3RoIDw9IDU7IHZhcmlhYmxlX2xlbmd0aCsrKSB7XG4gICAgICAgICAgLy8gbGlrZSAsQT0xMjM7IG9yICxCYT1udWxsIG9yICxBYj11bmRlZmluZWQ7XG4gICAgICAgICAgY29uc3QgZGVjbGFyYXRpb25fY29zdCA9IDEgKyB2YXJpYWJsZV9sZW5ndGggKyAxICsgdmFsdWVfbGVuZ3RoO1xuICAgICAgICAgIGNvbnN0IHJlcGxhY2VtZW50X2Nvc3QgPSBkZWNsYXJhdGlvbl9jb3N0ICsgY291bnQgKiB2YXJpYWJsZV9sZW5ndGg7XG4gICAgICAgICAgc2F2aW5nc1t2YXJpYWJsZV9sZW5ndGhdID0gY3VycmVudF9jb3N0IC0gcmVwbGFjZW1lbnRfY29zdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB2YWx1ZSwgY291bnQsIHNhdmluZ3MgfTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjb25zdCB7IGZpcnN0LCBsYXN0IH0gPSBpdDtcbiAgICAgICAgY29uc3QgcGVyY2VudF9zdGFydCA9IGZpcnN0IC8gY291bnQ7XG4gICAgICAgIGNvbnN0IHBlcmNlbnRfZW5kID0gbGFzdCAvIGNvdW50O1xuICAgICAgICBjb25zdCBub3RfcGVyY2VudF9zdGFydCA9IDEgLSBwZXJjZW50X3N0YXJ0O1xuICAgICAgICBjb25zdCBub3RfcGVyY2VudF9lbmQgPSAxIC0gcGVyY2VudF9lbmQ7XG5cbiAgICAgICAgLy8gaWYgaXQgaXMgYWx3YXlzIHByZWNlZWRlZCBieSBhIHNwYWNlLCB3ZSB3aWxsIGxhdGVyIHByZXBlbmQgYSBcIiBcIiBzcGFjZVxuICAgICAgICBjb25zdCBwYWQgPSBmaXJzdCA9PT0gMDtcbiAgICAgICAgaWYgKGRlYnVnX2xldmVsID49IDIpIGNvbnNvbGUubG9nKFwicGFkOlwiLCBwYWQpO1xuXG4gICAgICAgIC8vIGhvdyBtYW55IGNoYXJhY3RlcnMgdGhlIGN1cnJlbnQgdmFsdWUgdGFrZXMgdXBcbiAgICAgICAgY29uc3QgdmFsdWVfbGVuZ3RoID0gYCR7cGFkID8gXCIgXCIgOiBcIlwifSR7dmFsdWVfc3RyaW5nfWAubGVuZ3RoO1xuICAgICAgICBpZiAoZGVidWdfbGV2ZWwgPj0gMikgY29uc29sZS5sb2coXCJ2YWx1ZV9sZW5ndGg6XCIsIHZhbHVlX2xlbmd0aCk7XG5cbiAgICAgICAgY29uc3QgY3VycmVudF9jb3N0ID0gY291bnQgKiB2YWx1ZV9sZW5ndGg7XG4gICAgICAgIGlmIChkZWJ1Z19sZXZlbCA+PSAyKSBjb25zb2xlLmxvZyhcImN1cnJlbnRfY29zdDpcIiwgY3VycmVudF9jb3N0KTtcblxuICAgICAgICBjb25zdCBzYXZpbmdzID0ge307XG4gICAgICAgIGZvciAobGV0IHZhcmlhYmxlX2xlbmd0aCA9IDE7IHZhcmlhYmxlX2xlbmd0aCA8PSA1OyB2YXJpYWJsZV9sZW5ndGgrKykge1xuICAgICAgICAgIC8vIGxpa2UgLEE9Jytsb25fMD0xMDUnXG4gICAgICAgICAgbGV0IGRlY2xhcmF0aW9uX2xlbmd0aCA9IDEgKyB2YXJpYWJsZV9sZW5ndGggKyAxICsgMSArIHZhbHVlX2xlbmd0aCArIDE7XG5cbiAgICAgICAgICAvLyBub3QgZmFjdG9yaW5nIGluIHRoYXQgc3RyaW5ncyBjYW4gYmUga2V5cyBhcyB3ZWxsXG4gICAgICAgICAgLy8gd2lsbCBuZWVkIHRvIHVwZ3JhZGUgZGVlcC1jb3VudGVyIHRvIHRyYWNrIGFkZGl0aW9uYWwgc3RhdHMgbGlrZSBpcyB0aGUgc3RyaW5nIGEgY29tcGxldGUga2V5LCBpcyB0aGUgc3RyaW5nIHBhcnQgb2YgYSBrZXkgYW5kIHBvc2l0aW9uLCBhbmQgaXMgc3RyaW5nIGEgc3Vic3RyaW5nIGluIGEgc3RyaW5nXG4gICAgICAgICAgLy8gYWxzbyBuZWVkIHRvIGZhY3RvciBpbiB3aGV0aGVyIHRvIHByZXBlbmQgc3BhY2Ugb3Igbm90XG4gICAgICAgICAgLy8gPz8gbWF5YmUgc2hvdWxkIGZhY3RvciBpbiBhc3N1bWluZyBzdHJpbmdzIGFyZSByZXBsYWNlZCBiZWZvcmUgYW5kIGFmdGVyIHdpdGggdmFyaWFibGVzID8/XG4gICAgICAgICAgY29uc3QgYXZlcmFnZV9yZXBsYWNlbWVudF9sZW5ndGggPSBgXCIrYC5sZW5ndGggKiBub3RfcGVyY2VudF9zdGFydCArIHZhcmlhYmxlX2xlbmd0aCArIGBcIitgLmxlbmd0aCAqIG5vdF9wZXJjZW50X2VuZDtcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcImF2ZXJhZ2VfcmVwbGFjZW1lbnRfbGVuZ3RoOlwiLCBhdmVyYWdlX3JlcGxhY2VtZW50X2xlbmd0aCk7XG5cbiAgICAgICAgICBjb25zdCB0b3RhbF9yZXBsYWNlbWVudF9zaXplID0gZGVjbGFyYXRpb25fbGVuZ3RoICsgYXZlcmFnZV9yZXBsYWNlbWVudF9sZW5ndGggKiBjb3VudDtcbiAgICAgICAgICBpZiAoZGVidWdfbGV2ZWwgPj0gMykgY29uc29sZS5sb2coXCJ0b3RhbF9yZXBsYWNlbWVudF9zaXplOlwiLCB0b3RhbF9yZXBsYWNlbWVudF9zaXplKTtcbiAgICAgICAgICBzYXZpbmdzW3ZhcmlhYmxlX2xlbmd0aF0gPSBjdXJyZW50X2Nvc3QgLSB0b3RhbF9yZXBsYWNlbWVudF9zaXplO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWJ1Z19sZXZlbCA+PSAyKSBjb25zb2xlLmxvZyhcInNhdmluZ3M6XCIsIHNhdmluZ3MpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHZhbHVlOiAocGFkID8gXCIgXCIgOiBcIlwiKSArIGl0LnZhbHVlLFxuICAgICAgICAgIGNvdW50OiBjb3VudCxcbiAgICAgICAgICBmaXJzdCxcbiAgICAgICAgICBsYXN0LFxuICAgICAgICAgIHBhZCxcbiAgICAgICAgICBzYXZpbmdzLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH0pO1xuICBpZiAoZGVidWdfbGV2ZWwgPj0gMSkgY29uc29sZS5sb2codG9rZW5zKTtcblxuICBjb25zdCBza2lwVmFyTmFtZXMgPSBuZXcgU2V0KCk7XG4gIGlmIChsYW5nID09PSBcIlBZXCIpIHtcbiAgICBbJ2FuZCcsICdhcycsICdpcycsICdvcicsICdudWxsJ10uZm9yRWFjaChza2lwd29yZCA9PiB7XG4gICAgICBza2lwVmFyTmFtZXMuYWRkKHNraXB3b3JkKTtcbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0IHZhcm5hbWUydG9rZW4gPSBuZXcgTWFwKCk7XG4gIGNvbnN0IHRva2VuMnZhcm5hbWUgPSBuZXcgTWFwKCk7XG5cbiAgY29uc3QgZ2VuID0gZ2VuVmFyTmFtZXMoKTtcbiAgZm9yIChjb25zdCB2YXJuYW1lIG9mIGdlbikge1xuICAgIGlmIChkZWJ1Z19sZXZlbCA+PSAyKSBjb25zb2xlLmxvZyhcInZhcm5hbWU6XCIsIHZhcm5hbWUpO1xuICAgIGlmIChza2lwVmFyTmFtZXMuaGFzKHZhcm5hbWUpKSBjb250aW51ZTtcblxuICAgIGNvbnN0IHZhcmxlbiA9IHZhcm5hbWUubGVuZ3RoO1xuXG4gICAgLy8gc29ydCB0b2tlbnMgYnkgc2F2aW5nIGZvciB0aGUgZ2l2ZW4gdmFyaWFibGUncyBsZW5ndGhcbiAgICB0b2tlbnMuc29ydCgoYSwgYikgPT4gTWF0aC5zaWduKGIuc2F2aW5nc1t2YXJsZW5dIC0gYS5zYXZpbmdzW3Zhcmxlbl0pKTtcblxuICAgIC8vIHBvcCBvdXQgdGhlIGZpcnN0IHRva2VuXG4gICAgY29uc3QgdG9rZW4gPSB0b2tlbnMuc2hpZnQoKTtcblxuICAgIC8vIGlmIHdlIGNhbiBzYXZlIGFueSBzcGFjZSB3aXRoIHRoZSB0b2tlbiB3aXRoIHRoZSBtb3N0IHBvdGVudGlhbCBzYXZpbmdzLCBicmVha1xuICAgIGlmICh0b2tlbi5zYXZpbmdzW3Zhcmxlbl0gPD0gMCkgYnJlYWs7XG5cbiAgICAvLyBjb25zb2xlLmxvZyhcInRva2VuOlwiLCB0b2tlbik7XG4gICAgLy8gc2F2ZSB0aGUgc2VsZWN0aW9uXG5cbiAgICB2YXJuYW1lMnRva2VuLnNldCh2YXJuYW1lLCB7IGZpcnN0OiB0b2tlbi5maXJzdCwgdG9rZW46IHRva2VuLnZhbHVlIH0pO1xuICAgIHRva2VuMnZhcm5hbWUuc2V0KHRva2VuLnZhbHVlLCB7IHZhcm5hbWUsIGZpcnN0OiB0b2tlbi5maXJzdCwgdmFsdWU6IHRva2VuLnZhbHVlIH0pO1xuICB9XG4gIGlmIChkZWJ1Z19sZXZlbCA+PSAxKSBjb25zb2xlLmxvZyhcImFzc2lnbmVkIHZhcmlhYmxlIG5hbWVzIHRvIHRva2Vuc1wiKTtcbiAgaWYgKGRlYnVnX2xldmVsID49IDIpIGNvbnNvbGUubG9nKFwidG9rZW4ybmFtZTpcIiwgdG9rZW4ydmFybmFtZSk7XG5cbiAgLy8gY29uc29sZS5sb2coXCJ2YXJuYW1lMnRva2VuWydVJ106XCIsIHZhcm5hbWUydG9rZW5bJ1UnXSk7XG5cbiAgLy8gZ2V0IGEgY2xvbmUgb2YgdGhlIG9yaWdpbmFsIGRhdGFcbiAgY29uc3QgcmVzdWx0ID0gSlNPTi5wYXJzZShzdHJpbmdpZmllZCk7XG4gIGlmIChkZWJ1Z19sZXZlbCA+PSAxKSBjb25zb2xlLmxvZyhcImNsb25lZCBvcmlnaW5hbCBkYXRhXCIpO1xuICBpZiAoZGVidWdfbGV2ZWwgPj0gMikgY29uc29sZS5sb2coXCJjbG9uZWQgZGF0YTpcIiwgcmVzdWx0KTtcblxuICAvKlxuICAgIHN0cmluZyBvcGVyYXRpb25zXG4gICAgPGRlbHByZXY+IC0gZGVsZXRlcyBwcmV2aW91cyBjaGFyYWN0ZXJcbiAgICA8ZGVsbmV4dD4gLSBkZWxldGVzIG5leHQgY2hhcmFjdGVyXG4gICovXG4gIGNvbnN0IGRlbHByZXYgPSBgPGRlbHByZXYtJHt1aWR9PmA7XG4gIGNvbnN0IGRlbG5leHQgPSBgPGRlbG5leHQtJHt1aWR9PmA7XG5cbiAgY29uc3QgbG9va3VwID0gKHgpID0+IHtcbiAgICBsZXQgdmFybmFtZTtcbiAgICBsZXQgdmFydmFsdWU7XG4gICAgaWYgKHRva2VuMnZhcm5hbWUuaGFzKHgpKSB7XG4gICAgICB2YXJuYW1lID0gdG9rZW4ydmFybmFtZS5nZXQoeCkudmFybmFtZTtcbiAgICAgIHZhcnZhbHVlID0geDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB4ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBpZiAoeC5zdGFydHNXaXRoKFwiIFwiKSAmJiB0b2tlbjJ2YXJuYW1lLmhhcyh4LnN1YnN0cigxKSkpIHtcbiAgICAgICAgdmFybmFtZSA9IHRva2VuMnZhcm5hbWUuZ2V0KHguc3Vic3RyKDEpKS52YXJuYW1lO1xuICAgICAgICB2YXJ2YWx1ZSA9IHguc3Vic3RyKDEpO1xuICAgICAgfSBlbHNlIGlmICgheC5zdGFydHNXaXRoKFwiIFwiKSAmJiB0b2tlbjJ2YXJuYW1lLmdldChcIiBcIiArIHgpKSB7XG4gICAgICAgIHZhcm5hbWUgPSB0b2tlbjJ2YXJuYW1lLmdldChcIiBcIiArIHgpLnZhcm5hbWU7XG4gICAgICAgIHZhcnZhbHVlID0gXCIgXCIgKyB4O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyB2YXJuYW1lLCB2YXJ2YWx1ZSB9O1xuICB9O1xuXG4gIGNvbnN0IGdldFZhck91dCA9ICh7IHN1YnN0ciwgdmFybmFtZSwgdmFydmFsdWUgfSkgPT4ge1xuICAgIC8vIGNvbnNvbGUubG9nKFwic3RhcnRpbmcgZ2V0VmFyT3V0IHdpdGg6XCIsIHsgc3Vic3RyLCB2YXJuYW1lLCB2YXJ2YWx1ZSB9KTtcbiAgICBpZiAoc3Vic3RyLnN0YXJ0c1dpdGgoXCIgXCIpKSB7XG4gICAgICBpZiAodmFydmFsdWUuc3RhcnRzV2l0aChcIiBcIikpIHtcbiAgICAgICAgcmV0dXJuIHZhcm5hbWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYFwiIFwiKyR7dmFybmFtZX1gO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodmFydmFsdWUuc3RhcnRzV2l0aChcIiBcIikpIHtcbiAgICAgICAgaWYgKGxhbmcgPT09IFwiSlNcIikge1xuICAgICAgICAgIHJldHVybiBgJHt2YXJuYW1lfS50cmltKClgO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBgJHt2YXJuYW1tZX0uc3RyaXAoKWA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YXJuYW1lO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBjb25zdCB1bmVzY3AgPSAoc3RyKSA9PlxuICAgIHN0ci5yZXBsYWNlQWxsKCdcIicsIChtYXRjaCwgb2Zmc2V0LCBzdHJpbmcpID0+IHtcbiAgICAgIGNvbnN0IGJlZm9yZSA9IHN0cmluZy5zdWJzdHJpbmcoMCwgb2Zmc2V0KTtcbiAgICAgIC8vIGNvbnNvbGUubG9nKHttYXRjaCwgb2Zmc2V0LCBzdHJpbmcsIGJlZm9yZX0pO1xuICAgICAgaWYgKGJlZm9yZS5lbmRzV2l0aChkZWxuZXh0KSkgcmV0dXJuICdcIic7XG4gICAgICBlbHNlIHJldHVybiBkZWxuZXh0ICsgJ1wiJztcbiAgICB9KTtcblxuICBjb25zdCBnZXRFeHByID0gKHN0cikgPT4ge1xuICAgIGNvbnN0IHsgdmFybmFtZSwgdmFydmFsdWUgfSA9IGxvb2t1cChzdHIpO1xuICAgIGlmICh2YXJuYW1lKSByZXR1cm4gZ2V0VmFyT3V0KHsgc3Vic3RyOiBzdHIsIHZhcm5hbWUsIHZhcnZhbHVlIH0pO1xuICB9O1xuXG4gIGlmIChkZWJ1Z19sZXZlbCA+PSAxKSBjb25zb2xlLmxvZyhcInN0YXJ0aW5nIHdhbGtcIik7XG5cbiAgd2Fsayh7XG4gICAgZGF0YTogcmVzdWx0LFxuICAgIGNhbGxiYWNrOiAoeyBkYXRhOiBpdCwgbW9kLCB0eXBlOiBkYXRhVHlwZSB9KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoZGVidWdfbGV2ZWwgPj0gMikgY29uc29sZS5sb2coXCJ3YWxraW5nXCIsIHsgaXQsIGRhdGFUeXBlIH0pO1xuICAgICAgICBpZiAodHlwZW9mIGl0ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgY29uc3QgeyB2YXJuYW1lIH0gPSBsb29rdXAoaXQpO1xuICAgICAgICAgIGlmICh2YXJuYW1lKSBtb2QoZGVscHJldiArIHZhcm5hbWUgKyBkZWxuZXh0KTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaXQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICBjb25zdCBleHByID0gZ2V0RXhwcihpdCk7XG4gICAgICAgICAgaWYgKGV4cHIpIG1vZChleHByKTtcbiAgICAgICAgICBlbHNlIG1vZChkZWxwcmV2ICsgXCJ1bmRlZmluZWRcIiArIGRlbG5leHQpOyAgXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGl0ID09PSBcIm51bGxcIikge1xuICAgICAgICAgIGNvbnN0IGV4cHIgPSBnZXRFeHByKGl0KTtcbiAgICAgICAgICBpZiAoZXhwcikgbW9kKGV4cHIpO1xuICAgICAgICAgIGVsc2UgbW9kKGRlbHByZXYgKyBcIm51bGxcIiArIGRlbG5leHQpOyAgXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGl0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgaWYgKFtcIm9iamVjdC1rZXktc3RyaW5nXCIsIFwib2JqZWN0LXZhbHVlLXN0cmluZ1wiLCBcImFycmF5LWl0ZW0tc3RyaW5nXCJdLmluY2x1ZGVzKGRhdGFUeXBlKSkge1xuICAgICAgICAgICAgY29uc3Qgd29yZHMgPSBzZXBhcm8oaXQsIFwiIFwiLCB7IGF0dGFjaFNlcDogdHJ1ZSB9KS5tYXAoKHdvcmQpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgZXhwciA9IGdldEV4cHIod29yZCk7XG4gICAgICAgICAgICAgIGlmIChleHByKSByZXR1cm4geyBleHByIH07XG4gICAgICAgICAgICAgIGVsc2UgcmV0dXJuIHsgcXVvdGVkOiBtaW5RdW90ZSh3b3JkLCB7IGJhY2t0aWNrOiB1c2VCYWNrdGljayB9KSB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAod29yZHMuc29tZSgod29yZCkgPT4gd29yZC5leHByKSkge1xuICAgICAgICAgICAgICBsZXQgbW9kU3RyID0gZGVscHJldjtcbiAgICAgICAgICAgICAgaWYgKGRhdGFUeXBlID09PSBcIm9iamVjdC1rZXktc3RyaW5nXCIgJiYgbGFuZyA9PT0gXCJKU1wiKSBtb2RTdHIgKz0gXCJbXCI7XG4gICAgICAgICAgICAgIGZvckVhY2god29yZHMsICh7IGl0OiB3b3JkLCBwcmV2LCBmaXJzdDogZmlyc3RXb3JkIH0pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAod29yZC5leHByKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIWZpcnN0V29yZCkgbW9kU3RyICs9IFwiK1wiO1xuICAgICAgICAgICAgICAgICAgbW9kU3RyICs9IHdvcmQuZXhwcjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgLy8gY3VycmVudCB3b3JkIGFuZCBwcmV2aW91cyB3b3JkIHVzZSB0aGUgc2FtZSBxdW90ZXNcbiAgICAgICAgICAgICAgICAgIGlmICh3b3JkLnF1b3RlZFswXSA9PT0gcHJldj8ucXVvdGVkPy5bMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kU3RyID0gbW9kU3RyLnNsaWNlKDAsIC0xKSArIHdvcmQucXVvdGVkLnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gMiBzdHJpbmdzIGluIGEgcm93IHRoYXQgc2hhcmUgZGlmZmVyZW50IHF1b3Rlc1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZpcnN0V29yZCkgbW9kU3RyICs9IFwiK1wiO1xuICAgICAgICAgICAgICAgICAgICBtb2RTdHIgKz0gd29yZC5xdW90ZWQ7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaWYgKGRhdGFUeXBlID09PSBcIm9iamVjdC1rZXktc3RyaW5nXCIgJiYgbGFuZyA9PT0gXCJKU1wiKSBtb2RTdHIgKz0gXCJdXCI7XG4gICAgICAgICAgICAgIG1vZFN0ciArPSBkZWxuZXh0O1xuICAgICAgICAgICAgICBtb2QodW5lc2NwKG1vZFN0cikpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbW9kKGRlbHByZXYgKyB1bmVzY3AobWluUXVvdGUoaXQsIHsgYmFja3RpY2s6IHVzZUJhY2t0aWNrIH0pKSArIGRlbG5leHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIml0OlwiLCB7IGl0LCBkYXRhVHlwZSB9KTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInVuZXhwZWN0ZWQgZGF0YVR5cGU6XCIsIGRhdGFUeXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJ3YWxraW5nIGVycm9yXCIsIGVycm9yKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfSxcbiAgfSk7XG5cbiAgLypcbiAgICBBcnJheSB0byBob2xkIHZhcmlhYmxlcyBjcmVhdGVkIGZyb20gdGhlIGNvbmNhdGVuYXRpb24gb2Ygb3RoZXIgdmFyc1xuICAgIEZvciBleGFtcGxlIEE9QitDXG4gICAgQW5kIHRoZSBvcmRlciBpcyBpbXBvcnRhbnRcbiAgKi9cblxuICBjb25zdCB1c2VkVmFyTmFtZXMgPSBuZXcgU2V0KHZhcm5hbWUydG9rZW4ua2V5cygpKTtcbiAgY29uc3QgYWN0dWFsX2JpZ3JhbV90b192YXJuYW1lX3Bhc3NlcyA9IFtdO1xuICBmb3IgKGxldCBwYXNzID0gMDsgcGFzcyA8IG1heF9wYXNzZXMgLSAxOyBwYXNzKyspIHtcbiAgICBjb25zdCBhY3R1YWxfYmlncmFtX3RvX3Zhcm5hbWUgPSB7fTtcbiAgICAvLyBnZXQgYW4gYXJyYXkgb2YgbmV3IHZhcm5hbWVzIG9mIGFsbCB0aGUgc2FtZSBsZW5ndGggKGkuZS4gY29zdClcbiAgICBjb25zdCB2YXJuYW1lcyA9IFtdO1xuICAgIGxldCB2YXJsZW47XG4gICAgY29uc3QgdmFyTmFtZUdlbiA9IGdlblZhck5hbWVzKCk7XG4gICAgZm9yIChjb25zdCB2YXJuYW1lIG9mIHZhck5hbWVHZW4pIHtcbiAgICAgIGlmICh1c2VkVmFyTmFtZXMuaGFzKHZhcm5hbWUpKSBjb250aW51ZTtcbiAgICAgIGlmIChza2lwVmFyTmFtZXMuaGFzKHZhcm5hbWUpKSBjb250aW51ZTtcbiAgICAgIGlmICghdmFybGVuKSB2YXJsZW4gPSB2YXJuYW1lLmxlbmd0aDtcbiAgICAgIGlmICh2YXJuYW1lLmxlbmd0aCAhPT0gdmFybGVuKSBicmVhaztcbiAgICAgIHZhcm5hbWVzLnB1c2godmFybmFtZSk7XG4gICAgfVxuXG4gICAgLy8gY2xlYW4gdGV4dCBvcHMgZnJvbSBzdHJpbmdzXG4gICAgY29uc3QgYmlncmFtX2NvdW50ID0ge307XG5cbiAgICAvLyB3ZSBhbHJlYWR5IHJlcGxhY2VkIG51bWJlcnMsIG51bGxzLCBhbmQgdW5kZWZpbmVkcyBpbiB0aGUgZmlyc3QgcGFzc1xuICAgIC8vIHNvIHdlIGNhbiBqdXN0IGZvY3VzIG9uIHN0cmluZ3NcbiAgICBmb3JFYWNoU3RyaW5nKHJlc3VsdCwgKHsgc3RyIH0pID0+IHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKFwic3RyaW5nOlwiLCBbc3RyXSk7XG4gICAgICAvLyByZW1vdmUgYW55IHRleHQgb3BlcmF0aW9ucyBsaWtlIGRlbHByZXYgYW5kIGRlbG5leHRcbiAgICAgIHN0ciA9IHN0cmlwdGFncyhzdHIpO1xuXG4gICAgICAvLyByZW1vdmUgWyAuLi4gXVxuICAgICAgc3RyID0gc3RyLnJlcGxhY2UoL15cXFsvLCBcIlwiKS5yZXBsYWNlKC9cXF0kLywgXCJcIik7XG5cbiAgICAgIGNvbnN0IHBhcnRzID0gZGVjb25jYXQoc3RyKTtcbiAgICAgIC8vIGNvbnNvbGUubG9nKFwicGFydHM6XCIsIHBhcnRzKVxuXG4gICAgICBjb25zdCBiaWdyYW1zID0gY291bnROR3JhbXMoeyBkYXRhOiBwYXJ0cywgbjogMiB9KTtcblxuICAgICAgZm9yIChsZXQgYiA9IDA7IGIgPCBiaWdyYW1zLmxlbmd0aDsgYisrKSB7XG4gICAgICAgIGNvbnN0IFtiaWdyYW0sIHN1YmNvdW50XSA9IGJpZ3JhbXNbYl07XG4gICAgICAgIGNvbnN0IFtmaXJzdCwgc2Vjb25kXSA9IGJpZ3JhbTtcblxuICAgICAgICAvLyBpZ25vcmUgYmlncmFtcyB0aGF0IGluY2x1ZGUgYSBzdHJpbmdzXG4gICAgICAgIGlmIChpc1F1b3RlZChmaXJzdCkgfHwgaXNRdW90ZWQoc2Vjb25kKSkgY29udGludWU7XG5cbiAgICAgICAgY29uc3Qga2V5ID0gSlNPTi5zdHJpbmdpZnkoYmlncmFtKTtcbiAgICAgICAgaWYgKGtleSBpbiBiaWdyYW1fY291bnQpIGJpZ3JhbV9jb3VudFtrZXldWzFdICs9IHN1YmNvdW50O1xuICAgICAgICBlbHNlIGJpZ3JhbV9jb3VudFtrZXldID0gW2JpZ3JhbSwgc3ViY291bnRdO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgYmlncmFtX3NhdmluZ3MgPSBbXTtcbiAgICBPYmplY3QudmFsdWVzKGJpZ3JhbV9jb3VudCkuZm9yRWFjaCgoW2JpZ3JhbSwgY291bnRdKSA9PiB7XG4gICAgICAvLyBiaWdyYW0gaXMgbGlrZSBbICdFJywgJ0EnIF1cbiAgICAgIGNvbnN0IGxlbiA9IGJpZ3JhbS5qb2luKFwiK1wiKS5sZW5ndGg7XG4gICAgICBjb25zdCBjdXJyZW50X2Nvc3QgPSBsZW4gKiBjb3VudDtcbiAgICAgIC8vIGRlY2xhcmF0aW9uIGNvc3QgaXMgLCArIHZhcmlhYmxlICsgPSArIGxlblxuICAgICAgY29uc3QgZGVjbGFyYXRpb25fY29zdCA9IDEgKyB2YXJsZW4gKyAxICsgbGVuO1xuICAgICAgY29uc3QgcmVwbGFjZW1lbnRfY29zdCA9IGRlY2xhcmF0aW9uX2Nvc3QgKyB2YXJsZW4gKiBjb3VudDtcbiAgICAgIGNvbnN0IHNhdmluZ3MgPSBjdXJyZW50X2Nvc3QgLSByZXBsYWNlbWVudF9jb3N0O1xuXG4gICAgICAvLyBvbmx5IGNhcmUgaWYgYWN0dWFsbHkgc2F2ZSBzcGFjZVxuICAgICAgaWYgKHNhdmluZ3MgPiAwKSBiaWdyYW1fc2F2aW5ncy5wdXNoKFtiaWdyYW0sIHNhdmluZ3NdKTtcbiAgICB9KTtcblxuICAgIC8vIG5vIG1vcmUgb3Bwb3J0dW5pdGllcyB0byBzYXZlIHNwYWNlXG4gICAgaWYgKGJpZ3JhbV9zYXZpbmdzLmxlbmd0aCA9PT0gMCkgYnJlYWs7XG5cbiAgICAvLyBzb3J0IGJpZ3JhbSBzYXZpbmdzIGFycmF5IGZyb20gc21hbGxlc3QgdG8gbGFyZ2VzdCBzYXZpbmdzXG4gICAgYmlncmFtX3NhdmluZ3Muc29ydCgoYSwgYikgPT4gTWF0aC5zaWduKGFbMV0gLSBiWzFdKSk7XG5cbiAgICAvLyBjb25zb2xlLmxvZyhcImJpZ3JhbV9zYXZpbmdzXCIsIGJpZ3JhbV9zYXZpbmdzKVxuXG4gICAgLy8gYXNzaWduIGJpZ3JhbXMgdG8gdmFybmFtZXNcbiAgICBjb25zdCBiaWdyYW1fdG9fdmFybmFtZSA9IHt9O1xuICAgIGZvciAobGV0IHYgPSAwOyB2IDwgdmFybmFtZXMubGVuZ3RoOyB2KyspIHtcbiAgICAgIGNvbnN0IHZhcm5hbWUgPSB2YXJuYW1lc1t2XTtcbiAgICAgIC8vIGNvbnNvbGUubG9nKFwidmFybmFtZTpcIiwgdmFybmFtZSk7XG4gICAgICBjb25zdCBbYmlncmFtLCBzYXZpbmdzXSA9IGJpZ3JhbV9zYXZpbmdzLnBvcCgpO1xuICAgICAgY29uc3Qga2V5ID0gSlNPTi5zdHJpbmdpZnkoYmlncmFtKTtcbiAgICAgIGJpZ3JhbV90b192YXJuYW1lW2tleV0gPSB7IGJpZ3JhbSwgdmFybmFtZSwgc2F2aW5ncyB9O1xuICAgICAgaWYgKGJpZ3JhbV9zYXZpbmdzLmxlbmd0aCA9PT0gMCkgYnJlYWs7XG4gICAgfVxuICAgIC8vIGNvbnNvbGUubG9nKFwiYmlncmFtX3RvX3Zhcm5hbWU6XCIsIGJpZ3JhbV90b192YXJuYW1lKTtcblxuICAgIC8vIHdhbGsgdGhyb3VnaCBkYXRhIGFuZCBzZWUgaWYgcmVwbGFjZW1lbnQgb3Bwb3J0dW5pdGllc1xuICAgIGZvckVhY2hTdHJpbmcocmVzdWx0LCAoeyBzdHIsIG1vZCwgZGF0YVR5cGUgfSkgPT4ge1xuICAgICAgY29uc3QgaGFzRGVsUHJldiA9IHN0ci5zdGFydHNXaXRoKGRlbHByZXYpO1xuICAgICAgY29uc3QgaGFzRGVsTmV4dCA9IHN0ci5lbmRzV2l0aChkZWxuZXh0KTtcblxuICAgICAgaWYgKGRhdGFUeXBlID09PSBcImFycmF5LWl0ZW0tc3RyaW5nXCIpIHtcbiAgICAgICAgLy8gY29udmVydHMgRCsnICtsYXQ9MzknK3UrQ08gaW50byBbXCJEXCIsIFwiJyArbGF0PTM5J1wiLCBcInVcIiwgXCJDT1wiXSwgc28gY2FuIGJlIGNvbWJpbmVkIGFnYWluIHdpdGggK1xuICAgICAgICBjb25zdCBwYXJ0cyA9IGRlY29uY2F0KHN0cmlwdGFncyhzdHIpKTtcblxuICAgICAgICBjb25zdCBzd2FwcGVkID0gW107XG5cbiAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIHN3YXBwZWQucHVzaChwYXJ0c1swXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gY2FuIG9ubHkgcmVwbGFjZSBiaWdyYW1zIGlmIGhhdmUgbW9yZSB0aGFuIG9uZSBncmFtXG4gICAgICAgICAgZm9yIChsZXQgcCA9IDE7IHAgPCBwYXJ0cy5sZW5ndGg7IHArKykge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJwOlwiLCBwKTtcbiAgICAgICAgICAgIGNvbnN0IHByZXYgPSBwYXJ0c1twIC0gMV07XG4gICAgICAgICAgICBjb25zdCBjdXJyID0gcGFydHNbcF07XG4gICAgICAgICAgICBjb25zdCBiaWdyYW0gPSBbcHJldiwgY3Vycl07XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcImJpZ3JhbTtcIiwgYmlncmFtKTtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IEpTT04uc3RyaW5naWZ5KGJpZ3JhbSk7XG4gICAgICAgICAgICBpZiAoa2V5IGluIGJpZ3JhbV90b192YXJuYW1lKSB7XG4gICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwicmVwbGFjaW5nXCIpO1xuICAgICAgICAgICAgICBjb25zdCB2YXJuYW1lID0gYmlncmFtX3RvX3Zhcm5hbWVba2V5XS52YXJuYW1lO1xuICAgICAgICAgICAgICBzd2FwcGVkLnB1c2godmFybmFtZSk7XG4gICAgICAgICAgICAgIHVzZWRWYXJOYW1lcy5hZGQodmFybmFtZSk7XG4gICAgICAgICAgICAgIGFjdHVhbF9iaWdyYW1fdG9fdmFybmFtZVtrZXldID0geyBiaWdyYW0sIHZhcm5hbWUgfTtcbiAgICAgICAgICAgICAgcCsrOyAvLyBza2lwIGNoZWNraW5nIHRoZSBuZXh0IGJpZ3JhbSAoYmVjYXVzZSBjdXJyIHdvdWxkIGJlIHByZXYgZm9yIHRoYXQpXG5cbiAgICAgICAgICAgICAgLy8gdGhlcmUncyBvbmx5IG9uZSBncmFtIGxlZnQsIHNvIHdlIGtub3cgdGhhdCBpdCB3b24ndCBiZSByZXBsYWNlZFxuICAgICAgICAgICAgICBpZiAocCA9PT0gcGFydHMubGVuZ3RoIC0gMSkgc3dhcHBlZC5wdXNoKHBhcnRzW3BdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN3YXBwZWQucHVzaChwcmV2KTtcbiAgICAgICAgICAgICAgaWYgKHAgPT09IHBhcnRzLmxlbmd0aCAtIDEpIHN3YXBwZWQucHVzaChjdXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwic3dhcHBlZDpcIiwgc3dhcHBlZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwicmVwbGFjZWRcIiwgcGFydHMsIFwid2l0aFwiLCBzd2FwcGVkKTtcblxuICAgICAgICBjb25zdCBuZXdTdHIgPSAoaGFzRGVsUHJldiA/IGRlbHByZXYgOiBcIlwiKSArIHN3YXBwZWQuam9pbihcIitcIikgKyAoaGFzRGVsTmV4dCA/IGRlbG5leHQgOiBcIlwiKTtcblxuICAgICAgICBtb2QodW5lc2NwKG5ld1N0cikpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8vIGNvbnNvbGUubG9nKGFjdHVhbF9iaWdyYW1fdG9fdmFybmFtZSk7XG4gICAgaWYgKE9iamVjdC5rZXlzKGFjdHVhbF9iaWdyYW1fdG9fdmFybmFtZSkubGVuZ3RoID4gMCkge1xuICAgICAgYWN0dWFsX2JpZ3JhbV90b192YXJuYW1lX3Bhc3Nlcy5wdXNoKGFjdHVhbF9iaWdyYW1fdG9fdmFybmFtZSk7XG4gICAgfVxuICB9XG5cbiAgbGV0IG91dGNvZGUgPSBcIlwiO1xuXG4gIC8vIGFkZCBpbiBudWxsID0gXCJOb25lXCJcbiAgLy8gZm9yIFB5dGhvblxuICAvLyBiZWNhdXNlIEpTT04uc3RyaW5naWZ5IHdpbGwgd3JpdGUgaW4gbnVsbCB2YWx1ZXNcbiAgaWYgKGxhbmcgPT09IFwiUFlcIikge1xuICAgIG91dGNvZGUgKz0gXCIjIHNwZWNpYWwgaGFuZGxpbmcgZm9yIFB5dGhvblxcbm51bGwgPSBOb25lXFxudW5kZWZpbmVkID0gTm9uZVxcblwiXG4gIH1cblxuICAvLyBmaXJzdCBkZWNsYXJlIHRoZSBmaXJzdCB2YXJpYWJsZSByZXBsYWNlbWVudHNcbiAgb3V0Y29kZSArPSBkZWNsYXJlVmFycyh7XG4gICAgY29tbWVudDogXCJwYXNzIDFcIixcbiAgICBsYW5ndWFnZTogbGFuZyxcbiAgICB2YXJzOiBBcnJheS5mcm9tKHZhcm5hbWUydG9rZW4uZW50cmllcygpKS5tYXAoKFtuYW1lLCB7IHRva2VuIH1dKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHRva2VuID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiB7IG5hbWUsIHZhbHVlOiB0b2tlbiB9O1xuICAgICAgfSBlbHNlIGlmICh0b2tlbiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4geyBuYW1lLCB2YWx1ZTogXCJudWxsXCIsIHJhdzogdHJ1ZSB9O1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdG9rZW4gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmV0dXJuIHsgbmFtZSwgdmFsdWU6IFwidW5kZWZpbmVkXCIsIHJhdzogdHJ1ZSB9O1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdG9rZW4gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIHsgbmFtZSwgdmFsdWU6IHRva2VuLnRvU3RyaW5nKCksIHJhdzogdHJ1ZSB9O1xuICAgICAgfVxuICAgIH0pLFxuICB9KTtcblxuICBhY3R1YWxfYmlncmFtX3RvX3Zhcm5hbWVfcGFzc2VzLmZvckVhY2goKGFjdHVhbF9iaWdyYW1fdG9fdmFybmFtZSwgaSkgPT4ge1xuICAgIG91dGNvZGUgKz0gXCJcXG5cXG5cIjtcbiAgICBvdXRjb2RlICs9IGRlY2xhcmVWYXJzKHtcbiAgICAgIGNvbW1lbnQ6IFwicGFzcyBcIiArIChpICsgMiksXG4gICAgICBsYW5ndWFnZTogbGFuZyxcbiAgICAgIHZhcnM6IE9iamVjdC52YWx1ZXMoYWN0dWFsX2JpZ3JhbV90b192YXJuYW1lKS5tYXAoKHsgYmlncmFtLCB2YXJuYW1lIH0pID0+ICh7IG5hbWU6IHZhcm5hbWUsIHZhbHVlOiBiaWdyYW0uam9pbihcIitcIiksIHJhdzogdHJ1ZSB9KSksXG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIHByb2Nlc3MgdGhlIHRleHQgb3BlcmF0aW9uc1xuICBjb25zdCBwcm9jZXNzZWRKU09OID0gSlNPTi5zdHJpbmdpZnkocmVzdWx0LCB1bmRlZmluZWQsIHNwYWNlcilcbiAgICAucmVwbGFjZUFsbChuZXcgUmVnRXhwKGAuJHtkZWxwcmV2fWAsIFwiZ1wiKSwgXCJcIilcbiAgICAucmVwbGFjZUFsbChuZXcgUmVnRXhwKGAke2RlbG5leHR9LmAsIFwiZ1wiKSwgXCJcIik7XG5cbiAgb3V0Y29kZSArPSBcIlxcblwiO1xuICBvdXRjb2RlICs9IGAke3ByZWZpeH0gPSAke3Byb2Nlc3NlZEpTT059O2A7XG5cbiAgcmV0dXJuIHsgY29kZTogb3V0Y29kZSB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7IGVuY29kZSB9O1xuIiwiY29uc3QgaXRlciA9ICh7IGlucHQsIGZ1bmMsIGNiLCB0aGlzQXJnIH0pID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBsZW5ndGggPSBpbnB0Lmxlbmd0aDtcblxuICAgIC8vIHNoYWxsb3ctY29weSBvcmlnaW4gYXJyYXlcbiAgICBjb25zdCBvcmlnaW5hbEFycmF5ID0gQXJyYXkuZnJvbShpbnB0KTtcblxuICAgIGNvbnN0IGZpcnN0VmFsdWUgPSBvcmlnaW5hbEFycmF5WzBdO1xuICAgIGNvbnN0IGxhc3RWYWx1ZSA9IG9yaWdpbmFsQXJyYXlbbGVuZ3RoIC0gMV07XG5cbiAgICByZXR1cm4gaW5wdFtmdW5jXSgodmFsdWUsIGksIGFycmF5KSA9PiB7XG4gICAgICByZXR1cm4gY2Ioe1xuICAgICAgICB2YWx1ZSxcbiAgICAgICAgY3VycmVudFZhbHVlOiB2YWx1ZSxcbiAgICAgICAgZWxlbWVudDogdmFsdWUsXG4gICAgICAgIGl0ZW06IHZhbHVlLFxuICAgICAgICBpdDogdmFsdWUsXG5cbiAgICAgICAgZmlyc3RWYWx1ZSxcbiAgICAgICAgZmlyc3RFbGVtZW50OiBmaXJzdFZhbHVlLFxuICAgICAgICBmaXJzdEl0ZW06IGZpcnN0VmFsdWUsXG4gICAgICAgIGZpcnN0SXQ6IGZpcnN0VmFsdWUsXG5cbiAgICAgICAgbGFzdFZhbHVlLFxuICAgICAgICBsYXN0RWxlbWVudDogbGFzdFZhbHVlLFxuICAgICAgICBsYXN0SXRlbTogbGFzdFZhbHVlLFxuICAgICAgICBsYXN0SXQ6IGxhc3RWYWx1ZSxcblxuICAgICAgICBpLFxuICAgICAgICBpbmRleDogaSxcblxuICAgICAgICBhcnJheSxcblxuICAgICAgICBnZXQgcGVyY2VudCgpIHsgcmV0dXJuIChpICsgMSkgLyBsZW5ndGg7IH0sXG5cbiAgICAgICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIGxlbmd0aDsgfSxcblxuICAgICAgICBnZXQgcHJldmlvdXMoKSB7IHJldHVybiBvcmlnaW5hbEFycmF5W2kgLSAxXTsgfSxcbiAgICAgICAgZ2V0IHByZXYoKSB7IHJldHVybiBvcmlnaW5hbEFycmF5W2kgLSAxXTsgfSxcblxuICAgICAgICBnZXQgbmV4dCgpIHsgcmV0dXJuIG9yaWdpbmFsQXJyYXlbaSArIDFdOyB9LFxuXG4gICAgICAgIGdldCBiZWZvcmUoKSB7IHJldHVybiBvcmlnaW5hbEFycmF5LnNsaWNlKDAsIGkpOyB9LFxuICAgICAgICBnZXQgYWZ0ZXIoKSB7IHJldHVybiBvcmlnaW5hbEFycmF5LnNsaWNlKGkgKyAxKTsgfSxcblxuICAgICAgICBicms6IChuPTEpID0+IHsgdGhyb3cgYFthZHZhcnJdIGJyZWFraW5nICR7bn1gOyB9LFxuXG4gICAgICAgIC8vIG9yZGluYWwgbnVtYmVyc1xuICAgICAgICBmaXJzdDogaSA9PT0gMCxcbiAgICAgICAgc2Vjb25kOiBpID09PSAxLFxuICAgICAgICB0aGlyZDogaSA9PT0gMixcbiAgICAgICAgZm91cnRoOiBpID09PSAzLFxuICAgICAgICBmaWZ0aDogaSA9PT0gNCxcbiAgICAgICAgc2l4dGg6IGkgPT09IDUsXG4gICAgICAgIHNldmVudGg6IGkgPT09IDYsXG4gICAgICAgIGVpZ3RoOiBpID09PSA3LFxuICAgICAgICBuaW50aDogaSA9PT0gOCxcbiAgICAgICAgdGVudGg6IGkgPT09IDksXG5cbiAgICAgICAgbGFzdDogaSA9PT0gbGVuZ3RoIC0gMSxcbiAgICAgICAgcGVudWx0aW1hdGU6IGkgPT09IGxlbmd0aCAtIDIsXG4gICAgICAgIGFudGVwZW51bHRpbWF0ZTogaSA9PT0gbGVuZ3RoIC0gMyxcblxuICAgICAgICBvZGQ6IGkgJSAyID09PSAxLFxuICAgICAgICBldmVuOiBpICUgMiA9PT0gMCxcbiAgICAgIH0pO1xuICAgIH0sIHRoaXNBcmcpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGxldCBtc2cgPSBlcnJvci50b1N0cmluZygpO1xuICAgIGlmICghbXNnLmluY2x1ZGVzKFwiW2FkdmFycl0gYnJlYWtpbmcgMVwiKSkge1xuICAgICAgaWYgKG1zZy5pbmNsdWRlcyhcIlthZHZhcnJdIGJyZWFraW5nXCIpKSB7XG4gICAgICAgIGNvbnN0IG4gPSBwYXJzZUludChtc2dbbXNnLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgbXNnID0gXCJbYWR2YXJyXSBicmVha2luZyBcIiArIChuIC0gMSk7XG4gICAgICB9XG4gICAgICB0aHJvdyBtc2c7XG4gICAgfVxuICB9XG59O1xuXG5jb25zdCBhZHZhcnIgPSB7fTtcbltcImV2ZXJ5XCIsIFwiZmlsdGVyXCIsIFwiZmluZFwiLCBcImZpbmRJbmRleFwiLCBcImZsYXRNYXBcIiwgXCJmb3JFYWNoXCIsIFwibWFwXCIsIFwic29tZVwiXS5mb3JFYWNoKGtleSA9PiB7XG4gIGFkdmFycltrZXldID0gKGlucHQsIGNiLCB0aGlzQXJnKSA9PiBpdGVyKHsgaW5wdCwgZnVuYzoga2V5LCBjYiwgdGhpc0FyZyB9KTtcbn0pO1xuXG5pZiAodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiKSBtb2R1bGUuZXhwb3J0cyA9IGFkdmFycjtcbmlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSB3aW5kb3cuYWR2YXJyID0gYWR2YXJyO1xuaWYgKHR5cGVvZiBzZWxmID09PSBcIm9iamVjdFwiKSBzZWxmLmFkdmFyciA9IGFkdmFycjtcbiIsImNvbnN0IGRlY29uY2F0ID0gKHN0ciwgZGVidWcpID0+IHtcbiAgY29uc3QgdG9rZW5zID0gW107XG4gIGxldCBpblN0cmluZyA9IGZhbHNlO1xuICBsZXQgY3VycmVudCA9ICcnO1xuICBsZXQgcXVvdGVjaGFyID0gbnVsbDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjaGFyID0gc3RyW2ldO1xuICAgIGlmIChkZWJ1ZykgY29uc29sZS5sb2coXCJjaGFyOlwiLCBjaGFyKTtcbiAgICBpZiAoY2hhciA9PT0gXCIrXCIpIHtcbiAgICAgIGlmIChpblN0cmluZykge1xuICAgICAgICBjdXJyZW50ICs9IGNoYXI7XG4gICAgICB9IGVsc2UgaWYgKGN1cnJlbnQgIT09ICcnKSB7XG4gICAgICAgIHRva2Vucy5wdXNoKGN1cnJlbnQpO1xuICAgICAgICBjdXJyZW50ID0gXCJcIjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNoYXIgPT09IGAnYCB8fCBjaGFyID09PSBgXCJgIHx8IGNoYXIgPT09IFwiYFwiKSB7XG4gICAgICBjdXJyZW50ICs9IGNoYXI7XG4gICAgICBpZiAoaW5TdHJpbmcpIHtcbiAgICAgICAgaWYgKGNoYXIgPT09IHF1b3RlY2hhciAmJiBzdHJbaS0xXSAhPT0gXCJcXFxcXCIpIGluU3RyaW5nID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpblN0cmluZyA9IHRydWU7XG4gICAgICAgIHF1b3RlY2hhciA9IGNoYXI7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjaGFyID09PSBgIGApIHtcbiAgICAgIGlmIChpblN0cmluZykgY3VycmVudCArPSBjaGFyO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50ICs9IGNoYXI7XG4gICAgfVxuICB9XG4gIGlmIChjdXJyZW50ICE9PSAnJykgdG9rZW5zLnB1c2goY3VycmVudCk7XG4gIHJldHVybiB0b2tlbnM7XG59XG5cbmlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiKSBtb2R1bGUuZXhwb3J0cyA9IGRlY29uY2F0O1xuaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpIHdpbmRvdy5kZWNvbmNhdCA9IGRlY29uY2F0O1xuaWYgKHR5cGVvZiBzZWxmID09PSBcIm9iamVjdFwiKSBzZWxmLmRlY29uY2F0ID0gZGVjb25jYXQ7XG5cbiIsImNvbnN0IHsgZm9yRWFjaCB9ID0gcmVxdWlyZShcImFkdmFyclwiKTtcblxuY29uc3QgbWVyZ2UgPSByZXF1aXJlKFwiLi9tZXJnZS1jb3VudHNcIik7XG5cbmNvbnN0IGNvdW50ID0gKG9wdGlvbnMpID0+IHtcbiAgbGV0IHtcbiAgICBkYXRhLFxuICAgIGRlYnVnX2xldmVsPTAsXG4gICAgY291bnRfbnVtYmVycz10cnVlLFxuICAgIGNvdW50X3N0cmluZ3M9dHJ1ZSxcbiAgICBzcGxpdF9zdHJpbmdzX29uPVwiIFwiXG4gIH0gPSBvcHRpb25zO1xuXG4gIGlmIChkZWJ1Z19sZXZlbCA+PSAxKSBjb25zb2xlLmxvZyhcIltkZWVwLWNvdW50ZXJdIG9wdGlvbnM6XCIsIG9wdGlvbnMpO1xuXG4gIGlmICghKCdkYXRhJyBpbiBvcHRpb25zKSkgdGhyb3cgbmV3IEVycm9yKFwiW2RlZXAtY291bnRlcl0geW91IGNhbGxlZCBjb3VudCB3aXRob3V0IGEgZGF0YSBwcm9wZXJ0eSBzZXRcIilcblxuICBjb25zdCByZXN1bHRzID0ge1xuICAgIHN0cmluZ3M6IHt9LFxuICAgIG51bWJlcnM6IHt9LFxuICAgIG51bGw6IDAsXG4gICAgdW5kZWZpbmVkOiAwXG4gIH07XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICBmb3JFYWNoKGRhdGEsICh7IHZhbHVlIH0pID0+IHtcbiAgICAgIG1lcmdlKHtcbiAgICAgICAgZnJvbTogY291bnQoeyAuLi5vcHRpb25zLCBkYXRhOiB2YWx1ZSB9KSxcbiAgICAgICAgaW50bzogcmVzdWx0c1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoZGF0YSA9PT0gbnVsbCkge1xuICAgIHJlc3VsdHMubnVsbCsrO1xuICB9IGVsc2UgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgIHJlc3VsdHMudW5kZWZpbmVkKys7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGRhdGEgPT09IFwib2JqZWN0XCIpIHtcbiAgICBtZXJnZSh7XG4gICAgICBmcm9tOiBjb3VudCh7IC4uLm9wdGlvbnMsIGRhdGE6IE9iamVjdC5rZXlzKGRhdGEpIH0pLFxuICAgICAgaW50bzogcmVzdWx0c1xuICAgIH0pO1xuICAgIG1lcmdlKHtcbiAgICAgIGZyb206IGNvdW50KHsgLi4ub3B0aW9ucywgZGF0YTogT2JqZWN0LnZhbHVlcyhkYXRhKSB9KSxcbiAgICAgIGludG86IHJlc3VsdHNcbiAgICB9KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgIGlmIChjb3VudF9zdHJpbmdzKSB7XG4gICAgICBjb25zdCB0b2tlbnMgPSBkYXRhLnNwbGl0KHNwbGl0X3N0cmluZ3Nfb24pO1xuICAgICAgZm9yRWFjaCh0b2tlbnMsICh7IHZhbHVlOiB0b2tlbiwgbGFzdCwgZmlyc3QgfSkgPT4geyAgICBcbiAgICAgICAgaWYgKHRva2VuIGluIHJlc3VsdHMuc3RyaW5ncykge1xuICAgICAgICAgIHJlc3VsdHMuc3RyaW5nc1t0b2tlbl0uY291bnQrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHRzLnN0cmluZ3NbdG9rZW5dID0ge1xuICAgICAgICAgICAgdmFsdWU6IHRva2VuLFxuICAgICAgICAgICAgY291bnQ6IDEsXG4gICAgICAgICAgICBmaXJzdDogMCxcbiAgICAgICAgICAgIGxhc3Q6IDBcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaXJzdCkgcmVzdWx0cy5zdHJpbmdzW3Rva2VuXS5maXJzdCsrXG4gICAgICAgIGlmIChsYXN0KSByZXN1bHRzLnN0cmluZ3NbdG9rZW5dLmxhc3QrK1xuICAgICAgfSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBkYXRhID09PSBcIm51bWJlclwiKSB7XG4gICAgaWYgKGNvdW50X251bWJlcnMpIHtcbiAgICAgIGlmIChkYXRhIGluIHJlc3VsdHMubnVtYmVycykge1xuICAgICAgICByZXN1bHRzLm51bWJlcnNbZGF0YV0uY291bnQrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdHMubnVtYmVyc1tkYXRhXSA9IHsgY291bnQ6IDEsIHZhbHVlOiBkYXRhIH07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHRzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBjb3VudDtcblxuIiwibW9kdWxlLmV4cG9ydHMgPSAoeyBmcm9tLCBpbnRvIH0pID0+IHtcbiAgT2JqZWN0LmVudHJpZXMoZnJvbSkuZm9yRWFjaCgoW3R5cGUsIGNvdW50c10pID0+IHtcbiAgICBpZiAodHlwZSBpbiBpbnRvKSB7XG4gICAgICBpZiAodHlwZW9mIGNvdW50cyA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBpbnRvW3R5cGVdICs9IGNvdW50cztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIE9iamVjdC5lbnRyaWVzKGNvdW50cykuZm9yRWFjaCgoW3Rva2VuLCBpbmZvXSkgPT4ge1xuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiaW50bzpcIiwgaW50byk7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coXCJ0eXBlOlwiLCB0eXBlKTtcbiAgICAgICAgICBpZiAodG9rZW4gaW4gaW50b1t0eXBlXSkge1xuICAgICAgICAgICAgLy8gaXRlcmF0ZSBvdmVyIHZhbHVlcyBpZiBpdCdzIGEgbnVtYmVyIGFkZCBpdFxuICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMoaW5mbykuZm9yRWFjaCgoW2tleSwgY291bnRdKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChrZXkgIT09IFwidmFsdWVcIikge1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHtrZXksIGNvdW50fSk7XG4gICAgICAgICAgICAgICAgaWYgKGtleSBpbiBpbnRvW3R5cGVdW3Rva2VuXSkge1xuICAgICAgICAgICAgICAgICAgaW50b1t0eXBlXVt0b2tlbl1ba2V5XSArPSBjb3VudDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaW50b1t0eXBlXVt0b2tlbl1ba2V5XSA9IGNvdW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGludG9bdHlwZV1bdG9rZW5dID0gaW5mbztcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpbnRvW3R5cGVdID0gY291bnRzO1xuICAgIH1cbiAgfSk7XG59O1xuIiwiY29uc3QgeyBmb3JFYWNoLCBtYXAgfSA9IHJlcXVpcmUoXCJhZHZhcnJcIik7XG5jb25zdCByZXBsYWNlS2V5ID0gcmVxdWlyZShcInJlcGxhY2Uta2V5XCIpO1xuXG4vLyB1dGlsaXR5IGZ1bmN0aW9uc1xuY29uc3QgaXNBcnkgPSAoaXQpID0+IEFycmF5LmlzQXJyYXkoaXQpO1xuY29uc3QgaXNOdWwgPSAoaXQpID0+IGl0ID09PSBudWxsO1xuY29uc3QgaXNPYmogPSAoaXQpID0+ICFBcnJheS5pc0FycmF5KGl0KSAmJiAhaXNOdWwoaXQpICYmIHR5cGVvZiBpdCA9PT0gXCJvYmplY3RcIjtcbmNvbnN0IGlzU3RyID0gKGl0KSA9PiB0eXBlb2YgaXQgPT09IFwic3RyaW5nXCI7XG5jb25zdCBpc051bSA9IChpdCkgPT4gdHlwZW9mIGl0ID09PSBcIm51bWJlclwiO1xuXG4vLyBkb2luZyBzcGxpdCBzdHJpbmdzIG9uIC8oPz0gKS8gc3BsaXRzIFwiYSBjb3cganVtcGVkXCIgdG8gWyAnYScsICcgY293JywgJyBqdW1wZWQnIF1cbmZ1bmN0aW9uIHdhbGsoe1xuICBjYWxsYmFjayxcbiAgZGF0YSxcbiAgZGVidWcgPSBmYWxzZSxcbiAgcGF0aCA9IFtdLFxuICBzcGxpdF9zdHJpbmdzX29uID0gbnVsbCwgLy8gYWx0ZXJuYXRpdmUgaXMgXCIgXCIgaWYgeW91IHdhbnQgdG8gc3BsaXQgb24gd29yZHNcbiAgaW5jbHVkZV9zZXAgPSBmYWxzZSwgLy8gZGVmYXVsdHMgdG8gaW5jbHVkaW5nIHNlcGFyYXRvciBpbiBiZWdpbmdpbmcgaWYgZXhpc3RzXG4gIG1heF9wYXRoX2xlbmd0aDogbSA9IEluZmluaXR5LFxuICBzcGxpdF9rZXlzID0gdW5kZWZpbmVkLFxufSkge1xuICAvLyBzYXZpbmcgYXJncyB0byBwYXNzIGRvd25cbiAgbGV0IGFyZ3MgPSBhcmd1bWVudHNbMF07XG5cbiAgaWYgKHNwbGl0X2tleXMgPT09IHVuZGVmaW5lZCkge1xuICAgIHNwbGl0X2tleXMgPSBzcGxpdF9zdHJpbmdzX29uICE9PSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAoZGVidWcpIGNvbnNvbGUubG9nKFwic3RhcnRpbmcgd2FsayB3aXRoIGFyZ3NcIiwgYXJncyk7XG4gIGNvbnN0IGhhc1BhdGggPSBpc0FyeShwYXRoKSAmJiBwYXRoLmxlbmd0aCA+IDA7XG4gIGNvbnN0IGlzQXJyYXlJdGVtID0gaGFzUGF0aCAmJiBpc051bShwYXRoWzBdKSAmJiBpc0FyeShwYXRoWzFdKTtcbiAgY29uc3QgaXNPYmpWYWx1ZSA9IGhhc1BhdGggJiYgaXNTdHIocGF0aFswXSkgJiYgaXNPYmoocGF0aFsxXSk7XG5cbiAgY29uc3Qgc3BsaXRfc3RyID0gKHN0cikgPT5cbiAgICBtYXAoc3RyLnNwbGl0KHNwbGl0X3N0cmluZ3Nfb24pLCAoeyBpdCwgZmlyc3QgfSkgPT4gKGluY2x1ZGVfc2VwICYmICFmaXJzdCA/IHNwbGl0X3N0cmluZ3Nfb24gOiBcIlwiKSArIGl0KTtcbiAgY29uc3Qgam9pbl9zdWJzID0gKHN1YnMpID0+IHN1YnMuam9pbihpbmNsdWRlX3NlcCA/IFwiXCIgOiBzcGxpdF9zdHJpbmdzX29uKTtcblxuICBpZiAoIWhhc1BhdGggJiYgaXNTdHIoZGF0YSkpIHRocm93IG5ldyBFcnJvcihcInlvdSBtdXN0IHBhc3MgaW4gYW4gb2JqZWN0IG9yIGFuIGFycmF5IHRvIHN0YXJ0XCIpO1xuXG4gIGlmIChpc0FyeShkYXRhKSkge1xuICAgIGRhdGEuZm9yRWFjaCgoaXRlbSwgaSkgPT4ge1xuICAgICAgaWYgKGlzU3RyKGl0ZW0pKSB7XG4gICAgICAgIGNhbGxiYWNrKHtcbiAgICAgICAgICB0eXBlOiBcImFycmF5LWl0ZW0tc3RyaW5nXCIsXG4gICAgICAgICAgZGF0YTogaXRlbSxcbiAgICAgICAgICBtb2Q6IChuZXdfaXRlbSkgPT4gKGRhdGFbaV0gPSBuZXdfaXRlbSksXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoc3BsaXRfc3RyaW5nc19vbikge1xuICAgICAgICAgIGNvbnN0IHN1Ykl0ZW1zID0gc3BsaXRfc3RyKGl0ZW0pO1xuICAgICAgICAgIGZvckVhY2goc3ViSXRlbXMsICh7IGl0OiBzdWJJdGVtLCBpbmRleDogaWksIG5leHQsIHByZXYsIGZpcnN0OiBpc0ZpcnN0U3Vic3RyLCBsYXN0OiBpc0xhc3RTdWJzdHIgfSkgPT4ge1xuICAgICAgICAgICAgY2FsbGJhY2soe1xuICAgICAgICAgICAgICB0eXBlOiBcImFycmF5LWl0ZW0tc3Vic3RyaW5nXCIsXG4gICAgICAgICAgICAgIGRhdGE6IHN1Ykl0ZW0sXG4gICAgICAgICAgICAgIG1vZDogKG5ld1N1Ykl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICBzdWJJdGVtc1tpaV0gPSBuZXdTdWJJdGVtO1xuICAgICAgICAgICAgICAgIGRhdGFbaV0gPSBzdWJJdGVtcy5qb2luKGluY2x1ZGVfc2VwID8gXCJcIiA6IHNwbGl0X3N0cmluZ3Nfb24pO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBwYXRoOiBbaWksIGl0ZW0sIGRhdGEsIC4uLnBhdGhdLFxuICAgICAgICAgICAgICBuZXh0LFxuICAgICAgICAgICAgICBwcmV2LFxuICAgICAgICAgICAgICBmaXJzdDogaXNGaXJzdFN1YnN0cixcbiAgICAgICAgICAgICAgbGFzdDogaXNMYXN0U3Vic3RyLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhbGsoeyAuLi5hcmdzLCBkYXRhOiBpdGVtLCBwYXRoOiBbaSwgZGF0YSwgLi4ucGF0aF0uc2xpY2UoMCwgbSkgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoaXNPYmooZGF0YSkpIHtcbiAgICBPYmplY3Qua2V5cyhkYXRhKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGNhbGxiYWNrKHtcbiAgICAgICAgdHlwZTogXCJvYmplY3Qta2V5LXN0cmluZ1wiLFxuICAgICAgICBkYXRhOiBrZXksXG4gICAgICAgIG1vZDogKG5ld19rZXkpID0+IHtcbiAgICAgICAgICByZXBsYWNlS2V5KHsgb2JqOiBkYXRhLCBvbGRfa2V5OiBrZXksIG5ld19rZXkgfSk7XG4gICAgICAgICAga2V5ID0gbmV3X2tleTtcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoc3BsaXRfa2V5cyAmJiBzcGxpdF9zdHJpbmdzX29uKSB7XG4gICAgICAgIGNvbnN0IHN1YktleXMgPSBzcGxpdF9zdHIoa2V5KTtcbiAgICAgICAgZm9yRWFjaChzdWJLZXlzLCAoeyBpdDogc3Via2V5LCBpLCBmaXJzdCwgbGFzdCwgcHJldiwgbmV4dCB9KSA9PiB7XG4gICAgICAgICAgY29uc3QgbW9kID0gKG5ld1N1YktleSkgPT4ge1xuICAgICAgICAgICAgc3ViS2V5c1tpXSA9IG5ld1N1YktleTtcbiAgICAgICAgICAgIGNvbnN0IG5ld19rZXkgPSBqb2luX3N1YnMoc3ViS2V5cyk7XG4gICAgICAgICAgICByZXBsYWNlS2V5KHsgb2JqOiBkYXRhLCBvbGRfa2V5OiBrZXksIG5ld19rZXkgfSk7XG4gICAgICAgICAgICBrZXkgPSBuZXdfa2V5O1xuICAgICAgICAgIH07XG4gICAgICAgICAgY2FsbGJhY2soe1xuICAgICAgICAgICAgdHlwZTogXCJvYmplY3Qta2V5LXN1YnN0cmluZ1wiLFxuICAgICAgICAgICAgZGF0YTogc3Via2V5LFxuICAgICAgICAgICAgbW9kLFxuICAgICAgICAgICAgZmlyc3QsXG4gICAgICAgICAgICBsYXN0LFxuICAgICAgICAgICAgcHJldixcbiAgICAgICAgICAgIG5leHQsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgbGV0IHZhbHVlID0gZGF0YVtrZXldO1xuICAgICAgaWYgKGRlYnVnKSBjb25zb2xlLmxvZyhcInZhbHVlOlwiLCB2YWx1ZSk7XG4gICAgICBpZiAoaXNTdHIodmFsdWUpKSB7XG4gICAgICAgIGNhbGxiYWNrKHtcbiAgICAgICAgICB0eXBlOiBcIm9iamVjdC12YWx1ZS1zdHJpbmdcIixcbiAgICAgICAgICBkYXRhOiB2YWx1ZSxcbiAgICAgICAgICBtb2Q6IChuZXdWYWx1ZSkgPT4ge1xuICAgICAgICAgICAgZGF0YVtrZXldID0gbmV3VmFsdWU7XG4gICAgICAgICAgICB2YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoc3BsaXRfc3RyaW5nc19vbikge1xuICAgICAgICAgIGNvbnN0IHN1YlZhbHVlcyA9IHNwbGl0X3N0cih2YWx1ZSk7XG4gICAgICAgICAgZm9yRWFjaChzdWJWYWx1ZXMsICh7IGl0OiBzdWJ2YWx1ZSwgaSB9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtb2QgPSAobmV3U3ViVmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgc3ViVmFsdWVzW2ldID0gbmV3U3ViVmFsdWU7XG4gICAgICAgICAgICAgIGRhdGFba2V5XSA9IGpvaW5fc3VicyhzdWJWYWx1ZXMpO1xuICAgICAgICAgICAgICBzdWJ2YWx1ZSA9IG5ld1N1YlZhbHVlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhbGxiYWNrKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3QtdmFsdWUtc3Vic3RyaW5nXCIsXG4gICAgICAgICAgICAgIGRhdGE6IHN1YnZhbHVlLFxuICAgICAgICAgICAgICBtb2QsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gd2FsayB2YWx1ZVxuICAgICAgICB3YWxrKHsgLi4uYXJncywgZGF0YTogZGF0YVtrZXldLCBwYXRoOiBbLi4ua2V5LCBkYXRhLCAuLi5wYXRoXS5zbGljZSgwLCBtKSB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBlbHNlIGlmIChkYXRhID09PSB1bmRlZmluZWQgfHwgZGF0YSA9PT0gbnVsbCB8fCB0eXBlb2YgZGF0YSA9PT0gXCJudW1iZXJcIikge1xuICAgIGlmICghaGFzUGF0aCkge1xuICAgICAgY2FsbGJhY2soe1xuICAgICAgICBkYXRhLFxuICAgICAgICBtb2Q6ICgpID0+IHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmFibGUgdG8gbW9kXCIpO1xuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5SXRlbSB8fCBpc09ialZhbHVlKSB7XG4gICAgICBsZXQgdHlwZTtcbiAgICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHR5cGUgPSBcImFycmF5LWl0ZW0tdW5kZWZpbmVkXCI7XG4gICAgICBlbHNlIGlmIChkYXRhID09PSBudWxsKSB0eXBlID0gXCJhcnJheS1pdGVtLW51bGxcIjtcbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBkYXRhID09PSBcIm51bWJlclwiKSB0eXBlID0gXCJhcnJheS1pdGVtLW51bWJlclwiO1xuICAgICAgY2FsbGJhY2soe1xuICAgICAgICBkYXRhLFxuICAgICAgICB0eXBlLFxuICAgICAgICBtb2Q6IChuZXdfdmFsdWUpID0+IHtcbiAgICAgICAgICBwYXRoWzFdW3BhdGhbMF1dID0gbmV3X3ZhbHVlO1xuICAgICAgICAgIHZhbHVlID0gbmV3X3ZhbHVlO1xuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gd2FsaztcbiIsImNvbnN0IGNvdW50X2FycmF5ID0gKHsgYXJyLCBkZWJ1ZywgbiB9KSA9PiB7XG4gICAgY29uc3QgY291bnRzID0ge307XG4gICAgaWYgKGRlYnVnKSBjb25zb2xlLmxvZyhcImFycjpcIiwgYXJyKTtcbiAgICBmb3IgKGxldCBpID0gbjsgaSA8PSBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgbmdyYW0gPSBhcnIuc2xpY2UoaSAtIG4sIGkpO1xuICAgICAgICBpZiAoZGVidWcpIGNvbnNvbGUubG9nKFwibmdyYW06XCIsIG5ncmFtKTtcbiAgICAgICAgaWYgKGNvdW50cy5oYXNPd25Qcm9wZXJ0eShuZ3JhbSkpIGNvdW50c1tuZ3JhbV0uY291bnQrKztcbiAgICAgICAgZWxzZSBjb3VudHNbbmdyYW1dID0geyBvcmlnaW5hbDogbmdyYW0sIGNvdW50OiAxIH07XG4gICAgfVxuICAgIGlmIChkZWJ1ZykgY29uc29sZS5sb2coXCJjb3VudHM6XCIsIGNvdW50cyk7XG4gICAgY29uc3Qgc29ydGVkID0gT2JqZWN0LmVudHJpZXMoY291bnRzKS5zb3J0KChhLCBiKSA9PiBNYXRoLnNpZ24oYlsxXS5jb3VudCAtIGFbMV0uY291bnQpKTtcbiAgICBpZiAoZGVidWcpIGNvbnNvbGUubG9nKFwic29ydGVkOlwiLCBzb3J0ZWQpO1xuICAgIGNvbnN0IHJlc3VsdHMgPSBzb3J0ZWQubWFwKGl0ID0+IFtpdFsxXS5vcmlnaW5hbCwgaXRbMV0uY291bnRdKTtcbiAgICBpZiAoZGVidWcpIGNvbnNvbGUubG9nKFwicmVzdWx0czpcIiwgcmVzdWx0cyk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG59XG5cbmNvbnN0IGNvdW50X3RleHQgPSAoeyB0ZXh0LCBkZWJ1ZywgbiB9KSA9PiB7XG4gICAgY29uc3QgY291bnRzID0ge307XG4gICAgaWYgKGRlYnVnKSBjb25zb2xlLmxvZyhcInRleHQ6IFwiICsgdGV4dC5zdWJzdHJpbmcoMCwgMTAwKS50cmltKCkgKyBcIi4uLlwiKTtcbiAgICBmb3IgKGxldCBpID0gbjsgaSA8PSB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG5ncmFtID0gdGV4dC5zdWJzdHJpbmcoaSAtIG4sIGkpO1xuICAgICAgICBpZiAoZGVidWcpIGNvbnNvbGUubG9nKFwibmdyYW06XCIsIG5ncmFtKTtcbiAgICAgICAgaWYgKGNvdW50cy5oYXNPd25Qcm9wZXJ0eShuZ3JhbSkpIGNvdW50c1tuZ3JhbV0rKztcbiAgICAgICAgZWxzZSBjb3VudHNbbmdyYW1dID0gMTtcbiAgICB9XG4gICAgaWYgKGRlYnVnKSBjb25zb2xlLmxvZyhcImNvdW50czpcIiwgY291bnRzKTtcbiAgICBjb25zdCBzb3J0ZWQgPSBPYmplY3QuZW50cmllcyhjb3VudHMpLnNvcnQoKGEsIGIpID0+IE1hdGguc2lnbihiWzFdIC0gYVsxXSkpO1xuICAgIGlmIChkZWJ1ZykgY29uc29sZS5sb2coXCJzb3J0ZWQ6XCIsIHNvcnRlZCk7XG4gICAgcmV0dXJuIHNvcnRlZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSAoeyBkYXRhLCBkZWJ1ZywgbiB9KSA9PiB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgcmV0dXJuIGNvdW50X2FycmF5KHsgYXJyOiBkYXRhLCBkZWJ1ZywgbiB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY291bnRfdGV4dCh7IHRleHQ6IGRhdGEsIGRlYnVnLCBuIH0pO1xuICAgIH1cbn07XG4iLCJjb25zdCByZXBsYWNlS2V5ID0gKHsgb2JqLCBvbGRfa2V5LCBuZXdfa2V5IH0pID0+IHtcbiAgaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgRXJyb3IoYFtyZXBsYWNlLWtleV0gb2JqIGlzIG5vdCBhbiBvYmplY3RcImApO1xuICBpZiAoIShvbGRfa2V5IGluIG9iaikpIHRocm93IG5ldyBFcnJvcihgW3JlcGxhY2Uta2V5XSBcIiR7b2xkX2tleX1cIiBpcyBub3QgYSBrZXkgb2Ygb2JqYCk7XG4gIG9ialtuZXdfa2V5XSA9IG9ialtvbGRfa2V5XTtcbiAgZGVsZXRlIG9ialtvbGRfa2V5XTtcbiAgcmV0dXJuIG9iajtcbn1cblxuaWYgKHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIpIG1vZHVsZS5leHBvcnRzID0gcmVwbGFjZUtleTtcbmlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSB3aW5kb3cucmVwbGFjZUtleSA9IHJlcGxhY2VLZXk7XG5pZiAodHlwZW9mIHNlbGYgPT09IFwib2JqZWN0XCIpIHNlbGYucmVwbGFjZUtleSA9IHJlcGxhY2VLZXk7XG4iLCJjb25zdCBzZXBhcm8gPSAoc3RyLCBzZXA9JyAnLCB7IGF0dGFjaFNlcD1mYWxzZSwga2VlcFNlcD1mYWxzZSB9ID0geyBhdHRhY2hTZXA6IGZhbHNlLCBrZWVwU2VwOiBmYWxzZSB9KSA9PiB7XG4gIGlmICh0eXBlb2Ygc2VwID09PSAnc3RyaW5nJykgc2VwID0gbmV3IFNldChbc2VwXSk7XG4gIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoc2VwKSkgc2VwID0gbmV3IFNldChzZXApO1xuXG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBsZXQgY3VycmVudCA9ICcnO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNoYXIgPSBzdHJbaV07XG4gICAgaWYgKHNlcC5oYXMoY2hhcikpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGN1cnJlbnQpO1xuICAgICAgaWYgKGF0dGFjaFNlcCkge1xuICAgICAgICBjdXJyZW50ID0gY2hhcjtcbiAgICAgIH0gZWxzZSBpZiAoa2VlcFNlcCkge1xuICAgICAgICByZXN1bHQucHVzaChjaGFyKTtcbiAgICAgICAgY3VycmVudCA9ICcnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VycmVudCA9ICcnO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50ICs9IGNoYXI7XG4gICAgfVxuICB9XG4gIGlmIChjdXJyZW50Lmxlbmd0aCA+IDApIHJlc3VsdC5wdXNoKGN1cnJlbnQpO1xuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5pZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpIG1vZHVsZS5leHBvcnRzID0gc2VwYXJvO1xuaWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnKSB3aW5kb3cuc2VwYXJvID0gc2VwYXJvO1xuaWYgKHR5cGVvZiBzZWxmID09PSAnb2JqZWN0Jykgc2VsZi5zZXBhcm8gPSBzZXBhcm87XG4iLCIndXNlIHN0cmljdCc7XG5cbihmdW5jdGlvbiAoZ2xvYmFsKSB7XG5cbiAgICAvLyBtaW5pbWFsIHN5bWJvbCBwb2x5ZmlsbCBmb3IgSUUxMSBhbmQgb3RoZXJzXG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIFN5bWJvbCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgU3ltYm9sLm5vbk5hdGl2ZSA9IHRydWU7XG4gICAgfVxuXG4gICAgY29uc3QgU1RBVEVfUExBSU5URVhUID0gU3ltYm9sKCdwbGFpbnRleHQnKTtcbiAgICBjb25zdCBTVEFURV9IVE1MICAgICAgPSBTeW1ib2woJ2h0bWwnKTtcbiAgICBjb25zdCBTVEFURV9DT01NRU5UICAgPSBTeW1ib2woJ2NvbW1lbnQnKTtcblxuICAgIGNvbnN0IEFMTE9XRURfVEFHU19SRUdFWCAgPSAvPChcXHcqKT4vZztcbiAgICBjb25zdCBOT1JNQUxJWkVfVEFHX1JFR0VYID0gLzxcXC8/KFteXFxzXFwvPl0rKS87XG5cbiAgICBmdW5jdGlvbiBzdHJpcHRhZ3MoaHRtbCwgYWxsb3dhYmxlX3RhZ3MsIHRhZ19yZXBsYWNlbWVudCkge1xuICAgICAgICBodG1sICAgICAgICAgICAgPSBodG1sIHx8ICcnO1xuICAgICAgICBhbGxvd2FibGVfdGFncyAgPSBhbGxvd2FibGVfdGFncyB8fCBbXTtcbiAgICAgICAgdGFnX3JlcGxhY2VtZW50ID0gdGFnX3JlcGxhY2VtZW50IHx8ICcnO1xuXG4gICAgICAgIGxldCBjb250ZXh0ID0gaW5pdF9jb250ZXh0KGFsbG93YWJsZV90YWdzLCB0YWdfcmVwbGFjZW1lbnQpO1xuXG4gICAgICAgIHJldHVybiBzdHJpcHRhZ3NfaW50ZXJuYWwoaHRtbCwgY29udGV4dCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5pdF9zdHJpcHRhZ3Nfc3RyZWFtKGFsbG93YWJsZV90YWdzLCB0YWdfcmVwbGFjZW1lbnQpIHtcbiAgICAgICAgYWxsb3dhYmxlX3RhZ3MgID0gYWxsb3dhYmxlX3RhZ3MgfHwgW107XG4gICAgICAgIHRhZ19yZXBsYWNlbWVudCA9IHRhZ19yZXBsYWNlbWVudCB8fCAnJztcblxuICAgICAgICBsZXQgY29udGV4dCA9IGluaXRfY29udGV4dChhbGxvd2FibGVfdGFncywgdGFnX3JlcGxhY2VtZW50KTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gc3RyaXB0YWdzX3N0cmVhbShodG1sKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyaXB0YWdzX2ludGVybmFsKGh0bWwgfHwgJycsIGNvbnRleHQpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHN0cmlwdGFncy5pbml0X3N0cmVhbWluZ19tb2RlID0gaW5pdF9zdHJpcHRhZ3Nfc3RyZWFtO1xuXG4gICAgZnVuY3Rpb24gaW5pdF9jb250ZXh0KGFsbG93YWJsZV90YWdzLCB0YWdfcmVwbGFjZW1lbnQpIHtcbiAgICAgICAgYWxsb3dhYmxlX3RhZ3MgPSBwYXJzZV9hbGxvd2FibGVfdGFncyhhbGxvd2FibGVfdGFncyk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFsbG93YWJsZV90YWdzIDogYWxsb3dhYmxlX3RhZ3MsXG4gICAgICAgICAgICB0YWdfcmVwbGFjZW1lbnQ6IHRhZ19yZXBsYWNlbWVudCxcblxuICAgICAgICAgICAgc3RhdGUgICAgICAgICA6IFNUQVRFX1BMQUlOVEVYVCxcbiAgICAgICAgICAgIHRhZ19idWZmZXIgICAgOiAnJyxcbiAgICAgICAgICAgIGRlcHRoICAgICAgICAgOiAwLFxuICAgICAgICAgICAgaW5fcXVvdGVfY2hhciA6ICcnXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RyaXB0YWdzX2ludGVybmFsKGh0bWwsIGNvbnRleHQpIHtcbiAgICAgICAgbGV0IGFsbG93YWJsZV90YWdzICA9IGNvbnRleHQuYWxsb3dhYmxlX3RhZ3M7XG4gICAgICAgIGxldCB0YWdfcmVwbGFjZW1lbnQgPSBjb250ZXh0LnRhZ19yZXBsYWNlbWVudDtcblxuICAgICAgICBsZXQgc3RhdGUgICAgICAgICA9IGNvbnRleHQuc3RhdGU7XG4gICAgICAgIGxldCB0YWdfYnVmZmVyICAgID0gY29udGV4dC50YWdfYnVmZmVyO1xuICAgICAgICBsZXQgZGVwdGggICAgICAgICA9IGNvbnRleHQuZGVwdGg7XG4gICAgICAgIGxldCBpbl9xdW90ZV9jaGFyID0gY29udGV4dC5pbl9xdW90ZV9jaGFyO1xuICAgICAgICBsZXQgb3V0cHV0ICAgICAgICA9ICcnO1xuXG4gICAgICAgIGZvciAobGV0IGlkeCA9IDAsIGxlbmd0aCA9IGh0bWwubGVuZ3RoOyBpZHggPCBsZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgICAgICBsZXQgY2hhciA9IGh0bWxbaWR4XTtcblxuICAgICAgICAgICAgaWYgKHN0YXRlID09PSBTVEFURV9QTEFJTlRFWFQpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnPCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSAgICAgICA9IFNUQVRFX0hUTUw7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YWdfYnVmZmVyICs9IGNoYXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0ICs9IGNoYXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVsc2UgaWYgKHN0YXRlID09PSBTVEFURV9IVE1MKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJzwnOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlICc8JyBpZiBpbnNpZGUgYSBxdW90ZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluX3F1b3RlX2NoYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UncmUgc2VlaW5nIGEgbmVzdGVkICc8J1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVwdGgrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJz4nOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlICc+JyBpZiBpbnNpZGUgYSBxdW90ZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluX3F1b3RlX2NoYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc29tZXRoaW5nIGxpa2UgdGhpcyBpcyBoYXBwZW5pbmc6ICc8PD4+J1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlcHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVwdGgtLTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIGNsb3NpbmcgdGhlIHRhZyBpbiB0YWdfYnVmZmVyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbl9xdW90ZV9jaGFyID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSAgICAgICAgID0gU1RBVEVfUExBSU5URVhUO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFnX2J1ZmZlciAgICs9ICc+JztcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFsbG93YWJsZV90YWdzLmhhcyhub3JtYWxpemVfdGFnKHRhZ19idWZmZXIpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dCArPSB0YWdfYnVmZmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQgKz0gdGFnX3JlcGxhY2VtZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWdfYnVmZmVyID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICdcIic6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1xcJyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXRjaCBib3RoIHNpbmdsZSBhbmQgZG91YmxlIHF1b3Rlc1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hhciA9PT0gaW5fcXVvdGVfY2hhcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluX3F1b3RlX2NoYXIgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5fcXVvdGVfY2hhciA9IGluX3F1b3RlX2NoYXIgfHwgY2hhcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdGFnX2J1ZmZlciArPSBjaGFyO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFnX2J1ZmZlciA9PT0gJzwhLScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IFNUQVRFX0NPTU1FTlQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZ19idWZmZXIgKz0gY2hhcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJyAnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdcXG4nOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhZ19idWZmZXIgPT09ICc8Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlICAgICAgPSBTVEFURV9QTEFJTlRFWFQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0ICAgICs9ICc8ICc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnX2J1ZmZlciA9ICcnO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZ19idWZmZXIgKz0gY2hhcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICB0YWdfYnVmZmVyICs9IGNoYXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVsc2UgaWYgKHN0YXRlID09PSBTVEFURV9DT01NRU5UKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJz4nOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhZ19idWZmZXIuc2xpY2UoLTIpID09ICctLScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjbG9zZSB0aGUgY29tbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gU1RBVEVfUExBSU5URVhUO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWdfYnVmZmVyID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgdGFnX2J1ZmZlciArPSBjaGFyO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2F2ZSB0aGUgY29udGV4dCBmb3IgZnV0dXJlIGl0ZXJhdGlvbnNcbiAgICAgICAgY29udGV4dC5zdGF0ZSAgICAgICAgID0gc3RhdGU7XG4gICAgICAgIGNvbnRleHQudGFnX2J1ZmZlciAgICA9IHRhZ19idWZmZXI7XG4gICAgICAgIGNvbnRleHQuZGVwdGggICAgICAgICA9IGRlcHRoO1xuICAgICAgICBjb250ZXh0LmluX3F1b3RlX2NoYXIgPSBpbl9xdW90ZV9jaGFyO1xuXG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VfYWxsb3dhYmxlX3RhZ3MoYWxsb3dhYmxlX3RhZ3MpIHtcbiAgICAgICAgbGV0IHRhZ19zZXQgPSBuZXcgU2V0KCk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBhbGxvd2FibGVfdGFncyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGxldCBtYXRjaDtcblxuICAgICAgICAgICAgd2hpbGUgKChtYXRjaCA9IEFMTE9XRURfVEFHU19SRUdFWC5leGVjKGFsbG93YWJsZV90YWdzKSkpIHtcbiAgICAgICAgICAgICAgICB0YWdfc2V0LmFkZChtYXRjaFsxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBlbHNlIGlmICghU3ltYm9sLm5vbk5hdGl2ZSAmJlxuICAgICAgICAgICAgICAgICB0eXBlb2YgYWxsb3dhYmxlX3RhZ3NbU3ltYm9sLml0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJykge1xuXG4gICAgICAgICAgICB0YWdfc2V0ID0gbmV3IFNldChhbGxvd2FibGVfdGFncyk7XG4gICAgICAgIH1cblxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgYWxsb3dhYmxlX3RhZ3MuZm9yRWFjaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gSUUxMSBjb21wYXRpYmxlXG4gICAgICAgICAgICBhbGxvd2FibGVfdGFncy5mb3JFYWNoKHRhZ19zZXQuYWRkLCB0YWdfc2V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0YWdfc2V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZV90YWcodGFnX2J1ZmZlcikge1xuICAgICAgICBsZXQgbWF0Y2ggPSBOT1JNQUxJWkVfVEFHX1JFR0VYLmV4ZWModGFnX2J1ZmZlcik7XG5cbiAgICAgICAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKSA6IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICAvLyBBTURcbiAgICAgICAgZGVmaW5lKGZ1bmN0aW9uIG1vZHVsZV9mYWN0b3J5KCkgeyByZXR1cm4gc3RyaXB0YWdzOyB9KTtcbiAgICB9XG5cbiAgICBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgICAvLyBOb2RlXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gc3RyaXB0YWdzO1xuICAgIH1cblxuICAgIGVsc2Uge1xuICAgICAgICAvLyBCcm93c2VyXG4gICAgICAgIGdsb2JhbC5zdHJpcHRhZ3MgPSBzdHJpcHRhZ3M7XG4gICAgfVxufSh0aGlzKSk7XG4iLCJjb25zdCBhbHBoYWJldF9sb3dlciA9IFwiYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcIjtcbmNvbnN0IGFscGhhYmV0X3VwcGVyID0gYWxwaGFiZXRfbG93ZXIudG9VcHBlckNhc2UoKTtcblxuY29uc3QgREVGQVVMVF9DSEFSUyA9IEFycmF5LmZyb20oYWxwaGFiZXRfdXBwZXIgKyBhbHBoYWJldF9sb3dlcik7XG5cbmNvbnN0IERFRkFVTFRfTEFORyA9IFwiSlNcIjtcblxuY29uc3QgREVGQVVMVF9NQVhfQ09VTlQgPSAxZTY7XG5cbmNvbnN0IFJFU0VSVkVEX1dPUkRTID0ge1xuICAvLyBwcmV0dGllci1pZ25vcmVcbiAgSlM6IFtcbiAgICBcImFic3RyYWN0XCIsIFwiYWxlcnRcIiwgXCJhbGxcIiwgXCJhbmNob3JcIiwgXCJhbmNob3JzXCIsIFwiYXJlYVwiLCBcImFyZ3VtZW50c1wiLCBcImFzc2lnblwiLCBcIkFycmF5XCIsIFwiYXdhaXRcIixcbiAgICBcImJvb2xlYW5cIiwgXCJibHVyXCIsIFwiYnJlYWtcIiwgXCJidXR0b25cIiwgXCJieXRlXCIsXG4gICAgXCJjYXNlXCIsIFwiY2F0Y2hcIiwgXCJjaGFyXCIsIFwiY2hlY2tib3hcIiwgXCJjbGFzc1wiLCBcImNsZWFySW50ZXJ2YWxcIiwgXCJjbGVhclRpbWVvdXRcIiwgXCJjbGllbnRJbmZvcm1hdGlvblwiLCBcImNsb3NlXCIsIFwiY2xvc2VkXCIsIFwiY29uZmlybVwiLCBcImNvbnN0XCIsIFwiY29uc3RydWN0b3JcIiwgXCJjb250aW51ZVwiLCBcImNyeXB0b1wiLFxuICAgIFwiRGF0ZVwiLCBcImRlYnVnZ2VyXCIsIFwiZGVjb2RlVVJJXCIsIFwiZGVjb2RlVVJJQ29tcG9uZW50XCIsIFwiZGVmYXVsdFwiLCBcImRlZmF1bHRTdGF0dXNcIiwgXCJkZWxldGVcIiwgXCJkb1wiLCBcImRvY3VtZW50XCIsIFwiZG91YmxlXCIsXG4gICAgXCJlbGVtZW50XCIsIFwiZWxlbWVudHNcIiwgXCJlbHNlXCIsIFwiZW1iZWRcIiwgXCJlbWJlZHNcIiwgXCJlbmNvZGVVUklcIiwgXCJlbmNvZGVVUklDb21wb25lbnRcIiwgXCJlbnVtXCIsIFwiZXNjYXBlXCIsIFwiZXZhbFwiLCBcImV2ZW50XCIsIFwiZXhwb3J0XCIsIFwiZXh0ZW5kc1wiLFxuICAgIFwiZmFsc2VcIiwgXCJmaWxlVXBsb2FkXCIsIFwiZmluYWxcIiwgXCJmaW5hbGx5XCIsIFwiZmxvYXRcIiwgXCJmb2N1c1wiLCBcImZvclwiLCBcImZvcm1cIiwgXCJmb3Jtc1wiLCBcImZyYW1lXCIsIFwiZnJhbWVSYXRlXCIsIFwiZnJhbWVzXCIsIFwiZnVuY3Rpb25cIixcbiAgICBcImdldENsYXNzXCIsIFwiZ290b1wiLFxuICAgIFwiaGFzT3duUHJvcGVydHlcIiwgXCJoaWRkZW5cIiwgXCJoaXN0b3J5XCIsXG4gICAgXCJpZlwiLCBcImltYWdlXCIsIFwiaW1hZ2VzXCIsIFwiaW1wbGVtZW50c1wiLCBcImltcG9ydFwiLCBcImluXCIsIFwiSW5maW5pdHlcIiwgXCJpbm5lckhlaWdodFwiLCBcImlubmVyV2lkdGhcIiwgXCJpbnN0YW5jZW9mXCIsIFwiaW50XCIsIFwiaW50ZXJmYWNlXCIsIFwiaXNGaW5pdGVcIiwgXCJpc05hTlwiLCBcImlzUHJvdG90eXBlT2ZcIixcbiAgICBcImphdmFcIiwgXCJqYXZhQ2xhc3NcIiwgXCJKYXZhQXJyYXlcIiwgXCJKYXZhT2JqZWN0XCIsIFwiSmF2YVBhY2thZ2VcIixcbiAgICBcImxheWVyXCIsIFwibGF5ZXJzXCIsIFwibGVuZ3RoXCIsIFwibGV0XCIsIFwibGlua1wiLCBcImxvY2F0aW9uXCIsIFwibG9uZ1wiLFxuICAgIFwiTWF0aFwiLCBcIm1pbWVUeXBlc1wiLCBcIm1vZHVsZVwiLFxuICAgIFwibmFtZVwiLCBcIk5hTlwiLCBcIm5hdGl2ZVwiLCBcIm5hdmlnYXRlXCIsIFwibmF2aWdhdG9yXCIsIFwibmV3XCIsIFwibnVsbFwiLCBcIk51bWJlclwiLFxuICAgIFwib2Zmc2NyZWVuQnVmZmVyaW5nXCIsIFwiT2JqZWN0XCIsIFwib3BlblwiLCBcIm9wZW5lclwiLCBcIm9wdGlvblwiLCBcIm91dGVySGVpZ2h0XCIsIFwib3V0ZXJXaWR0aFwiLFxuICAgIFwicGFja2FnZVwiLCBcInBhY2thZ2VzXCIsIFwicGFnZVhPZmZzZXRcIiwgXCJwYWdlWU9mZnNldFwiLCBcInBhcmVudFwiLCBcInBhcnNlRmxvYXRcIiwgXCJwYXJzZUludFwiLCBcInBhc3N3b3JkXCIsIFwicGtjczExXCIsIFwicGx1Z2luXCIsIFwicHJpdmF0ZVwiLCBcInByb21wdFwiLCBcInByb3BlcnR5SXNFbnVtXCIsIFwicHJvdGVjdGVkXCIsIFwicHJvdG90eXBlXCIsIFwicHVibGljXCIsXG4gICAgXCJyYWRpb1wiLCBcInJlc2V0XCIsIFwicmV0dXJuXCIsXG4gICAgXCJzY3JlZW5YXCIsIFwic2NyZWVuWVwiLCBcInNjcm9sbFwiLCBcInNlY3VyZVwiLCBcInNlbGVjdFwiLCBcInNlbGZcIiwgXCJzZXRJbnRlcnZhbFwiLCBcInNldFRpbWVvdXRcIiwgXCJzaG9ydFwiLCBcInN0YXRpY1wiLCBcInN0YXR1c1wiLCBcIlN0cmluZ1wiLCBcInN1Ym1pdFwiLCBcInN1cGVyXCIsIFwic3dpdGNoXCIsIFwic3luY2hyb25pemVkXCIsXG4gICAgXCJ0ZXh0XCIsIFwidGV4dGFyZWFcIiwgXCJ0aGlzXCIsIFwidGhyb3dcIiwgXCJ0aHJvd3NcIiwgXCJ0b3BcIiwgXCJ0b1N0cmluZ1wiLCBcInRyYW5zaWVudFwiLCBcInRydWVcIiwgXCJ0cnlcIiwgXCJ0eXBlb2ZcIixcbiAgICBcInVuZGVmaW5lZFwiLCBcInVuZXNjYXBlXCIsIFwidW50YWludFwiLFxuICAgIFwidmFsdWVPZlwiLCBcInZhclwiLCBcInZvaWRcIiwgXCJ2b2xhdGlsZVwiLFxuICAgIFwid2hpbGVcIiwgXCJ3aXRoXCIsIFwid2luZG93XCIsXG4gICAgXCJ5aWVsZFwiXG4gIF0sXG59O1xuXG5mdW5jdGlvbiogZ2VuVmFyTmFtZXMoXG4gIHtcbiAgICBjaGFycyA9IERFRkFVTFRfQ0hBUlMsXG4gICAgZGVidWcgPSBmYWxzZSxcbiAgICBsYW5ndWFnZSA9IERFRkFVTFRfTEFORyxcbiAgICBtYXhfY291bnQgPSBERUZBVUxUX01BWF9DT1VOVCxcbiAgfSA9IHtcbiAgICBjaGFyczogREVGQVVMVF9DSEFSUyxcbiAgICBkZWJ1ZzogZmFsc2UsXG4gICAgbGFuZ3VhZ2U6IERFRkFVTFRfTEFORyxcbiAgICBtYXhfY291bnQ6IERFRkFVTFRfTUFYX0NPVU5ULFxuICB9XG4pIHtcbiAgY29uc3QgcmVzZXJ2ZWRfd29yZHMgPSBuZXcgU2V0KFJFU0VSVkVEX1dPUkRTW2xhbmd1YWdlXSk7XG5cbiAgbGV0IGNvdW50ID0gMDtcbiAgbGV0IGluZGV4ZXMgPSBbLTFdO1xuICBsZXQgaSA9IDA7XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAoY291bnQgPT09IG1heF9jb3VudCkgcmV0dXJuO1xuXG4gICAgaSsrO1xuXG4gICAgaWYgKGluZGV4ZXNbaW5kZXhlcy5sZW5ndGggLSAxXSA9PT0gY2hhcnMubGVuZ3RoIC0gMSkge1xuICAgICAgLy8gcmVzZXQgYXQgYWxsIEEnc1xuICAgICAgLy8gc28gaW5jcmVtZW50IHRoZSBwcmV2aW91cyBhdmFpbGFibGUgY2hhcmFjdGVyIGJ5IG9uZVxuICAgICAgLy8gc28gaWYgQUFaIGdvIHRvIEFCQVxuICAgICAgbGV0IHJlc2V0X2luZGV4ID0gbnVsbDtcbiAgICAgIGZvciAobGV0IGlpID0gaW5kZXhlcy5sZW5ndGggLSAyOyBpaSA+PSAwOyBpaS0tKSB7XG4gICAgICAgIGlmIChpbmRleGVzW2lpXSA8IGNoYXJzLmxlbmd0aCAtIDIpIHtcbiAgICAgICAgICByZXNldF9pbmRleCA9IGlpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocmVzZXRfaW5kZXggPT09IG51bGwpIHtcbiAgICAgICAgaWYgKGRlYnVnKVxuICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgXCJbdmFyLW5hbWVzXSBhZGRpbmcgYSBjaGFyYWN0ZXIgYW5kIHJlc2V0dGluZyB0byBhbGwgQSdzXCJcbiAgICAgICAgICApO1xuICAgICAgICBpbmRleGVzID0gaW5kZXhlcy5tYXAoKG4pID0+IDApLmNvbmNhdChbMF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5kZXhlc1tyZXNldF9pbmRleF0rKztcbiAgICAgICAgZm9yIChsZXQgaWkgPSByZXNldF9pbmRleCArIDE7IGlpIDwgaW5kZXhlcy5sZW5ndGg7IGlpKyspIHtcbiAgICAgICAgICBpbmRleGVzW2lpXSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaW5kZXhlc1tpbmRleGVzLmxlbmd0aCAtIDFdKys7XG4gICAgfVxuICAgIGNvbnN0IG5ld192YXJpYWJsZV9uYW1lID0gaW5kZXhlcy5tYXAoKGlpKSA9PiBjaGFyc1tpaV0pLmpvaW4oXCJcIik7XG4gICAgaWYgKHJlc2VydmVkX3dvcmRzLmhhcyhuZXdfdmFyaWFibGVfbmFtZSkpIHtcbiAgICAgIGlmIChkZWJ1ZylcbiAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgXCJbdmFyLW5hbWVzXSBza2lwcGluZyBcIiArXG4gICAgICAgICAgICBuZXdfdmFyaWFibGVfbmFtZSArXG4gICAgICAgICAgICBcImJlY2F1c2UgaXQgaXMgYSByZXNlcnZlZCB3b3JkXCJcbiAgICAgICAgKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoZGVidWcpIGNvbnNvbGUubG9nKFwiW3Zhci1uYW1lc10gdHJ5aW5nIHRvIGV2YWwgbmV3X3ZhcmlhYmxlX25hbWVcIik7XG4gICAgdHJ5IHtcbiAgICAgIGV2YWwoYGNvbnN0ICR7bmV3X3ZhcmlhYmxlX25hbWV9ID0gXCJ0ZXN0XCI7YCk7XG4gICAgICBjb3VudCsrO1xuICAgICAgeWllbGQgbmV3X3ZhcmlhYmxlX25hbWU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChkZWJ1ZykgY29uc29sZS5sb2coXCJbdmFyLW5hbWVzXSBjYW4ndCB1c2UgXCIgKyBuZXdfdmFyaWFibGVfbmFtZSk7XG4gICAgfVxuICB9XG59XG5cbmlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiKSBtb2R1bGUuZXhwb3J0cyA9IHsgZ2VuVmFyTmFtZXMgfTtcbmlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSB3aW5kb3cudmFybmFtZXMgPSB7IGdlblZhck5hbWVzIH07XG5pZiAodHlwZW9mIHNlbGYgPT09IFwib2JqZWN0XCIpIHNlbGYudmFybmFtZXMgPSB7IGdlblZhck5hbWVzIH07XG4iXX0=
